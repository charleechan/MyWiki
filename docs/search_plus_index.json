{"./":{"url":"./","title":"Introduction","keywords":"","body":"我的Wiki 更新本站 办公类(Windows/Office) | 图像类 | 管理类 | 插件类 | 工程类 |视频类 | 音频类 | 游戏类 flowchart TB 物理电子-->板级电路 板级电路-->芯片设计 计算机组成与设计/软硬件接口-->算法 算法-->HTML应用与开发 subgraph 物理电子 A1(电磁场与电磁波)-->A2(电子器件)-->A3(电路中的信号) end click A1 \"./Hardware/1_Devices/index.html\" click A2 \"./Hardware/1_Devices/index.html\" click A3 \"./Hardware/2_SigCirSys/index.html\" subgraph 板级电路 B1(模拟电路基础)-->B2(数字电路基础)-->B3(PCB设计与应用) B1-->B3 end click B1 \"./Hardware/3_AnalogCirciut/index.html\" click B2 \"./Hardware/4_DigitalCircuit/index.html\" click B3 \"./Hardware/5_PCB/index.html\" subgraph 芯片设计 C1(模拟IC设计)-->C2(数字IC RTL设计)-->C3(CPU设计)-->C4(SoC设计) C1-->C4 end click C1 \"./Hardware/6_AnalogIC/index.html\" click C2 \"./Hardware/7_DigitalIC/index.html\" click C3 \"./Hardware/8_CPU/index.html\" click C4 \"./Hardware/9_SoC/index.html\" subgraph 计算机组成与设计/软硬件接口 D1(C程序与驱动开发)--> D2(CPP程序与Qt开发) end click D1 \"./Software/1_CSTM32/index.html\" click D2 \"./Software/2_CppQt/index.html\" subgraph 算法 E1(数据结构与数据库)-->E2(信号/图像处理)-->E3(Python与AI) end click E1 \"./Software/3_Datas/index.html\" click E2 \"./Software/4_DSPISP/index.html\" click E3 \"./Software/5_PythonAI/index.html\" subgraph HTML应用与开发 F1(Markdown)-->F2(HTML/CSS/Javascript网站应用)-->F3(HTML5移动/桌面APP) F4(QML) end click F1 \"./Software/6_MD/index.html\" click F2 \"./Software/7_HCJ/index.html\" click F3 \"./Software/8_H5App/index.html\" click F4 \"./Software/9_QML/index.html\" Q&A: 两个图之间的关系是什么? CPU设计与C程序/驱动之间通过寄存器联系起来. 这就是时至今日,为啥大家还非得学习C语言,也是为啥硬件语言描述的是RTL模型. 在设计信号处理芯片DSP/图像信号处理芯片ISP时,工程中需要学习信号/图像处理算法和数字IC RTL设计结合起来. Qt开发是Qt4还是Qt5? 这里建议学习Qt4的同时学习C++,配合侯捷老师的视频课程,效果拔群. 不建议学习Qt5,因为其本质就是HTML/CSS/JS做前端页面(QML就是把它们融在一起了),后端使用C++处理数据模型.那我为啥还学习你,直接学习HTML开发,通过JS调用C++的库就可以了呀,还不用那么复杂的环境. 学习嵌入式Linux系统开发需要哪些知识呢? 学习完计算机组成与设计/软硬件接口,再学习完物理电子和板级电路即可立马去学习嵌入式Linux系统开发. 嵌入式Linux系统开发一般需要学习C程序实现底层外设硬件的驱动,学习Linux系统完成系统裁剪和移植,学习C/Qt4完成程序/驱动开发. 本站不涉及嵌入式Linux系统开发. 有专门讲TCL、Verilog HDL的吗? 没有,单独学习一门语言而不实践,是学习不到知识的,因此把TCL和Verilog HDL等已经融入在数字IC RTL设计相关教程里了. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:20:50 "},"Hardware/1_Devices/":{"url":"Hardware/1_Devices/","title":"电磁与电子器件","keywords":"","body":"内容列表 回到主页 静电场与静磁场 电容与电极化 电阻的原理与设计 电感与磁极化 经典电磁学理论基础 电磁波与天线 电磁学与电路的关系 半导体器件1-双极型晶体管(BJT) 半导体器件2-MOS管 res 资源(右键打开或下载) 1.pdf Ant.pptx kulun.vsdx Res.pptx 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Hardware/1_Devices/1_StaticEM.html":{"url":"Hardware/1_Devices/1_StaticEM.html","title":"静电场与静磁场","keywords":"","body":"静电场与静磁场 一些定义 静电场： 研究空间内所有电荷(电子(及空穴)、离子等)保持静止,也就是没有电流. 恒流场： 研究空间内所有位置的电流恒定,也就是电流不随时间变化. 耦合：意思就是相互作用,可以是力的形式,电的形式. 介质：用来传输信息的物质. 例如声音要依靠介质进行传播;而光在真空中就可以传播,也就是说,光的传播不需要介质. 库仑定律:电荷产生电场 库仑力 两个静止点电荷q_{1}和q_{2}之间的相互作用力叫做库仑力,也叫静电力: F=k\\frac{q_{1}q_{2}}{r^2}\\tag{1} 库仑力的特点: 等大反向. 同性相斥,异性相吸. k=\\frac{1}{4\\pi \\epsilon_{0}},其中\\epsilon_{0}为真空介电常数,这里先不对此常数进行解释. 叠加原理：根据力的叠加原理,位于\\vec{r}处的某电荷q_{0}收到的库伦合力是所有其他电荷对其作用的库仑力之和. F=\\frac{1}{4\\pi\\epsilon_{0}}q_{0}\\sum^{N}_{i=1}{\\frac{q_{i}}{|\\vec{r}-\\vec{r_{i}}|^{3}}(\\vec{r}-\\vec{r_{i}})} 然而事实上,实际生活中我们很少遇到点电荷,更多的是带电体,因此根据叠加原理: F=\\frac{q_{0}}{4\\pi\\epsilon_{0}}\\oint_{V}{\\frac{\\rho}{|\\vec{r}-\\vec{r'}|^{3}}(\\vec{r}-\\vec{r'})}dV' 其中,\\rho dV为某dV空间内的电荷量,因此\\rho=dq/dV为体电荷密度. 进一步地,容易得到两个带电体1和2之间 F_{12}=\\frac{1}{4\\pi\\epsilon_{0}}\\oint_{V_{1}}\\oint_{V_{2}}{\\frac{\\rho_{1}\\rho_{2}}{|\\vec{r_2}-\\vec{r_1}|^{3}}(\\vec{r_2}-\\vec{r_1})}dV_{1}dV_{2}=-F_{21} 电场强度 如果在空间内某一点放置一个测试电荷q_{0},若其收到的库仑合力为F,由于F与q_{0}的比值与q_{0}无关,因此定义单位正电荷在位置r处所受到的力为电场强度：E=F/q_{0}. 电场强度是有方向的矢量,因此如果将各点电场的方向在图中绘制出来,就形成了电场线. 高斯定理：通过某闭合曲面S的电通量等于该曲面S内部的电荷量之和除以\\epsilon_{0}. \\oint_{S}E\\cdot dS = \\frac{1}{\\epsilon_0}\\sum_{S内}q 静电场中,如果电场强度的在闭合曲面上的积分不为0,表示内部有电荷(电荷源),因此说电场是有源场. 环路定理：电场强度某闭合回路l的环量均为0. \\oint_{l}E\\cdot dl = 0 静电场中,电场强度的在闭合环路上的积分一定为0,表示电场不可能一直沿着闭合环路,也就是静电场中不可能有闭合的电场线,因此叫做无旋场. 电势 如果试探电荷q在电场E中从位置1处移动到位置2处,此过程电场力对试探电荷q做功Eql,则电荷的电势能增大Eql. 电势能的增加量与试探电荷q的比值与q无关,定义位置1与位置2之间的电势差为 U_{21}=\\int E\\cdot dl 因此有 E=-\\nabla U 电场线的方向总是由高电势指向低电势. 毕奥-萨伐尔定律:元电流产生磁场 如果n个电子e^{-}的向同一方向发生微小移动d\\vec{l},则电流大小为I=neSv,S为穿过的截面积,v为电荷移动的速度。这个电流叫做元电流。 原点处的元电流Id\\vec{l}在\\vec{r}处的磁感应强度为 \\vec{B}=\\int d\\vec{B}=\\int{\\frac{\\mu_{0}}{4\\pi}\\frac{Id\\vec{l}\\times\\vec{r}}{r^{3}}} 练习题:求P点的磁感应强度. 答案: B=\\frac{\\mu_{0}I}{4\\pi a}(\\cos\\alpha_{1}-\\cos\\alpha_{2}),导线延长线上磁感应强度为0;当导线无限长时,B=\\frac{\\mu_{0}I}{2\\pi a}. 安培力 某点处的元电流Id\\vec{l}受到此点磁场的力为 d\\vec{F}=Id\\vec{l}\\times\\vec{B} 磁通量 在\\vec{r}处穿过曲面dS的磁感线的数量为磁通量: d\\Phi=\\vec{B}\\cdot dS 例如,在一个电流环内部平面上距离圆心r=a处的磁感应强度为: 显然, \\cos\\theta=\\frac{a^{2}+R^{2}-r^{2}}{2aR} 于是 r^{2}=a^{2}+R^{2}-2aR\\cos\\theta 又由于dl=Rd\\theta, d\\vec{l}\\times\\vec{r}=dl\\cdot r\\frac{R^{2}+r^{2}-a^{2}}{2Rr}=\\frac{R^{2}+r^{2}-a^{2}}{2}d\\theta 于是 {B}=\\frac{\\mu_{0}I}{4\\pi}\\int^{2\\pi}_{0}\\frac{R^{2}+r^{2}-a^{2}}{2r^{3}}d\\theta 线圈中的磁通量为: \r \\begin{aligned}\r \\Phi&=\\int BdS\\\\\r &=\\frac{\\mu_{0}I}{4\\pi}\\int^{R}_{0} 2\\pi a\\left(\\int^{2\\pi}_{0}\\frac{R^{2}+r^{2}-a^{2}}{2r^{3}}d\\theta\\right)da\\\\\r &=\\frac{\\mu_{0}I}{4}\\int^{2\\pi}_{0}\\int^{R}_{0}a\\frac{R^{2}+r^{2}-a^{2}}{r^{3}}dad\\theta\\\\\r &=\\frac{\\mu_{0}kI}{4}\r \\end{aligned}\r 其中k=\\int^{2\\pi}_{0}\\int^{R}_{0}a\\frac{R^{2}+r^{2}-a^{2}}{r^{3}}dad\\theta只与圆形线圈的半径有关. 安培环路定理:在真空中，磁感应强度B沿任意回路的线积分，等于该回路所限定的曲面上穿过的总电流乘以磁导率。这表明磁场是有旋场。定义H=B/\\mu_{0},二者的关系在电感进一步描述.这里\\mu_{0}是真空磁导率. \r \\begin{aligned}\r \\oint_{l}B\\cdot dl&=\\mu_{0}I\\\\\r \\oint_{l}H\\cdot dl&=I\r \\end{aligned}\r 磁通连续定理: 磁感应线通常是闭合的。因此,对于磁场中的任何闭合曲面S,穿入的磁感应线数恒等于穿出的磁感应线数,即穿出闭合曲面S的净磁通量为零。 \\oint_{S}B\\cdot dS=0 小结 本节主要讲了: 点电荷之间的库仑力,元电流之间的安培力; 静电场环路定理:电场的无旋性; 静电场高斯定理:电场的有源性; 静磁场安培环路定理:磁场的有旋性; 静磁场磁通连续定理:磁场的无源性. 引申:电流连续性方程 电荷守恒定律:单位时间内流出闭合曲面的电荷量等于该曲面内电荷量的减少量.即: I=-\\frac{dq}{dt} 用面电流密度\\vec{J}=dI/dS表示: \\oint_{S}\\vec{J}\\cdot dS=-\\frac{d}{dt}\\int\\rho dV 其微分形式为 \\nabla\\cdot\\vec{J}+\\frac{\\partial\\rho}{\\partial t}=0 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-03 18:57:07 "},"Hardware/1_Devices/2_Cap.html":{"url":"Hardware/1_Devices/2_Cap.html","title":"电容与电极化","keywords":"","body":"电容与电极化 回顾 在真空中的静电场和静磁场中我们讲过: 点电荷之间的库仑力,元电流之间的安培力; 静电场环路定理:电场的无旋性; 静电场高斯定理:电场的有源性; 静磁场安培环路定理:磁场的有旋性; 静磁场磁通连续定理:磁场的无源性. 原子核与电子的关系靠束缚力维持 单个原子外的电子在条件一定的情况下只能取到某些特定的能量，才能形成稳定的结构,这个能量的大小就是能级.下图展示了氢原子H的电子能级.电子吸收一定的能量后,在能级之间跳动,叫做跃迁.电子只能在能级之间跃迁,而不能跑到能级之外(因为不稳定). 当体系中有很多个原子的时候，由于原子间的相互作用，原子的能级会发生移动。原本相同的一条能级变成了一组差别很小的能级，这就是能带，也就是允带。由于能带内不同能级的能量差别非常小，所以很多时候在能带内可以忽略间隔，认为能量是连续的。下图展示了能级与能带的关系. 与能级之间存在间隔一样,能带与能带相互之间也存在较大的能量差别,这个能量的间隔就是禁带. 当原子处于基态的时候，它的所有电子从最低能级开始依次向上填充。对于半导体，电子刚好填充到某一个能带满了，下一个能带全空。这些被填满的能带称为满带，满带中能量最高的一条称为价带。 由于电流的产生需要载流子发生定向运动，而价带中电子已经占据了所有可能的能级，绝大多数电子相邻位置上的态都已经被占据了，无法移动，所以价带中的电子可以认为是不导电的。 对于半导体，能量最高的一个价带，到能量更高的下一个能带之间有一个禁带，但是这个禁带的宽度（能量）不是很大，所以有一些电子有机会跃迁到下一个能带。由于这个能带几乎是空的，所以电子们跃迁到这个能带之后就可以自由地奔跑，这个能带就是导带。 对于绝缘体，这个禁带宽度太大，基本上不可能有电子跃迁过去。 对于金属，根本没有禁带，导带和价带直接重合了，既然最高的能带本身就不满那不需要跃迁就可以导电了。 下图展示了金属、半导体和绝缘体的禁带. 纯净的半导体（本征半导体）的导电能力是很差的，因为需要很高的温度才能让足够多的载流子跃迁到导带。一般使用半导体的时候都会进行掺杂，通过掺入杂质来引入新的能级。 对于硅来说，掺杂硼可以在禁带中里价带很近的位置上引入一组全空的能级，价带电子可以很容易地跃迁到这个能级上，电子跃迁之后在价带留下的空穴就可以导电了，这就是P型半导体。空穴导电时，电子运动发生在价带； 掺杂磷，可以在禁带中里导带很近的位置上引入一组全满的能级，这个能级上的电子可以很容易地跃迁到导带上，成为导带电子导电，这就是N型半导体。电子导电时，电子运动发生在导带。 我们常说的电阻，一般是指导体或半导体的电阻，因为绝缘体的电阻很大，经常视为无穷大。如果把绝缘材料放在电池两端连接,会发生什么情况呢? 电容的本质与电极化 为了zhuangB,给绝缘材料换个名字,叫做电介质. 随着电池与绝缘材料加上电气连接,电池负极发射电子,正极吸收电子,电子在材料两端分别被聚集和被吸收,材料表面形成电荷积累,这种电荷积累一方面导致内部电场强度从0开始逐渐增大,原子外层的电子e和原子核在电场下发生很小的方向性偏移,这就是电极化.但电场力仍不足以使电子挣脱P原子的束缚,仍然没有电流;另一方面电荷积累导致来自电池负极的电子的加速度减小;随着电荷进一步积累,直到电池负极发出的电子的加速度为0,如无吸引,电子将不再从电池负极向外部运动(也就是说,导线和金属电极板内部电场为0,因此,金属电极板上电势等于电池电极的电势);最终结果是,绝缘材料两端形成电荷积累,内部形成电场.因此这个过程叫做充电的过程. 如果此时断开电源连接,使用导线将绝缘材料两端直接连接,导线内部形成场强,由于电子可以在导线内自由移动,于是绝缘材料两端的正负电荷相互吸引,直到两端电势差为0,电场强度为0,自由电荷不再移动.最终结果是绝缘材料两端电荷通过导线结合在一起,两端均为电中性. 几个问题 现在我们想分析以下问题,充电完成之后,电场是静电场,那么此时: 极板之间真空(无介质材料)时,极板间场强是怎样的?充电时场强又是怎样的? 材料两端积累的电荷量是相等的吗? 在材料内部,场强是怎样分布的? 答案 如图所示,在封闭曲面S2内,根据静电场的高斯定理 \\oint{\\vec{E}\\cdot d\\vec{S}}=\\frac{q}{\\epsilon_{0}} 由于电极板内部场强为0,因此在极板之间的任意处,均满足 E\\cdot S=\\frac{q}{\\epsilon_{0}} 于是极板内部场强为匀强电场.进一步地,有 \\frac{\\epsilon_{0}S}{d}=\\frac{q}{U} 左侧仅与极板的几何形状和位置有关,表示单位电压下能容纳电荷的能力,这就是电容: C=\\frac{\\epsilon_{0}S}{d} 充放电时在dt时间内极板上电荷量发生变化,而内部电场仍为匀强电场,所以对于任意时刻,均有 C=\\frac{dq}{dU} 如图所示,在封闭曲面S1内,根据静电场的高斯定理 \\oint{\\vec{E}\\cdot d\\vec{S}}=\\frac{q}{\\epsilon_{0}} 由于电极板内部场强为0,且电介质是电中性的,其总电荷量为0; 因此材料两端电荷量之和为0,因此材料两端积累的电荷量相等. 在电场下材料发生电极化,只会导致材料表面产生电荷,而材料内部仍呈电中性. 在封闭曲面S2内,设在金属极板上的面电荷密度为\\sigma_{0},产生的电场为E_{0};在E_{0}的作用下,材料电极化在表面产生的极化电荷面密度为\\sigma_{p},二者符号相反,因此极化电荷产生的电场\\vec{E}_P的方向与外电场\\vec{E}_{0}方向相反.内电场和外电场的矢量和记为\\vec{E}=\\vec{E_{0}}+\\vec{E_{p}}. 设介质是均匀的,继续用静电场的高斯定理: \r \\begin{aligned}\r \\oint{\\vec{E}\\cdot d\\vec{S}}&=\\frac{\\int{(\\sigma_{0}+\\sigma_{p})\\cdot dS}}{\\epsilon_{0}}\\\\\r E&=\\frac{(\\sigma_{0}+\\sigma_{p})}{\\epsilon_{0}}\r \\end{aligned}\r 其中\\sigma_{0}=\\epsilon_{0}E为自由电荷的面密度. 设介质是各向同性的,\\sigma_{p}的大小与E_{0}正相关,因此E与E_{0}为线性关系,设E=\\frac{E_{0}}{\\epsilon_{r}},其中\\epsilon_{r}>1仅与材料本身有关。\\epsilon_{r}反映了实际场强相对于真空介质中的场强的大小,因此叫做相对介电常数,且真空中\\epsilon_{r}=1。 可以计算得到 \\sigma_{p}=\\sigma_{0}\\left(\\frac{1-\\epsilon_{r}}{\\epsilon_{r}}\\right)=\\epsilon_{0}(1-\\epsilon_{r})E \\epsilon_{r}越大,则介质内实际场强越小,材料越容易被电极化. 这就是极化电荷的面密度.将上式代入到高斯定理中,可以得到 \r \\begin{aligned}\r \\oint{(\\epsilon_{0}E-\\sigma_{p})\\cdot dS}&=q\\\\\r \\oint{\\epsilon_{0}\\epsilon_{r}E}&=q\r \\end{aligned}\r 这里的q是自由电荷. 可以看出,与真空介质相比,式中仅多了一项\\epsilon_{r}. 定义 D=\\epsilon_{0}E-\\sigma_{p}=\\epsilon_{0}\\epsilon_{r}E D表示了界面上的自由面电荷密度.这个方程是绝缘材料(电介质)的本构方程. \\oint D\\cdot dS=\\oint\\rho dV 微分形式为 \\nabla\\cdot D=\\rho 此时在介质中有 \\epsilon_{0}\\epsilon_{r}E\\cdot S=q 电介质形成电极板的电容能力(储存自由电荷的能力)为 C=\\frac{\\epsilon_{0}\\epsilon_{r}S}{d} 通过设计电介质的材料,电极板的间距以及电极板的面积可以设计电容的大小. 电容的特性 I-V特性:隔直通交 电容的特性方程为: C=\\frac{q}{u} 其中C=\\frac{\\epsilon_{0}\\epsilon_{r}S}{d}. 电流是指单位时间内通过某界面的电荷量. i=\\frac{dq}{dt} 因此流过电容的电流与两端电压的关系为: i=C\\frac{du}{dt} 这就是其I-V特性.电容的电流是两端电压的微分. 当两端电压不变时,电容的电流为0. 因此直流电压信号不可以通过电容器. 当两端电压变化频率越快,通过电容的电流越大. 这就是电容的隔直通交特性. 电容与电场能 在充电(电荷积累)过程中,电压源为电容充能;在放电(电荷耗散)过程中,电容能量消耗在回路中. 充电时,以电源负极为0电势参考点,则正电荷从电源正极流向电容中,一定时间dt内积累的正电荷量为q = \\int_{S}{D\\cdot dS},电容的正负极板上的电压差为u=\\int{E\\cdot dl},因此此过程积累的能量为 E=qu=\\int{D\\cdot EdV} 定义电场的能量密度为单位体积内的能量:D\\cdot E 虽然负电荷在负极板上积累,但积累前后电势均为0,因此没有电势能的增加. 即使没有导体和金属板,只要真空中一定空间内产生了电势差,就是外界对其充电才产生了的电势能. 容抗与相移 在复数空间中,设x=a+bj,由于实部和虚部是独立的向量,则有da/dt = Re(dx/dt). 因此,为了以后表述方便,使用复指数表示任意正弦信号. 例如: 任意正弦信号u=K\\cos{(\\omega t + \\phi)}=Re(Ke^{j(\\omega t + \\phi)}),以后就用u=Ke^{j(\\omega t+\\phi)}表示. 当电容两端信号为u=Ke^{j(\\omega t+\\phi)}时,则i=C\\cdot j\\omega Ke^{j(\\omega t + \\phi)}=j\\omega Cu, 因此,电容对交流信号的抵抗能力,也就是容抗,大小为 Z=\\frac{1}{j\\omega C} 由于i=e^{j90^{o}}\\omega Cu,因此i 的相位超前u的相位90°. 由于电容的以上特性,常用于交流信号耦合,构建延时和相移电路,滤除纹波噪声等. 欧拉公式:e^{aj}=\\cos a+j\\sin a IC中电容的设计 IC设计中,1个Poly层,3个金属层的工艺简记为1P3M,其结构如下:基本元件的IO尽量在底层,相邻的金属层走线应两两垂直,避免产生寄生电容,从而有效避免串扰. 集成电路中,电容很难做到很大.通常IC中的电容只有fF量级(10^{-15}F).理由如下: 增大S会大大增加芯片面积,成本受不了; 减小d会导致相同电压下,E会很大,会直接将电介质击穿,使电容失效; 因此,只能通过选用更高介电常数的介质作为电容的介质. 常见材料的相对介电常数为Si(11.8),SiO_2(3.9),TEOS(4.0),Si_{3}N_{4}(6~7). 硅的介电常数大,因此反偏的PN结形成的耗尽区电容叫做结电容,该电容较大;但结电容一方面受电压大小的影响而变化,另一方面还有寄生效应,因此几乎不会使用. 氮化硅的介电常数大,但容易形成针孔,降低电容可靠性;与Si材料之间的热膨胀系数相差较大,产生的应力也会影响器件寿命和可靠性.可以在氮化硅的上下添加一个氧化层,形成三个电容的串联.以避免热膨胀引起器件失效. 设计电容时,大多数还是使用平板电容,通过增大S和减小d的方法,同时注意避免击穿。 常见的设计方法为: 使用双层多晶硅形成平板电容: 栅氧化层作为介质.应主要考虑接触孔的摆放:接触孔要尽可能多且均匀分布,介质与上极板的接触做成叉指状,介质与下极板的接触做成环状,这样可以保证电容充放电时电流均匀,且减少寄生电阻的带来的延迟. 多晶硅和N+区形成平板电容:当工艺中只提供单层多晶硅层时,采用此方法,栅氧化层作为介质. 多晶硅和衬底P区形成MOS电容:当反型时,MOS电容值与普通平板电容相同,仅与S,d有关.当耗尽时,MOS电容是氧化层电容(平板电容)和耗尽层电容的串联,此时电容值是极板电压的函数.而反型时,虽然电容为定值,但交流信号进入反型工作区时,不可避免地会经过耗尽状态,电容仍然不稳定. 金属层与多晶硅形成平板电容:介质层质量相对较差,且会对布线造成一定的不方便. 练习题:分析并联电容的等效电容,串联电容的等效电容. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-03 20:52:02 "},"Hardware/1_Devices/3_Res.html":{"url":"Hardware/1_Devices/3_Res.html","title":"电阻的原理与设计","keywords":"","body":"电阻的原理与设计 在上节我们讨论了电容的原理,特性和设计方法,把绝缘材料放在平行的金属极板中,即可形成电容器.那么,如果把金属导体材料放在两个电极中,会发生什么情况呢? 电导的本质 现在假设有一块已经掺入P原子的长方体硅晶体,电池与材料无电气连接时,材料内的自由电荷随机均匀分布,无定向移动,因此无电流; 随着电池与材料加上电气连接,电池负极发射电子,正极吸收电子,电子在材料两端分别被聚集和被吸收,材料表面形成电荷积累,这种电荷积累一方面导致内部电场强度从0开始逐渐增大,终于在E=E_{0}时,P原子外层的电子e获得能量(E_{0}e),就可以挣脱P原子的束缚,在电场作用下发生定向移动,形成电流,这种运动叫做漂移运动,载流子的平均漂移速度v与电场强度成正比 v=\\mu E 系数\\mu叫做迁移率,它表示了单位电场下载流子的平均漂移速度;另一方面电荷积累导致来自电池负极的电子的加速度减小;随着电荷进一步积累,直到电池负极发出的电子的加速度为0,如无吸引,电子将不再从电池负极向材料运动;但此时材料内部电子在内部电场作用下向电池正极方向移动,导致材料表面电荷量减小,从而将相同电荷量的电子从电池负极吸引过来.单位时间内,从电池负极流入材料表面的电荷量等于材料表面流入到材料另一面的电荷量. 常见的半导体材料中，原子核对导带电子的束缚力小于价带电子，散射效应也是在价带更明显，所以空穴迁移率小于电子。 此时电流的大小为 I=dq/dt=neSv=neS\\mu E=neS\\mu U/d=\\sigma SU/d 其中S是材料的横截面积,d为材料的长度,n为材料中载流子的浓度,e为元电荷量,\\mu为载流子迁移率,U为材料两端的电压.系数\\sigma反映了材料本身的导电能力,叫做电导率.电阻率是电导率的导数. \\sigma=ne\\mu,G=\\frac{I}{U}=\\sigma\\frac{S}{d} \\rho=\\frac{1}{\\sigma},R=\\frac{U}{I}=\\rho\\frac{d}{S} 这就是欧姆定律. 用面电流密度\\vec{J}=dI/dS表示: \\vec{J}=\\sigma\\vec{E} 这就是欧姆定律的微分形式,也是电阻的本构方程. 本构方程是指描述了材料的属性特性或参数之间的定量关系的数学方程,它描述了材料对外部激励的响应情况. Constitutive equation or model is a mathematical formulation which establishes a quantitative relation between two parameters and hence characterizes the material properties. It describes how the material responds to external stimuli. 电阻率/电导率与材料类型,载流子浓度以及温度有关. 常用材料的电阻率如下表所示. 材料 电阻率(\\Omega\\cdot \\text{cm},25 ℃) 铜Cu 1.7\\times10^{-6} 金Au 2.4\\times10^{-6} 铝Al 2.7\\times10^{-6} N型硅(N_{d}=10^{18}cm^{-3}) 0.25 N型硅(N_{d}=10^{15}cm^{-3}) 48 本征硅(超级纯)) 2.5\\times10^{5} \\mathrm{SiO}_{2} 10^{14} 电阻的特性 I-V特性 事实上,在实际生活中,我们更常在器件两端加上电压,观测其电流值,作出其I-V曲线,叫做输出特性曲线. 室温下,n,e和\\mu均几乎不变,因此输出特性曲线时一条直线. 电压一定时,当温度上升时,更多的电子吸收热量跃迁到导带,导致载流子浓度增大,从而电导率上升,电阻下降. 电阻的功耗 电场能量是什么呢?答曰:电势能. 电荷置于电场中,就具有了电势能. 导体导电的过程中,导体中电子的电势能转化为动能,然后被散射消耗掉,或者转化成光能(钨丝灯泡)、热能(保险丝遇到大电流时温度升高将自己烧断,从而切断电路,保障用电安全),这个过程消耗了电势能.这种能量损耗统称为热传导损耗. 在电子从导体一端运动到另一端的过程中,电势变化量为导体两端电压u,一定时间\\Delta t内通过导体的电荷量为\\Delta q = i\\Delta t,因此此过程消耗的能量为 \\Delta E=u\\Delta q=ui\\Delta t 定义功耗为单位时间内消耗的能量,则电阻的功耗为: P_{R}=ui 接下来为了更直观地体会电阻特性,在Multisim 14 Education上做仿真实验. 电阻的设计 人们希望可以把元件的体积不断减小,这样就可以在有限的空间内集成极其复杂的电路,这种高度集成化的电路就是集成电路,英文时Intergrated Circuit,也就是IC. 通常我们说的芯片Chip不止包含集成电路(IC),还有分立器件(MEMS,传感器,光电子器件等). 但通常是指IC. 那么在微小的电子电路(微电子电路)中,我们如何自己设计一个电阻呢? 如果材料的长度与宽度相等,材料的顶视图是一个方块(Box),此时其电阻称为方块电阻,记作R_{\\Box}。方块电阻只与材料种类、温度、材料厚度有关.在设计时,如果方块电阻为R_{\\Box}=200\\Omega,要设计出1\\mathrm{k\\Omega}的电阻,只需拼接5个方块,即可将5个方块电阻串联. 由于微电子电路中半导体的掺杂不十分均匀,因此无法直接使用公式计算方块电阻大小.在特定工艺下,一般工艺厂商(Foundry)会给定方块电阻.例如,下面是不同材料的方块电阻值. 材料层 方块电阻(\\Omega/\\Box,25 ℃) 温度系数 电压系数 N阱 1000 5.74E-3 8.24E-3 N+掺杂 65 1.32E-3 3.76E-4 P+掺杂 170 - - 多晶硅1 19 5E-4 4.1E-6 多晶硅2-低阻 55 1.42E-4 1.66E-4 多晶硅2-高阻 1900 -3.32E-3 -2E-4 金属铝 0.08 - - 其中: N阱: 单晶硅经过掺杂杂质原子形成的电阻.设计阱电阻需要注意: 阱电阻的长度是两接触孔之间的长度; 由于加工工艺中阱区是第一道工艺,后续工艺中的高温会使阱区向外扩散,制造出的实际阱电阻的宽度往往超过设计宽度的20%,因此需要在设计宽度上加以修正; 方块电阻是根据成品实验测得,无需加以修正,直接使用即可. N+掺杂: 单晶硅经过掺入较重浓度的杂质原子,浓度明显大于N阱; P+掺杂: 单晶硅经过掺入较重浓度的杂质原子; 多晶硅1,2: 在绝缘的多晶硅材料中掺入少量杂质原子,其电导率急剧上升,接近于金属.常用于代替金属制作MOS管的栅极.多晶硅的温度系数和电压系数较小,阻值随电压和温度变化较小.多晶硅2高阻电阻需要增加一个额外的光刻板,高阻多晶注入板,增加制造成本.多晶硅不会扩散,因此电阻的设计宽度无需修正. 金属Al: 一般不使用金属制作电阻,但其阻值不能忽略,因为导线电阻会产生压降,并有可能产生寄生电容. 工艺存在误差,导致实际制造出的电阻阻值R'与设计值R不完全一致,叫做失配.二者的相对误差\\frac{R'-R}{R}叫做失配程度(失配误差).由于工艺带来的误差方向和大小均不确定,因此在设计时也无能为力. 总结: 大电阻优选多晶硅2高阻、可选阱电阻.小电阻优选多晶1、多晶2低阻、N+掺杂等. 高精度的RC振荡器需要振荡器频率随电压和温度变化尽量小,因此使用电压系数和温度系数为正的电阻、配合系数为负的电阻(多晶硅2高阻),抵消温度和电压对RC振荡器频率的影响. 电阻的宽度L越大,受到加工带来的误差\\Delta L的影响\\Delta L/L越小. 较大数值的电阻常分为较短的电阻单位,放在一条线上,比蛇形电阻优越,后者在拐角处电阻较大. 但工艺对各个电气层均有最大尺寸和最小尺寸的限制,如果一条直线摆放到了最大尺寸,还不满足设计阻值的要求,这是才可以使用金属导线将电阻按蛇形串联起来; 或者直接使用蛇形电阻. 有源电阻:将MOS管的栅源或栅漏短接,形成工作在饱和区的导通电阻,可以大大节省面积,但阻值会受到电压波动的影响,严重时甚至导致电路功能失效,精度要求较高的电路中,一定要慎用有源电阻.有关有源电阻的更多信息,在MOS管一节中介绍. 练习题:分析并联电阻的电压关系,串联电阻的电流关系. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-15 17:14:53 "},"Hardware/1_Devices/4_Ind.html":{"url":"Hardware/1_Devices/4_Ind.html","title":"电感与磁极化","keywords":"","body":"电感与磁极化 先说明,模拟和数字IC里,是没有电感的.因此本节中不包括电感的设计. 在微波/射频电路中,由于涉及到电磁波,需要考虑电感的设计,本文暂时不做讨论. 在IC里你咋绕线圈.... 回顾 在真空中的静电场和静磁场和电容中我们讲过: 点电荷之间的库仑力,元电流之间的安培力; 静电场环路定理:\\oint E\\cdot dl=0,电场的无旋性; 静电场高斯定理:\\oint E\\cdot dS=q/\\epsilon,电场的有源性; 静磁场安培环路定理:\\oint_{l}H\\cdot dl=I,磁场的有旋性; 静磁场磁通连续定理:\\oint B\\cdot dS=0,磁场的无源性. 电流连续性定理:\\oint_{S}\\vec{J}\\cdot dS=-\\frac{d}{dt}\\int\\rho dV,电荷守恒定律. 本构方程1-导体的欧姆定律:J=\\sigma E 本构方程2-电介质的极化:D=\\epsilon_{0}\\epsilon_{r}E 电磁感应定律 后来,法拉第一次实验中发现了电磁感应定律: 磁场中的一个闭合导体回路由于某种原因引起穿过导体回路的磁通量发生变化时，回路中就产生了感应电动势，且感应电动势的大小正比于磁通对时间的变化率: \\mathscr{E}_{ind}=-\\frac{d\\Phi}{dt} \\oint E_{ind}\\cdot dl=-\\int_{S}\\frac{\\partial B}{\\partial t}dS 微分形式是 \\nabla\\times E_{ind}=-\\frac{\\partial B}{\\partial t} 注意,这里我们说时导体形成的回路,那么当导体的导电能力下降,替换成绝缘体形成的回路时,感应电动势仍然不变,即使没有绝缘体,任意一个回路,仍然会感应出电动势,也就是感应出电场. 电磁感应定律的本质是变化的磁通量产生了感应电动势(也就是感应电场),与介质无关. 现在假设有一个很圆很圆的线圈,两端加上电压. 在静电场一节中,我们计算过单匝线圈内部的磁通量. \\Phi=\\frac{\\mu_{0}kI}{4} 因此N匝线圈线圈两端的感应电动势大小为: U=\\frac{Nd\\Phi}{dt}=N\\frac{\\mu_{0}k}{4}\\frac{dI}{dt}=L\\frac{dI}{dt} 其中 L=N\\frac{\\mu_{0}k}{4}$体现了线圈随电流变化的感应电动势能力.L$只与线圈的匝数,半径,介质的磁导率有关.\r \r \r \r ## 分子电流与磁极化\r 我们知道元电流可以产生磁场(毕奥-萨伐尔定律),而事实上,物质中的电子在不停地做着自旋和绕原子旋转的运动.有没有很像日-地关系!!!物理真他妈美.WOC.\r \r 那还有一种东西可以形成磁场,比个如,磁性材料! 磁性材料按化学成分分，常见的有两大类：**金属磁性材料**和**铁氧体**．**铁氧体**是以**氧化铁**为主要成分的磁性氧化物．这家伙就是磁铁呀,指南针呀兄弟们,四大发明呀兄弟们~\r \r 安培就思考它们之间是不是有联系?于是他就认为,在原子、分子等物质微粒内部，存在着一种环形电流——分子电流，分子电流使每个物质微粒都成为微小的磁体，它的两侧相当于两个磁极.\r \r \r \r \r 这种电子除了自旋和绕核旋转形成分子环形电流,在外磁场作用下会受到安培力,并发生**进动**,该进动形成的环形电流产生的磁场与外磁场方向相反,削弱了磁场的作用(你可以伸开左女朋友试试,再伸出来右女朋友试试,别忘了高中物理知识,只有安培力需要用左爪,其他都用右爪).这种现象叫做**磁极化**,简称为磁化.在任何材料中,除了进动产生的环形电流I{1},材料自身还有分子电流I{2},二者之矢量和统称为I{p}.根据泡利不相容原理,同一层的电子的自旋方向一定不同,因此:\r * 如果材料原子外的电子是成对出现的,固有分子电流I{2}的和为0.此时磁化作用由进动的环形电流I{1}主导;该材料主要体现**抗磁性**. 总场强H{0},如铜,铋,硫,氢,银等;\r * 如果材料原子外的电子是不成对的,固有分子电流I{2}一般大于进动的环形电流I{1},因此可能体现与外磁场方向相同,此时材料主要体现**顺磁性**. 总场强H>H{0},如锰,铬,铂,氧,氮等;\r * 如果材料原子外的电子是不成对的,固有分子电流I{2}远远大于进动的环形电流I{1}时,材料呈现**铁磁性**. 总场强H>>H{0},如铁,钴,镍等.\r \r 把顺磁性物质和抗磁性物质称为**弱**磁性物质，把铁磁性物质称为**强**磁性物质．**通常所说的磁性材料是指强磁性物质．**\r \r 设在导体交界面上的外界环形电流I{0},产生的磁感应强度为B{0};在B{0}的作用下,材料磁化产生的磁化环形电流为I{p}.现假设**二者方向相反**.该环形电流产生的磁感应强度和外部磁感应强度的矢量和记为\\vec{B}=\\vec{B{0}}+\\vec{B{p}}.\r \r \r \r **设磁介质是均匀的**,继续用安培环路定理:\r \r \\oint B\\cdot dl=\\mu{0}(I{0}+I{p})\r \r I{p}的大小与B{0}正相关,因此B与B{0}为线性关系,设B=\\mu{r}B{0},其中\\mu{r}的值仅与材料本身有关。\\mu{r}反映了实际磁场强度相对于真空介质中的磁场强度的大小,因此叫做**相对磁导率**,且真空中\\mu{r}=1。\r \r 可以计算得到\r I{p}=\\oint (1-\\frac{1}{\\mu{r}})\\frac{B}{\\mu{0}}\\cdot dl\r \r \r **在0{r}时,\\mu{r}越大,则介质内实际磁场强度越大,材料越不易被磁化.**\r 这就是磁化电流.将上式代入到安培环路定理中,可以得到\r \\oint{\\frac{B}{\\mu{0}\\mu{r}}\\cdot dl}=I{0} \r \r > **S是闭合回路l包围的曲面,该曲面是不闭合的**.\r \r 这里的I{0}**是介质中的传导电流**. 可以看出,与真空介质相比,式中仅多了一项\\mu{r}.\r 这里定义了磁场强度H=B/\\mu{0}\\mu{r},因此\r \r \\oint{H\\cdot dl}=I{0}=\\int{S} J{c}\\cdot dS\r \r H**表示了穿过曲面的传导电流**.B=\\mu{0}\\mu{r}H=\\mu{0}H+\\mu{0}M,这个方程是材料(磁介质)的**本构方程**.\r 微分形式为\r \\nabla\\times H=J{c}\r \r ## 位移电流\r \r 然而麦克斯韦在实验中发现,即使穿过该曲面上的电流和为0时,当**曲面上的电场强度随时间变化**时,仍然有产生了磁感应强度,这种交变的电场就像是一个虚拟的电流对该曲面进行充电产生的,因此叫做**位移电流**.注意,虽然叫做位移电流,但实际上是不存在的电流,仅仅用于表述J{D}=\\partial D/\\partial t. 传导电流J{c}与位移电流J{D}共同对磁场做出了贡献.\r \r \\oint{H\\cdot dl}=I{0}=\\int{S} \\left(J{c}+\\frac{\\partial D}{\\partial t}\\right)\\cdot dS\r \r 微分形式为\r \r \\nabla\\times H=J{c}+\\frac{\\partial D}{\\partial t}\r \r 至此,**交变的磁场可以产生电场(感应电动势),交变的电场(位移电流)可以产生磁场,这是电磁波的理论基础,更是电磁波为什么能在真空中传播的原因**.\r \r ## 电感的特性\r 1. I-V特性\r 当线圈内部存在磁介质时,介质中的磁化会增大磁感应强度(与真空介质相比H不变,但B增大了),因此,增大了感应电动势.\r 下图中左图显示了当电流不变时,虽然磁感应强度比真空介质的大,但仍无感应电动势.右图显示了感应电动势的产生条件时线圈中的电流发生变化.\r 线圈的感应电动势是来自自身电流变化,这种现象叫做**自感**. 当线圈中的感应电动势来自于其他线圈电流的变化,叫做**互感**. \r 电感器的I-V特性方程为\r u=L\\frac{di}{dt}\r 其中L=N\\frac{\\mu{0}\\mu{r}k}{4}体现了线圈随电流变化的感应电动势能力.L只与线圈的匝数,半径,介质的磁导率有关.\r \r \r 2. 电感与磁场能\r 在电流变化的过程中,电源为电感**充磁**;在**放磁**过程中,电感能量消耗在回路中.\r 充磁时,设经过电感的电流不断增大,电感两端产生的感应电动势为\\mathscr{E}=\\int{S}{\\frac{\\partial B}{\\partial t}\\cdot dS},因此此过程积累的能量为\r E=\\int\\mathscr{E}Idt=\\int{B\\cdot HdV}\r 定义**磁场的能量密度**为单位体积内的能量:B\\cdot H\r **即使没有产生传导电流,只要真空中一定空间内产生了感应电动势,就是外界对其充磁才产生了的电势能.**\r \r 3. 感抗与相移\r 当流过电感的电流为i=Ke^{j(\\omega t+\\phi)}时,则u=L\\cdot j\\omega Ke^{j(\\omega t + \\phi)}=j\\omega Li,\r 因此,电容对交流信号的抵抗能力,也就是**容抗**,大小为\r Z={j\\omega L}\r 由于u=e^{j90^{o}}\\omega Li,因此u **的相位超前i的相位90°**.\r 由于电感的以上特性,常用于**直流信号耦合(DC-DC,变压器)**,构建**延时和相移电路**,**滤除纹波噪声**等.\r 由于加入磁介质后,感应电动势明显增大,因此,在变压器(或者说DC-DC)电路中,**根据初级和次级线圈的匝数比值不同**,就可以在次级线圈中产生不同的感应电动势.这就是变压电路的原理.\r > 欧拉公式:e^{aj}=\\cos a+j\\sin a\r ## 电感的能量\r \r 线圈中的电流I发生变化,产生了感应电动势\\mathscr{E},产生的能量为\r \r E{m}=\\int{\\mathscr{E}Idt}=\\int{LI\\frac{dI}{dt}dt}=\\frac{1}{2}LI^{2}\r \r ## 电感与趋肤效应\r \r 交流电通过导体时,**导体产生的磁场会以安培力(/洛伦兹力)的形式作用于导体中的载流子,使载流子发生横向运动**.这导致导体各个横向部分的电流密度不均匀,导体表面电流密度大(减少了截面积，增大了损耗),这种现象称为**趋肤效应**.交流电的频率越高,趋肤效应越显著,频率高到一定程度,可以认为电流完全从导体表面流过. 在射频电路中,必须考虑趋肤效应.\r \r > 实际应用：空心导线代替实心导线，节约材料；在高频电路中使用多股相互绝缘细导线编织成束来削弱趋肤效应。\r \r \r ## 小结\r \r 到目前位置,我们已介绍过电容的原理(介质的极化增大了储存电荷的能力);电感的原理(磁介质的磁化增大了线圈感应电流的能力).\r \r * 点电荷之间的库仑力,元电流之间的安培力;\r * [电磁感应定律](1_StaticEM.html):\\oint E\\cdot dl=-\\int{S}\\frac{\\partial B}{\\partial t}dS,电场的无旋性;\r * [电场高斯定理](2_Cap.html):\\oint D\\cdot dS=q,电场的有源性;\r * [磁场安培环路定理](4_Ind.html):\\oint{l}H\\cdot dl=\\int{S} \\left(J{c}+\\frac{\\partial D}{\\partial t}\\right)\\cdot dS,磁场的有旋性;\r * [磁场磁通连续定理](1_StaticEM.html):\\oint B\\cdot dS=0,磁场的无源性.\r * [电流连续性定理](1_StaticEM.html):\\oint{S}\\vec{J}\\cdot dS=-\\frac{d}{dt}\\int\\rho dV,电荷守恒定律.\r * [本构方程1-导体的欧姆定律](3_Res.html):J=\\sigma E\r * [本构方程2-电介质的极化](2_Cap.html):D=\\epsilon{0}\\epsilon{r}E\r * [本构方程3-磁介质的磁化](4_Ind.html):B=\\mu{0}\\mu_{r}H$$ 这就是4个麦克斯韦方程组,1个电流连续性定理,以及3个材料的本征方程. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-03 21:00:48 "},"Hardware/1_Devices/5_Maxwell.html":{"url":"Hardware/1_Devices/5_Maxwell.html","title":"经典电磁学理论基础","keywords":"","body":"经典电磁学理论基础 点电荷之间的库仑力:F=Eq; 元电流之间的安培力(移动电荷受到洛伦兹力):F=IBL,F=qvB; 麦克斯韦方程组 电磁感应定律: \\oint E\\cdot dl=-\\int_{S}\\frac{\\partial B}{\\partial t}dS,\\nabla\\times E=-\\frac{\\partial B}{\\partial t} 无交变磁场时,右侧为0,体现了静电场的无旋性; 电场高斯定理: \\oint D\\cdot dS=q,\\nabla\\cdot D=\\rho_{V} q是自由电荷,\\rho_{V}为自由电荷体密度,体现了电场的有源性; 磁场安培环路定理: \\oint_{l}H\\cdot dl=\\int_{S} \\left(J_{c}+\\frac{\\partial D}{\\partial t}\\right)\\cdot dS,\\nabla\\times H=J_{c}+\\frac{\\partial D}{\\partial t} 当电流恒定时,位移电流项为0,即界面上积累的自由电荷密度不变. 磁场的有旋性; 磁场磁通连续定理: \\oint B\\cdot dS=0,\\nabla\\cdot B=0 磁场的无源性. 电流连续性定理 电流连续性定理: \\oint_{S}\\vec{J_{c}}\\cdot dS=-\\frac{d}{dt}\\int\\rho dV,\\nabla\\cdot J_{c}=-\\frac{\\partial\\rho_{V}}{\\partial t} 由电荷守恒定律得出. 材料的本构方程 本构方程1-导体的欧姆定律: J_{c}=\\sigma E 它决定了导体的I-V特性为I=GU. 本构方程2-电介质的极化: D=\\epsilon_{0}\\epsilon_{r}E 它决定了电容器的I-V特性为i=C\\frac{du}{dt}. 本构方程3-磁介质的磁化: B=\\mu_{0}\\mu_{r}H 它决定了电感器的I-V特性为u=L\\frac{di}{dt}. 这就是4个麦克斯韦方程组,1个电流连续性定理,以及3个材料的本征方程. 接下来我们讨论一下,在介质的交界面上,静电场和静磁场是怎样变化的? 静电场和静磁场的边界条件 静电场: 研究空间内所有电荷(电子(及空穴)、离子等)保持静止,也就是没有电流.因此电势不随时间变化. 静磁场: 研究空间内所有位置的磁感应强度恒定,因此电流保持恒定. 恒流场: 研究空间内所有位置的电流恒定,也就是电流不随时间变化.如果介质的位置和结构不变,则电势分布也不随时间变化. 静电场与恒流场的区别是有没有恒定电流. 由于边界中，介质的性质发生了突变，故微分形式的麦克斯韦方程组不适用了，可以用麦克斯韦方程组的积分形式进行推导。 静电场的边界条件 (1) 界面两侧相邻两点的电位连续: U_{1}＝U_{2}; (2) H的切向分量在界面处不连续，其数量等于界面处的自由表面电流密度 H_{1t}−H_{2t}=J_{ns} (3) B的垂直分量在界面B上连续 B_{1n}=B_{2n} (4) 静电磁场中磁场感应强度不随时间变化时,E的切向分量在整个界面上是连续的 E_{1t}=E_{2t} (5) D的垂直分量在界面处不连续，其数量等于界面处的自由表面电荷密度 D_{1 n}-D_{2 n}=\\rho_{s} 恒流场(静磁场)的边界条件 稳定电流场的边界条件,就是稳定电流场建立之后,在两种不同电阻率介质界面处的电场分布特征。 (1) 界面两侧相邻两点的电位连续: U_{1}＝U_{2}; (2) 界面上电流密度的法线分量连续：J_{1n}＝J_{2n},电流密度的切线分量不连续； 电流恒定(电场必然恒定)时,则边界上电荷密度不随时间变化(否则电场不恒定),\\frac{\\partial \\rho_{V}}{\\partial t}=0,根据电流连续性方程有\\nabla \\cdot J_{c} = 0.因此传导电流J_{c}在边界上法向分量也连续: J_{1n}=J_{2n} (3) 对于电场强度的边界条件,由于E＝ρJ,故可直接得出电场强度的法向分量不连续;而电场强度的切线分量连续：E_{1t}＝E_{2t}。 (4) B的垂直分量在界面B上连续 B_{1n}=B_{2n} (5) D的垂直分量在界面处不连续，其数量等于界面处的自由表面电荷密度 D_{1 n}-D_{2 n}=\\rho_{s} (6) H的切向分量在界面处不连续，其数量等于界面处的自由表面电流密度 H_{1t}−H_{2t}=J_{ns} 注意,边界条件不要死记硬背,麦克斯韦方程组也不要死记硬背!要理解,才可以! 经典电磁学需要微积分的知识. 电动力学需要场论初步知识. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-02 21:31:40 "},"Hardware/1_Devices/6_AntWave.html":{"url":"Hardware/1_Devices/6_AntWave.html","title":"电磁波与天线","keywords":"","body":"电磁波与天线 本文参考了知乎. 在电路中,除了电阻,电容,电感等常见的两端器件,其实还有一种器件,这就是天线.我们知道,近到看电视、听收音机、手机接打电话,远到卫星导航、三体中与外星人通讯,都用到了电磁波.甚至更确切地说,电路中的所谓电流、电压信号,也是电磁波. 交变的磁场可以产生电场(感应电动势),交变的电场(位移电流)可以产生磁场,这是电磁波的理论基础,更是电磁波为什么能在真空中传播的原因(没有导体,也就没有传导电流,但位移电流可以产生磁场啊!). 场论初步-梯度、旋度、散度 梯度 可以对标量u求梯度: grad\\,u=\\frac{\\partial u}{\\partial x}\\vec{e_{x}}+\\frac{\\partial u}{\\partial y}\\vec{e_{y}}+\\frac{\\partial u}{\\partial z}\\vec{e_{z}} 其中\\nabla算子表示这种操作: \\nabla=(\\frac{\\partial }{\\partial x}\\vec{e_{x}}+\\frac{\\partial }{\\partial y}\\vec{e_{y}}+\\frac{\\partial }{\\partial z}\\vec{e_{z}}) 例如:\\vec{E}=-\\nabla U表示电势(标量)U的梯度时电场强度(矢量). 散度 矢量场穿过闭合曲面是一个积分特性,定义为散度: \r \\begin{aligned}\r div\\,\\vec{D}&=\\frac{\\partial D_{x}}{\\partial x}+\\frac{\\partial D_{y}}{\\partial y}+\\frac{\\partial D_{z}}{\\partial z}\\\\\r &=\\left(\\frac{\\partial }{\\partial x}\\vec{e_{x}}+\\frac{\\partial }{\\partial y}\\vec{e_{y}}+\\frac{\\partial }{\\partial z}\\vec{e_{z}}\\right)\\cdot\\left(D_{x}\\vec{e_{x}}+D_{y}\\vec{e_{y}}+D_{z}\\vec{e_{z}}\\right)\\\\\r &=\\nabla\\cdot\\vec{D}\r \\end{aligned}\r 例如: \\nabla\\cdot\\vec{D}=\\rho_{V} 旋度 矢量场沿场中一闭合路径的曲线积分也是一种积分特性,定义为旋度: \r \\nabla\\times\\,H=\\left|\r \\begin{matrix}\r \\vec{e_{x}} & \\vec{e_{y}} & \\vec{e_{z}}\\\\\r \\frac{\\partial}{\\partial x} & \\frac{\\partial}{\\partial y} & \\frac{\\partial}{\\partial z}\\\\\r H_{x} & H_{y} & H_{z}\r \\end{matrix}\r \\right|\r 拉普拉斯算子\\nabla^{2} 对标量先求梯度,再求散度: \\nabla\\cdot(\\nabla u)=\\nabla^{2}u 由于矢量是坐标系基向量的线性组合\\vec{A}=A_{x}\\vec{e_{x}}+A_{y}\\vec{e_{y}}+A_{z}\\vec{e_{z}},因此定义 \\nabla^{2}\\vec{A}=\\nabla^{2}A_{x}\\vec{e_{x}}+\\nabla^{2}A_{y}\\vec{e_{y}}+\\nabla^{2}A_{y}\\vec{e_{y}} 易证明 \\nabla\\times(\\nabla\\times\\vec{A})=-\\nabla^{2}\\vec{A}+\\nabla(\\nabla\\cdot\\vec{A})\\tag{1} 矢量场和标量场的两个公式 对于任何矢量场\\vec{A},有 \\nabla\\cdot(\\nabla\\times\\vec{A})=0\\tag{2} 对于任何标量场u,有 \\nabla\\times\\nabla u=0\\tag{3} 你可以用公式(1)~(3)去证明,麦克斯韦方程组的自洽性. 再来一个公式 \\nabla\\cdot(\\vec{E}\\times \\vec{H})=\\vec{H}\\cdot(\\nabla\\times\\vec{E})-\\vec{E}\\cdot(\\nabla\\times\\vec{H})\\tag{4} 波动电磁场与辐射电磁场的区别 我们有电信号,那么我们如何将其转换为电磁波呢?您可能会想到一个简单的答案: 使用闭合导体,并借助电磁感应原理,您将能够产生波动的磁场和围绕它的电场,如图1A所示.但是,源周围的这种波动场在传输信号时没有用.这里的电磁场不传播,它只是围绕源波动.这种全部或绝大部分电磁能量被约束在有限横截面内沿确定方向传输的电磁波叫做导行波。在天线中,电磁波需要与源分开,并且它们应该传播（图1B）.天线把传输线上传播的导行波，变换成在自由空间中传播的电磁波，或者进行相反的变换。 经过实验发现,在电路中存在电势差的两个点分别拉起一根传输线.随着传输线张角的增大，辐射电磁波越强。后来又提出了对称振子天线理论，继而发展出了各种各样的天线。 图中的对称振子结构中,当l/2=\\lambda/4,也就是两根导体棒的总长度l等于波长的一半时,发射出/接收到的电磁波功率最大,因此这种振子叫做半波振子.半波振子是天线的基本辐射单元，波长越长，天线半波振子越大。 电磁波通过天线发射出去 现在取两根导电棒AC和BD，并在该电路中施加随时间变化的电压信号。 当V>0,电阻A侧电势高于B侧电势,电阻内部形成电场,根据电场切向连续的边界条件,不管R两端是否分别和A,B通过导线连接,A、B之间都会形成电场(介质是空气或者真空),此时C处的负电荷会向A端游动,D处的正电荷向B端游动. 当V,电阻A侧电势低于B侧电势,电阻内部形成电场,根据电场切向连续的边界条件,不管R两端是否分别和A,B通过导线连接,A、B之间都会形成电场(介质是空气或者真空),此时A处的负电荷会向C端游动,B处的正电荷向D端游动. 随着电压随时间的变化，导体棒BD中的正电荷和AC中的负电荷将往返移动,形成振荡. 也就是说,在导体棒C-A-B-D中,产生了交变的电流. 因此,在AB之间产生了交变的电场. 下面我们分析一下这个交变电场\\vec{E}=E_{x}\\vec{e_{x}}会产生怎样的磁场. 电磁波的传播 根据麦克斯韦方程组中电磁感应定律和安培环路定律: \\nabla\\times E=-\\frac{\\partial B}{\\partial t}\\tag{5} \\nabla\\times H=J_{c}+\\frac{\\partial D}{\\partial t}\\tag{6} 于是有 \\nabla\\times(\\nabla\\times E)=-\\nabla\\times(\\frac{\\partial B}{\\partial t})=-\\frac{1}{\\mu}\\frac{\\partial}{\\partial t}(\\nabla\\times H)=-\\mu\\sigma\\frac{\\partial E}{\\partial t}-\\frac{1}{\\mu\\epsilon}\\frac{\\partial^{2}E}{\\partial t^{2}} 根据公式(1),有 \\nabla^{2}E-\\mu\\sigma\\frac{\\partial E}{\\partial t}-\\frac{1}{\\mu\\epsilon}\\frac{\\partial^{2}E}{\\partial t^{2}}=0 同理有 \\nabla^{2}B-\\mu\\sigma\\frac{\\partial B}{\\partial t}-\\frac{1}{\\mu\\epsilon}\\frac{\\partial^{2}B}{\\partial t^{2}}=0 两个方程完全一致!电磁学啊!麦克斯韦啊!美呀~! 在真空中,无导体,因此传导电流J_{c}为0. 想一下什么情况下有导体~~当然是遇到天线啦. 方程变为 \\nabla^{2}E-\\frac{1}{\\mu\\epsilon}\\frac{\\partial^{2}E}{\\partial t^{2}}=0 \\nabla^{2}B-\\frac{1}{\\mu\\epsilon}\\frac{\\partial^{2}B}{\\partial t^{2}}=0 设\\vec{E}=E_{x}\\vec{e_{x}}+E_{y}\\vec{e_{y}}+E_{z}\\vec{e_{z}},在上图的天线中,\\vec{E}=E_{x}\\vec{e_{x}},其他两个方向分量为0. 事实上,这个天线形成的电磁场可以向任意方向传播.我们选定其中一个方向\\vec{e_{z}},来分析在该方向上电磁波的传播. 动图1 求解上面公式,可得电场\\vec{E}为: E_{x}(x,t)=E_{x0}e^{j(kz-\\omega t)} 其中 k=\\omega\\sqrt{\\mu\\epsilon},\\omega=2\\pi f_{0} 其中f_{0}是电压源的振荡频率. 由公式(5)得到: \\frac{\\partial B}{\\partial t}=\\frac{\\partial E_{x}}{\\partial y}\\vec{e_{z}}-\\frac{\\partial E_{x}}{\\partial z}\\vec{e_{y}}, 于是有\\mu\\frac{\\partial H_{z}}{\\partial t}=\\frac{\\partial E_{x}}{\\partial y}=0,\\mu\\frac{\\partial H_{y}}{\\partial t}=-\\frac{\\partial E_{x}}{\\partial z},\\mu\\frac{\\partial H_{x}}{\\partial t}=0,因此\\vec{B}与\\vec{E}垂直,且只有\\vec{e_{y}}方向的分量. 由公式(6)得到: \\frac{\\partial H_{z}}{\\partial y}-\\frac{\\partial H_{y}}{\\partial z}=\\epsilon \\frac{\\partial E_{x}}{\\partial t},于是-\\frac{\\partial H_{y}}{\\partial z}=\\epsilon \\frac{\\partial E_{x}}{\\partial t} 由公式(6)得到: \\frac{\\partial H_{z}}{\\partial x}-\\frac{\\partial H_{x}}{\\partial z}=0. 由公式(6)得到: \\frac{\\partial H_{y}}{\\partial x}-\\frac{\\partial H_{x}}{\\partial y}=0,于是有\\frac{\\partial H_{y}}{\\partial x}=0. 由此可以得到\\vec{H}也沿\\vec{e_{z}}方向传播,且只有\\vec{e_{y}}方向的分量. 求得: B_{y}(y,t)=B_{y0}e^{j(kz-\\omega t)} 其中 k=\\omega\\sqrt{\\mu\\epsilon},\\omega=2\\pi f_{0} 其中f_{0}是电压源的振荡频率,也就是电磁波的频率. 定义\\vec{k}=\\omega\\sqrt{\\mu\\epsilon}\\vec{e_{z}}, 是电磁波的传播速度. 事实上,你也可以选定方向\\vec{e_{y}},来分析在该方向上电磁波的传播,可以看出相同频率\\omega的电磁波,在不同介质中的传播速率不同. 电磁波的波长(电磁场在空间坐标系的周期)为 \\lambda=\\frac{2\\pi}{k}=\\frac{\\frac{1}{\\sqrt{\\mu\\epsilon}}}{f} 对于真空介质而言,将常数\\frac{1}{\\sqrt{\\mu\\epsilon}}记作c,其值为3\\times10^{8}m/s. 因此真空中电磁波的波长\\lambda = c/f. 综合分析之后发现,天线产生的电磁波在任意一个方向上,都是这样传播的:\\vec{E}、\\vec{B}、\\vec{k}的方向永远遵守右手坐标系的定则. 而整个天线产生的电磁波可以朝四面八方广播,这就是天线的基本工作原理. 电磁波通过天线接收电磁波 天线接收电磁波是一样的原理!如下图所示,但是要注意:天线的尺寸要特别设计,一般是天线的长度等于半波长时,感应电流最强,这也就是天线的工作频率. 现在我们计算下,当动图1中半波振子的长度l为多少时,在R两端产生的电压最大. t=0时,R两端的电压为 \r \\begin{aligned}\r U&=\\int_{0}^{l} E_{x}\\cdot dx\\\\\r &=\\int_{0}^{l} E_{x0}e^{jkx}dx\\\\\r &=\\frac{E_{x0}e^{jkl}}{k}-\\frac{E_{x0}}{k}\r \\end{aligned}\r 当e^{jkl}=-1,也就是kl=\\pi时,U取到最大值.由于\\lambda=2\\pi/k,于是当l=\\lambda/2时,半波振子接收到的功率最大! 同时根据上式,当l\\cdot k= l\\cdot\\frac{2\\pi}{\\lambda}\\approx 0时,也就是l远远小于\\lambda时,可以得到U=0,电磁波不会在元件两端产生电压差,这就是集总电路的原理. 在天线中,会吸收电磁波能量,因此如果电磁波需要远距离传播,则需要能制造大功率电磁波的天线.这部就是天眼吗~还有《三体》里那个红岸基地的巨型天线也是这玩意儿. 波长和频率之间有着密切关系，从1G到5G，使用的频率越来越高，波长越小，对应天线的尺寸越小，这就是为什么手机的天线可以藏到手机里面了。 相控阵雷达是通过调节天线阵列上不同天线单元的信号的相位,从而使阵列天线的总体电磁波的角度发生改变,实现电磁波的定向发射. 天眼接收电磁波则与相控阵的原理不太一样,它是在每个天线单元(类似卫星电视的天线(锅形天线))底座安装马达,使天线可以旋转,从而可以接收不同方向的电磁波.其中锅的作用起到电磁波的汇集作用,通过多次折射反射可以使电磁波能量只向特定的开口方向汇集,使发射或接收到的电磁波能量更大. 天线的设计需要使用HFSS(俗称海飞丝)进行电磁设计与仿真.这里不做涉及.有兴趣的可以进一步学习! 电磁波在分层介质中的传播 在分层介质中的传播,可以根据边界条件进行推导.结论就是会发生折射.每种介质都有折射率,其值为n=\\sqrt{\\mu\\epsilon},界面处遵循光折射定律n_{1}\\sin{\\theta_{1}}=n_{2}\\sin{\\theta_{2}}.其中角度\\theta是界面法线与传播方向的夹角. 电磁波在不同介质中的频率是不变的.由于折射率不同,其传播速度随介质发生改变,因此波长也会改变. 例如,在地球外大气层中,随着高度的增加,大气层中的离子浓度n越大,导致介质中的介电常数\\epsilon随高度减小.因此距离地球越远,折射率越大.最终将角度较小的光变成角度较大的光,这也是海市蜃楼的原理. 电磁波与通信 射频（RF）是Radio Frequency的缩写，表示可以辐射到空间的电磁频率，频率范围从300KHz-300GHz之间。射频简称RF射频就是射频电流，它是一种高频交流变化电磁波的简称。 微波是指频率为300MHz-300GHz的电磁波，是无线电波中一个有限频带的简称，即波长在1毫米-1米之间的电磁波，是分米波、厘米波、毫米波的统称。 毫米波(millimeter wave):波长为1～10毫米的电磁波称毫米波，它位于微波与远红外波相交叠的波长范围，因而兼有两种波谱的特点。 波长短的电磁波,其频率高,能量大,因此透射能力强,体现了粒子性; 紫外光,X射线和伽马射线波长比可见光短,它们的波长和大气粒子直径接近,这种情况极易发生散射和吸收,所以即使能量大,却被散射吸收了.地球真好,保护了它的子民们. 频率低的电磁波,其波长大,因此衍射能力强,体现了波动性; 比如广播用的无线电波，波长非常大，甚至可以绕过一栋建筑物、山头。 电离层有反射无线电波的本领．当频率在一定范围的无线电波以一定角度射向电离层时，将由电离层反射回地面，反射回地面的无线电波还可再向电离层射去，实现多次反射，这就是所谓的多跳传播．电离层对不同波段的无线电波反射作用不同，由于电离层的吸收作用，中波段的无线电波在白天几乎全部被电离层吸收．高频的微波段的无线电波，根本不能被电离层反射，直接穿透电离层射向太空．只有短波段（频率3兆赫～30兆赫，波长100米～10米）的无线电波，能通过多跳传播方式传送到几千甚至几万千米远的地方，实现远距离短波无线通信和广播． 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-04 14:28:43 "},"Hardware/1_Devices/7_EMcircuit.html":{"url":"Hardware/1_Devices/7_EMcircuit.html","title":"电磁学与电路的关系","keywords":"","body":"电磁学与电路的关系 知识回顾 电磁感应定律:\\oint E\\cdot dl=-\\int_{S}\\frac{\\partial B}{\\partial t}dS,电场的无旋性; 电场高斯定理:\\oint D\\cdot dS=q,电场的有源性; 磁场安培环路定理:\\oint_{l}H\\cdot dl=\\int_{S} \\left(J_{c}+\\frac{\\partial D}{\\partial t}\\right)\\cdot dS,磁场的有旋性; 磁场磁通连续定理:\\oint B\\cdot dS=0,磁场的无源性. 电流连续性定理:\\oint_{S}\\vec{J}\\cdot dS=-\\frac{d}{dt}\\int\\rho dV,电荷守恒定律. 本构方程1-导体的欧姆定律:J=\\sigma E 本构方程2-电介质的极化:D=\\epsilon_{0}\\epsilon_{r}E 本构方程3-磁介质的磁化:B=\\mu_{0}\\mu_{r}H 集总参数电路 只要空间中的电磁波,或者电路中信号自身产生的电磁波的波长远远大于电路的尺寸,就是集总参数电路.在电磁波与天线中我们讲到,当电路尺寸l和电磁波的波长满足l\\cdot k= l\\cdot\\frac{2\\pi}{\\lambda}\\approx 0时,也就是l远远小于\\lambda时,可以得到U=0,电磁波不会在元件两端产生电压差.此外,根据\\lambda\\gg L,于是c/f\\gg l,也就是说此时空间中的电磁波,或者电路中信号自身产生的电磁波的频率特别低,此时有\\partial D/\\partial t \\approx0,\\partial B/\\partial t \\approx0. 于是有\\oint E\\cdot dl = 0,\\oint{H\\cdot dl}=I. 基尔霍夫电流定律 根据电荷守恒定律,流入某闭合曲面内的电荷量等于曲面内电荷量的增加量,而在电场作用下,导线/介质内部不会积累电荷,于是 \\oint_{S}\\vec{J_{c}}\\cdot dS=-\\frac{d}{dt}\\int\\rho dV=0 于是在电路中任意点 \\sum^{n}_{i=1}I_{i}=0 n为与该点连接的导线数.这个方程叫做基尔霍夫电流定律(KCL). 当某点n>2时,我们一般称之为节点. 基尔霍夫电压定律 由于集总参数电路中, \\oint_{l}E\\cdot dl=0 因此 \\sum^{n}_{i=1}U_{i}=0 小结 集总参数电路是尺寸很小,频率不高的电路.当考虑到微波、射频电路时,必须考虑电磁波与电路的相互作用. 集总参数电路遵循KCL和KVL方程. 电路分析时,时刻运用两个方程进行分析. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-04 14:32:34 "},"Hardware/1_Devices/8_BJT.html":{"url":"Hardware/1_Devices/8_BJT.html","title":"半导体器件1-双极型晶体管(BJT)","keywords":"","body":"半导体器件1-双极型晶体管(BJT) 半导体器件的基础: PN结 学半导体记住一句话, 只有所有区域的多子均为电子或均为空穴时,才可以导电. 硅原子的最外层有4个价电子, 两两硅原子形成共价键,因此结构稳定,常温下不能导电. 向超级超级纯(据说99.9999999%,简称9个9)的硅晶体中均匀地掺入少量B硼原子(最外层3个价电子),B硼原子与硅原子形成三对共价键之后,结构已经较为稳定,但仍有一个空位,如果这时有其他Si原子的外层电子过来,则该电子又会形成空位。这种情况下,相当于一个正电子在移动,这种正电子叫做空穴.而B原子周围多出1个电子,形成不能自由移动的B-离子。这种材料由于有可以自由移动的空穴, 空穴携带着正电荷形成电流。这种载流子为空穴的半导体叫做P型半导体材料. 向9个9的硅晶体中均匀地掺入少量P磷原子(最外层5个价电子), P磷原子核与硅原子核形成共价键之后,多出来一个外层价电子,同时多出来不能自由移动的P+磷离子。这种载流子为电子的半导体叫做N型半导体材料. 注意,P型材料和N型材料都是电中性的,都可以导电.那么既然P型材料和N型材料都可以导电,把二者放在一起呢? 经过实验,在界面处,P区的多子空穴和N区的多子电子二者相见恨晚,分别跑向对方,并直接结合在一起,界面处没有自由电荷了,叫做耗尽区(无自由电荷的区域).交界面处P区只剩下孤单的B-硼负离子,N区只剩下寂寞的正离子P+磷正离子,离子们形成了平板电容,这个平板电容的电场叫做内电场,内电场的两端有电势差,叫做势垒,它阻止了两边的电子和空穴继续干柴烈,...咳咳,阻止了继续扩散.但是自由奔向爱情的空穴和电子表示不干了: \"我们是真爱\",不听劝阻继续向对方狂奔.而内电场随之变强,力量更大了,将来自P区的空穴和来自N区的电子隔开,表示无比的郁闷, 二者之间无电流产生. 无外加电场时，极少数的多子才能够突破强大势垒会向对面扩散,同时也有少子在内电场作用下向对方漂移,二者达到平衡时,电流为0. 这时,如果外加一个与内电场方向相反的电场(V_{p}>V_{n}),它削弱了内电场的作用,使界面处的电场不足以阻碍真实的爱情,P区和N区之间会形成较小的电流(亚阈值区). 如果外加电场的强度足够大,大到什么程度呢? 那就是内电场完全消失,真爱行动没有任何障碍,此时P型材料和N型材料之间完全导通(正向导通),此时PN结电阻很小,该外加电压叫做阈值电压.因此外加电压稍微增大,都会导致电流增大很多.PN结的正向导通电流为 i_{D}=I_{S}\\left(e^{v_{D}/V_{T}}-1\\right) \\tag{1} 科学家们表示,这还挺好玩,那我反着来呢?外加一个与内电场方向相同的电场 V_{p} ),与内电场叠加,更阻碍了真爱,将来自P区的空穴和来自N区的电子隔开,表示无比的郁闷, 二者之间无电流产生(反向截止).然而,随着外加电压的增大,内部电场变得十分强,它表示我要摧毁一切,既然自由电子和空穴都已经结合了,那我就用超强的拉力破坏掉一部分共价键,硬生生地把所有爱情都拆开,然后在我的作用下反向运动.此时自由电子和空穴突然增多,在外加电场下被迫运动,形成很大的反向电流(反向击穿). 利用击穿现象可以制造稳压二极管.但由于超大的反向电流和超大的外加电压,会输出大量的热量,如果元件热稳定性不好(散热条件不好,结温升高),导致共价键遭到彻底破坏,进一步增大反向电流,形成热电击穿,这种热稳定性不好造成的热电击穿即使冷却掉之后,PN结也不能自动恢复.因此,稳压二极管的热稳定性很棒.但一般的二极管严禁反向使用,因为一定会发生热电击穿.与反向击穿一致,普通二极管(PN结)的外加的正向电压也不能太大,因为同样会发生正向击穿. 其中i_{D}是通过PN结的电流,v_{D}是PN结的外接电压,V_{t}=kT/e是温度电压当量,常温时为0.026V.I_{S}是反向饱和电流,其典型值是10^{-8}\\sim 10^{-14}A. 硅管的阈值电压为0.6V ~ 0.7V,锗晶体管的阈值电压为0.2 ~ 0.3V. 在外加的电压信号既正向不太大,反向也不太大时,普通二极管能正常工作,其单向导电的特性使其可以整流. 把P型半导体换成贵金属,贵金属与N型半导体之间形成的金-半结,同样有着内电场的存在,但肖特基的势垒低于PN结,因此阈值电压低于PN结; 此外, PN结的导通电阻大,恢复速度低,因此只能用于低频整流,如果信号频率高,PN结来不及恢复,会发生反向漏电,烧毁普通二极管.肖特基二极管的恢复速度快,因此可以用于开关电源进行整流，但尽管如此,开关电源还是很烫啊. 二极管 发光二极管的正负极判断:一般接触处面积较大的是负极. 小结: 当外加电压很暴力时,大量空穴和电子的爱情都会被暴力拆散,外加电压表示你们的爱情不堪一击,形成很大的击穿电流. 当外加电压力度一般, 但也足以抑制内电场时,爱情会驱使他们走向对方,形成爱流,..啊呸,正向电流.当外加电压过于柔和,内电场表示,嘿嘿,你们这些小娃子,都给我乖乖立定,好好念书吧~ 二极管导通时，电阻通过\\partial V_{D}/\\partial I_{D}计算得到,很小的数值; 截止时,电阻很大,接近于开路. 双极结型晶体管(Bipolar Junction Transistor) 科学家表示,上面既然PN结这么可爱,这么有搞头,还能和金属搞成肖特基二极管,那就再开发开发这个半导体材料吧~ BJT 当V_{c}>V_{b}=V_{e}=0时, b、e之间PN结和b、c之间的pn结均截止. 当V_{c}>V_{b}>V_{e}+V_{T}时,基极电压高于发射极，电路正偏，有大量电子从发射极发射，形成I_{e}，电子原本要通过基极回到电源正极，但是发射极电子进入基极后，由于集电极电压比基极还要高，于是电子被集电极强烈的电场吸引，从而电子不走基极回到电源正极，而进入集电极到达电源正极形成集电极电流I_c，但是基极中还是有空穴的，发射极电子被集电极电场吸引进入集电极过程中，一小部分电子与基极空穴复合形成基极电流I{b}。这就是三级管电流走向。而基极空穴较少，所以发射极电子被集电极电场吸引进入集电极过程与基极空穴复合概率较小，当基极的电流增大（空穴增多）时，因为电子与基极空穴复合概率较小，所以，基极电流稍微增大一点，就需要很多的电子才能与基极增多一点的空穴复合，因此，基极电流变化一点，而引起发射极电流发生较大的变动，从而实现了放大作用。 BJT放大信号的本质是发射极电子只有小部分到达基极,因此是流控电流源(ICCS) 当V_{b}继续增大,达到V_{b}>V_{c}>V_{e},两个PN结均正偏.当基极电流I_{b}增大时,基极空穴增多, 更多的电子从发射极发出,因此通过基极向集电极的电流增大,但同时集电极也向基极发出更多的电子,电流也增大.二者的差值保持稳定.也就是电流达到饱和. 那么实际使用时,如果我有一个比较小的交流小信号,只想让三极管放大它怎么办? 也就是说,要时刻保证BJT的V_{c}>V_{b}>V_{e}+V_{T}. 把加在b极的电压V_{b}分为直流信号V_{B}和交流小信号v_{b}:V_{b}=V_{B}+v_{b} 直流信号V_{B}使用偏置电阻R_{B1}和R_{B2}进行分压获得,通过调节电阻阻值,可以设置三极管的V_{B}大小,也就设置了三极管的工作状态,叫做 直流工作点. 把需要放大的信号u_{i}作为交流小信号v_{b},通过电容C_{1}耦合进来(电容通交流阻直流),其容抗(R_{C}=1/j\\omega C)对信号来说越小越好,因此,在低频放大电路中,常使用电解电容器(低频时铝电解电容容抗很小,高频时则不如钽电容). 设计偏置电路时,直流信号把电容视为开路,把当前的直流工作点记为Q点. 其中V_{BQ}=\\frac{R_{B2}}{R_{B1}+R_{B2}}V_{CC},I_\\text{EQ}=\\frac{V_{BQ}-V_{BEQ}}{R_{E}},I_{CQ}\\approx I_{EQ},I_{BQ}=\\frac{I_{EQ}}{\\beta},V_{CEQ}=V_{CC}-I_{CQ}(R_{C}+R_{E}). 进行交流信号分析时,则需要把直流电源设置为0.(电压源V=0短路,电流源V=0开路) A_{v}=\\frac{v_{o}}{v_{i}}=\\frac{-\\beta i_{b} R'_{L}}{i_{b}r_{be}}=\\frac{-\\beta R'_{L}}{r_{be}} 其中R'_{L}=R_{C}||R_{L},r_{be}是晶体管的交流输入电阻,是基极的体积电阻r_{bb}和be之间的结电阻之和(基极的掺杂浓度最低,体积电阻一般为几十到二三百欧姆;发射极掺杂很高,体积电阻很小; pn结电阻通过公式(1)求得;). r_{be}=r_{bb}+\\frac{\\partial V_{BE}}{\\partial I_{BE}}\\approx r_{bb}+\\frac{V_{T}}{I_{BE}}\\approx 200+\\beta \\frac{26mV}{I_{E}(\\text{mA})} 源电压放大倍数 A_{vs}=\\frac{v_o}{v_s}=\\frac{v_{o}v_{i}}{v_{i}v_{s}}=A_{v}\\frac{R_{i}}{R_{i}+R_{s}} 其中 R_{i}=R_{B1}||R_{B2}||r_{be}(求输入电阻需要设置网络内所有独立电源为0). 求输出电阻需要设置网络内所有独立电源为0,则得到输出电阻为R_{o}=R_{C}. 通过这几个式子,配合仿真软件Multisim或者HSPICE或Spectre等,可以计算出几个电阻的值. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-04 14:37:16 "},"Hardware/1_Devices/9_MOS.html":{"url":"Hardware/1_Devices/9_MOS.html","title":"半导体器件2-MOS管","keywords":"","body":"半导体器件2-MOS管 MOS管原理 既然半导体材料这么有意思,又能整流,又能放大,那科学家就提了,能不能做开关呢? 于是就有人做出来啦！来看看这个小开关! 平面工艺-版图 剖面图 立体图 把一个P型的半导体材料作为地基(叫做衬底),连接的电极叫做基极(Bulk,主体); 在上面铺一层厚厚的SiO_{2}材料(这玩意儿自然界很多,土里到处都是,记住是绝缘的就可以了),叫做场氧化层, 在某一个小区域把厚厚的SiO_{2}削薄,叫做刻蚀,形成很薄的SiO_{2}薄膜. 在该区域的两侧大量注入N型原子(磷原子等),形成N型区域(记为扩散区),这个过程就是掺杂的过程; 然后使用淀积的方法长一层多晶硅材料(Poly-Silicon,以多个硅原子核(晶核)为中心,向不同方向生长的硅晶体),并掺入杂质原子使其能在常温下导电,形成类似金属的功能.把多晶硅的电极叫做栅极(gate ,门的意思,中文翻译做栅栏门,阀门); 这种金属(Poly)-氧化物(Oxide)-半导体(Semiconductor)结构,简记为MOS. 你可能有疑问,这尼玛分明,就是多晶硅,你非要说时金属? 其实多晶硅可以通过重掺杂(浓度高)来改变其导电能力,从而调整MOS开关的阈值电压,而金属不方便调阈值电压. 截止区：当V_\\text{GB(S)}\\ge0,N区多子(主要是N区多子和极少数的衬底中少子)受到电场的勾引,向上移动与P型半导体的多子空穴结合,在表面留下了形成一层耗尽层(仍没有多余的电子用于导电).NMOS两个N区被P型衬底隔开,在D和S之间加电压也不会电流。 线性区：V_\\text{GB(S)}继续增大, 耗尽层变厚,直到靠近表面的电子越来越多,当多于空穴时,在表面形成电子层,叫做反型层,与两个N区连成一片,这片反型层的区域叫做沟道.它可以导电,此时的V_\\text{GB(S)}电压叫做 阈值电压,记做V_{th}.N区和沟道区等能够在衬底表面导电的区域,叫做Active区,国内叫做有源区. 既然能导电了,那么我在两片N区两端加上电势差V_{DS},就可以有电流通过. 其实,在V_\\text{GB(S)}略低于阈值时,也有较小电流通过,叫做亚阈值区.此时MOS管进入线性区. 沟道长度L 是集成电路工艺的制程标准.沟道宽度W 在模拟集成电路设计中至关重要. 导通时沟道中为电子的,叫做Ｎ型沟道,MOS管叫做NMOS. 反之,导通时为空穴的,叫做PMOS管. 把两片N区物理上没有任何区别; 但为了区分,设定源极(source,电源)作为载流子的来源,漏极(drain,排出,泄漏)是载流子的电极.因此,NMOS的低电位端为源极,PMOS的高电位端为源极. 注意,MOS管的阈值电压与PN结的阈值电压原理上不同. MOS管时反型层生成时的电压,PN结是内电场被抵消时的电压. 饱和区: V_\\text{DS}进一步增大时,S极和D极之间形成电场,导致V_{GS}>V_{GD},所以D端沟道会变窄.直到V_{DS}=V_{GS}-V_{th}刚好D端沟道消失,这种情况叫做预夹断.此时的电压叫做过驱动电压,记做V_{DS,sat}.漏极电位进一步上升时,漏极的反型层消失,出现夹断区(其实夹断区长度远小于沟道长度,可能只有几个nm).V_{DS}-V_{DS,sat}全部落在夹断区,电子沿着沟道运动时向漏极运动,到达夹断区时,会在较强的电场作用下直接漂移向漏极.此时在保持V_{GS} 为恒定值的前提下增大V_{DS},沟道电流几乎不变(S端的沟道厚度没有变).此时MOS管进入饱和区.如果保持V_{DS}恒定,增大V_{GS}，则反型层(沟道)变厚,相当于增大了导体的横截面积,DS之间的电流也随之增大,从而达到放大信号的目的.MOS管放大的本质是V_{GS}改变了沟道电阻,产生了电流,因此是压控电流源(VCCS). 但注意：过度增大V_{GS}会使MOS管的栅氧化层击穿. 击穿区: 当V_{DS}过大时,D端电压会远高于衬底电压,漏端的PN结会反向击穿.$V_{DS}电流会很大. MOS管总结 截止区(V_\\text{GB(S)}\\le V_{th}): I_{DS}=0. 亚阈值区: I_{D}=I_{0}\\exp\\frac{V_{GS}}{ξ V_{T}},ξ为非理想因子,V_{T}=kT/e为热电压. 线性区(V_\\text{GB(S)} > V_{th},0): I_{D}=\\mu_n \\frac{\\epsilon_{0}\\epsilon_{ox}}{t_{ox}}\\bullet \\frac{W}{L}\\left[ (V_{GS}-V_{th})V_{DS}-\\frac{1}{2}V_{DS}^{2}\\right] 其中\\mu_{n}为N型半导体载流子(电子)的迁移率,C_{ox}=\\epsilon_{0}\\epsilon_{ox}/t_{ox}为单位面积的栅氧化层电容. 饱和区(放大)(V_\\text{GB(S)}\\ge V_{th},V_{DS} \\ge V_{GS}-V_{th} ): I_{D}=\\mu _n\\frac{\\epsilon_{0}\\epsilon_{ox}}{2t_{ox}}\\bullet \\frac{W}{L} (V_{GS}-V_{th})^{2} MOS管的输出特性曲线 BJT的输出特性曲线中,放大区受i_{b}控制,三个区域分别是截止区,饱和区,放大区; MOS的输出特性曲线中,放大区受V_{GS}控制,三个区域分别是截止区,线性区,和饱和放大区. 在模拟CMOS集成电路设计中,我们只关注MOS的饱和区.在CMOS数字电路设计中,一般工作在线性区. MOS管的大信号模型(交流信号的幅度很大): NMOS管的直流工作点 MOS管的小信号模型(交流信号的幅度很小): NMOS管的基本小信号模型 沟道长度调制效应. 事实上,考虑沟道长度受到V_{DS}影响,对公式做出修正. I_{D}=\\mu _n\\frac{\\epsilon_{0}\\epsilon_{ox}}{2t_{ox}}\\bullet \\frac{W}{L} (V_{GS}-V_{th})^{2}(1+\\lambda V_{DS}) 此时,MOS管的导通电阻不为0. r_{o}=\\frac{\\partial V_{DS}}{\\partial I_{D}}=\\frac{1}{\\partial I_{D}/\\partial V_{DS}}=\\frac{2}{\\mu_{n}C_{ox}\\frac{W}{L}(V_{GS}-V_{th})^{2}\\lambda}\\approx \\frac{1}{\\lambda I_{D}} 对于长沟道,沟道长度调制系数\\lambda的值很小. 此时NMOS管的小信号模型变成了下图. 考虑沟长调制后NMOS管的小信号模型 体效应 在CMOS集成电路中,所有的PMOS管的基极接V_{DD},所有NMOS管的基极接GND. 之前都假设了V_{S}=V_{B}, 衬底和源极相连.然而,大多数情况下该情况不成立.例如,最常见的电路二输入与非门中,T2管的S极电压与T1管的D极电压相等,由于导通电阻的存在,其电压不为0. 在传输门中,这种情况更为常见. 二输入与非门 当V_{S}>V_{B}=0时,沟道导通时V_{GS}=V_{th0},此时的V_{G}为 V_{th}=V_{th0}+\\gamma(\\sqrt{2|\\phi_{F}+V_{SB}|}-\\sqrt{2|\\phi_{F}|}) 其中V_{th0}是V_{B}=V_{S}时的阈值电压; \\gamma为体效应系数,典型值(0.3\\sim0.4)\\sqrt{\\text{V}}, \\phi_{F}是反型层的表面电势. V_{S}>V_{B}=0时,漏极电流I_{D}也受到该V_{SB}的影响,V_{S}越大,D和S之间压差越小,电流也越小. 考虑沟长调制、体效应后NMOS管的低频小信号模型 高频下的小信号模型 信号频率较高时,除了D、S之间导通,其电容很小,各极之间的电容不能忽略. 完整的小信号模型 短沟道效应: 随着工艺能力提升,沟道变短: 垂直电场更大,沟道内载流子更贴近表面,迁移速度下降. 水平电场也更大,载流子速度达到饱和. 高场强之下,热载流子 加速-碰撞电离-更多的载流子. 事实上, 在制造过程中, 源极和漏极横向扩散L_{D}，导致有效的沟道长度L_\\text{eff} = L-2L_{D},小于设计的沟道长度L.因此需要仿真. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-04 14:42:15 "},"Hardware/2_SigCirSys/":{"url":"Hardware/2_SigCirSys/","title":"电路中的信号","keywords":"","body":"内容列表 回到主页 ImgProc SigProc 理解卷积 傅里叶级数与傅里叶变换(Fourier Transform) 小波变换(一): 为什么需要小波? 小波变换(二): 小波基函数,母小波和父小波 小波变换(三): 从实例代码看Haar小波分解和重构 小波变换(四): 常用小波特点及二维小波变换 小波变换(五): 小波变换与卷积 小波变换彩蛋: Python中的小波变换库 .vscode 资源(右键打开或下载) settings.json res 资源(右键打开或下载) sigGen.py sigSpectrum.py WaveletTrans.py WaveletTransTest.py init.py pycache 资源(右键打开或下载) fourier.cpython-36.pyc sigGen.cpython-36.pyc WaveletTrans.cpython-36.pyc init.cpython-36.pyc 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Hardware/2_SigCirSys/SigProc/conv1.html":{"url":"Hardware/2_SigCirSys/SigProc/conv1.html","title":"理解卷积","keywords":"","body":"理解卷积 卷积的内涵 先给公式，f函数和h函数的卷积： (f*h)(t)=\\int^{t}_{-\\infty}f(\\tau)h(t-\\tau)d\\tau \\tag{1} 什么意思呢？对于任意的输入信号x(t),都可以表示为 \r x(t)=\\sum_{t_{k}\\in R}x(t_k)\\delta(t-t_{k})\r 即，任意输入信号均可分解为冲激函数\\delta(t)的线性组合。输入信号为单位冲激函数(幅值为1)时，把对应的输出(响应结果)定义为h(t)。也就是说，h(t)是系统对单位冲激函数\\delta的响应。注意，这个响应函数h(t)是系统决定的，每个系统都有自己的h(t)函数，因此h(t)也叫系统函数: \r h(t)=\\frac{y(t)}{x(t)}\r 如下图所示，如果系统的输入在t=0时刻的幅值为f(0)，那么系统对它的响应就是f(0)h(t)。 也就是说，该输入对应的系统输出为： \r y(t)=f(0)h(t),\r 事实上，而实践中，输入一般是连续的信号。例如，在t=1时刻，系统的输入为f(1)，则该输入相应的输出为f(1)h(t-1),\\text{here}\\;t>1。因此，如果在任一时刻\\tau，系统中的输入为f(\\tau)，那么该输入对应的输出为f(\\tau)h(t-\\tau)。而t时刻时的输出，不只是当前时刻t的输入的作用，还包括之前的所有时刻\\tau的输入带来的作用。因此，系统在t时刻的输出，是t时刻之前所有时刻的输入信号作用的求和。即 \r y(t)=\\sum_{\\tau=-\\infty}^{\\tau 写成积分的形式，即可得到式(1)。 因此，式(1)的含义是：系统t时刻的输出，是该时刻之前的所有输入f(t)引起的响应累积作用的结果。 图解法求卷积 把h换成g，重写卷积公式： y(t)=(f*g)(t)=\\int^{t}_{-\\infty}f(\\tau)g(t-\\tau)d\\tau \\tag{3} 已知f(t)和g(t)的表达式以及函数图像，怎么求得二者的卷积结果呢? 为了理解方便，设f(t)和g(t)都是方框函数， \r f(t)=\\begin{cases}1\\quad&t\\leq|a|\\\\0&\\text{Others}\\end{cases}\r \r g(t)=\\begin{cases}0.5\\quad&0\\leq t\\leq b\\\\0&\\text{Others}\\end{cases}\r 如下图所示。考察公式(3)，求y(t)，就是求t时刻之前，所有\\tau时刻f(\\tau)与g(t-\\tau)乘积的和。 为了求f(\\tau)与g(t-\\tau)的乘积并积分，需要首先分别画出f(\\tau)，g(t-\\tau)关于\\tau的图像。f(\\tau)-\\tau的图像直接根据表达式可以画出，如下图紫色矩形框所示。g(t-\\tau)关于\\tau的图像则需要对函数g(\\tau)-\\tau图像依次做反褶(沿\\tau=0做镜像)，然后右移t，并计算在不同t下，两个函数曲线所围的面积(如果f(0)=2呢，就不是面积了。这里为了举例方便，设置了f(0)=1，应该是f*g)。 当t时，需要对反褶的g图像左移|t|，然后计算两个函数曲线所围的面积。 当t时，相当于对反褶的g图像左移|t|(|t|>a)，两曲线无重叠区域，因此y(t)=0； 当t=-a，相当于对反褶的g图像左移a，反褶的g图像右侧与f(t)左侧刚好重叠。 当-a，相当于对反褶的g图像左移|t|(|t|，二者重叠区域变大。 当0，相当于对反褶的g图像右移|t|(|t|，二者重叠区域进一步变大。 当t=a，相当于对反褶的g图像右移a，二者重叠区域达到极大值。 当a，相当于对反褶的g图像右移|t|(a，反褶的g图像将f(t)整体包围，二者重叠区域保持极大值。 当t=b-a，相当于对反褶的g图像右移b-a，反褶的g图像左侧与f(t)左侧重叠。 当b-a，相当于对反褶的g图像右移|t|，反褶的g图像左侧进入f(t)图像中，二者重叠区域随t的右移而减小。 当t=a+b，相当于对反褶的g图像右移|t|=a+b，反褶的g图像左侧与f(t)图像右侧重叠，二者重叠面积变为0。 当t>a+b，相当于对反褶的g图像右移|t|>a+b，反褶的g图像左侧与f(t)图像右侧分别且随着t增大而渐行渐远，二者重叠面积保持为0。 在此过程中，随着t从-\\infty逐渐增大到0再到+\\infty，反褶的g图像其实从左侧无穷远处紧贴着t逐渐向右滑动到反褶图像原本位置，再到右侧无穷远处。反褶的g图像就像一个滑动的窗口，因此该方法也常称作滑窗法。 卷积的计算机算法 计算卷积的算法是\"不进位乘法\"，如下图所示(计算机编程的算法，与上述图解法一样的)： 二维卷积 与一维卷积的滑窗类似，二维卷积也用滑窗进行计算。广泛用在图像处理领域。 以下内容转自CSDN博客 算法：对矩阵A,B进行卷积：conv2(A,B)，其中A为图像矩阵，B为卷积核。 对矩阵A补零。如图。 将卷积核B分别沿行方向和列方向进行反褶(相当于沿中心旋转180°)。如图。 滑动滑窗，将卷积核的中心位于图像矩阵的每个元素，求滑窗内两矩阵点积(按元素乘)之和。如图。 在图像处理中，卷积常用于对图像模糊处理，边缘检测，产生轧花效果等。 在深度学习中，卷积在卷积网络中发挥作用。 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-02-13 00:54:17 "},"Hardware/2_SigCirSys/SigProc/FourierTransform.html":{"url":"Hardware/2_SigCirSys/SigProc/FourierTransform.html","title":"傅里叶级数与傅里叶变换(Fourier Transform)","keywords":"","body":"傅里叶级数与傅里叶变换(Fourier Transform) 频谱分析是一种对于周期性波动信号做数值分析的方法，将随时间做周期性变化的振动信号分解为不同频率的振动分量，形成频谱。 概要 连续的周期信号用E=\\{e^{ikωt}\\},k\\in N作为基函数，进行傅里叶级数分析； 连续的非周期信号(自然信号)用傅里叶变换，进行频域分析； 离散的非周期信号(采样的自然信号)用离散傅里叶变换，进行频域分析。 正余弦级数展开 设周期信号 f(t) 的周期为 T ，相应的 \\omega = \\frac{2\\pi}{T} 。现在以 E=\\{1,cos⁡kωt,sin⁡kωt\\},k\\in N^{+} 作为一组正交基函数，进行傅里叶级数展开： \r \\begin{aligned}\r f(t)&=\\sum_{g_{k}(t)\\in E}c_{k}g_{k}(t) \\\\\r &=a_{0}+\\sum^{\\infty}_{k=1}\\{a_{k}\\cos k\\omega t + b_{k}\\sin k\\omega t\\} \\\\\r &=\\sum^{\\infty}_{k=0}\\{a_{k}\\cos k\\omega t + b_{k} \\sin k\\omega t\\}\r \\end{aligned}\\tag{1}\r 其中，系数a_k和b_k是函数f(t)在基函数g_{k}(t)上分量的振幅大小。由于正交函数之间的内积\\langle g_i (t),g_j (t)\\rangle=0，其中i≠j。于是 \r \\langle f(t),g_n (t)\\rangle =\\sum_{g_k (t)\\in E}c_k \\langle g_k (t),g_n (t)\\rangle =c_n \\langle g_n (t),g_n (t)\\rangle \\tag{2}\r 因此分量振幅的大小c_n可以通过函数的内积计算， \r c_n=\\frac{\\langle f(t),g_n (t)\\rangle}{\\langle g_n (t),g_n (t)\\rangle} =\\frac{\\int_{-∞}^{+∞}f(t)\\bullet g_n (t)dt}{\\int_{-∞}^{+∞}g_n (t)∙g_n (t)dt}\\tag{3}\r 对于周期为T的信号f(t)，可计算得到 \r \\begin{aligned}\r a_0&=\\frac{1}{T} \\int_{t_0}^{t_0+T}f(t)dt\\\\\r a_n&=\\frac{2}{T} \\int_{t_0}^{t_0+T}f(t) \\cos ⁡n\\omega t dt \\\\\r b_n&=\\frac{2}{T} \\int_{t_0}^{t_0+T}f(t) \\sin⁡ n\\omega t dt\r \\end{aligned}\\tag{4}\r 根据公式(1)和公式(4)，可以把任意周期函数f(t)展开为正弦和余弦函数的级数。 傅里叶级数 与正余弦级数展开完全类似，只不过把E=\\{e^{ikωt}\\},k\\in N作为一组新的正交基函数，于是对周期信号f(t)进行傅里叶级数展开： \r f(t)=\\sum_{k=-\\infty}^{\\infty}A_{k}\\bullet e^{ikωt}\\tag{5}\r 由于\\int_{-\\infty}^{\\infty}e^{in \\omega t}dt=\\int_{-\\infty}^{\\infty}(\\cos ⁡n\\omega t+i \\sin⁡ n\\omega t)dt=0，于是 \r \\langle f(t),e^{-in\\omega t} \\rangle =\\sum_{k=-\\infty}^{\\infty}A_k \\int_{-\\infty}^{\\infty}e^{ik\\omega t}\\bullet e^{-in\\omega t} dt=A_n \\int_{-\\infty}^{\\infty}1dt\\tag{6}\r 对于周期为T的信号f(t)，可以计算分量的振幅为 \r A_k=\\frac{1}{T} \\int_{-\\frac{T}{2}}^{\\frac{T}{2}}f(t) e^{-ik\\omega t} dt\\tag{7}\r 傅里叶变换 但当信号f(t)为非周期信号，即T\\rightarrow \\infty，则信号的频率\\omega\\rightarrow 0， 记W=k\\omega，则与相邻基函数的频率相差为\\Delta W=(k+1)\\omega - k\\omega=\\omega \\rightarrow 0。 公式(7)可以写成 \r A_k=\\frac{1}{T} \\int_{-\\frac{T}{2}}^{\\frac{T}{2}}f(t) e^{-iW t} dt\\tag{8}\r 则对于任意非周期信号， \r \\begin{aligned}\r f(t)&=\\lim_{T\\rightarrow \\infty}\\sum^{\\infty}_{k=-\\infty}(\\frac{1}{T}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}}f(t) e^{-ik\\omega t} dt)e^{ik\\omega t} \\\\\r &=\\lim_{T\\rightarrow \\infty}\\sum^{\\infty}_{W=-\\infty}(\\frac{1}{T}\\int_{-\\frac{T}{2}}^{\\frac{T}{2}}f(t) e^{-iW t} dt)e^{iW t} \\\\\r &=\\lim_{\\Delta W\\rightarrow 0}\\sum^{\\infty}_{W=-\\infty}(\\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty}f(t) e^{-iW t} dt)e^{iW t}\\Delta W\\\\\r &=\\frac{1}{2\\pi}\\int^{\\infty}_{-\\infty}(\\int_{-\\infty}^{\\infty}f(t) e^{-iW t} dt)e^{iW t}dW\r \\end{aligned}\\tag{9}\r 令 \r F(W)=\\int_{-\\infty}^{\\infty}f(t) e^{-iW t} dt\\tag{10}\r 则 \r f(t)=\\frac{1}{2\\pi}\\int^{\\infty}_{-\\infty}F(W)e^{iW t}dW\\tag{11}\r 公式(10)与公式(11)就是大名鼎鼎的傅里叶变换与傅里叶反变换。 常用的离散傅里叶变换(DFT,Descrete Fourier Transform) 自然界中的信号大部分都是连续非周期信号。因此傅里叶变换的应用远远多于傅里叶级数。 通常，我们会收集一段信号，该信号是由ADC采样得到，因此是时间离散的信号，该离散的非周期信号是从连续的非周期信号中采样产生的，采样的时间区间为T=[t_{1},t_{2}]，采样的时间间隔为\\Delta t=\\frac{T}{N}，于是采样得到的信号 f_{s}(t)=f(t)\\delta(t_{1}+n\\Delta t) 则该采样信号的傅里叶变换： \r \\begin{aligned}\r F_{s}(\\omega)&=\\int_{t_{1}}^{t_{2}}f(t) e^{-i\\omega t} \\delta(t_{1}+n\\Delta t)dt \\\\\r &=\\frac{T}{N}\\sum_{n=0}^{N-1}f(t_{1}+n\\Delta t) e^{-i\\omega (t_{1}+n\\Delta t)}\r \\end{aligned}\\tag{12}\r 如果F_{s}(\\omega)的频率取值区间为[\\omega_{1},\\omega_{2}]，则有 \r F_{s}(\\omega_{1}+k\\Delta\\omega)=\\frac{T}{N}\\sum_{n=0}^{N-1}f(t_{1}+n\\Delta t) e^{-i(\\omega_{1}+k\\Delta\\omega) (t_{1}+n\\Delta t)} \\tag{13}\r 其中, \\Delta\\omega = \\frac{\\Omega}{K}表示频域抽样间隔，\\Omega=\\omega_{2}-\\omega_{1}表示带宽。 同样的，对于傅里叶逆变换，由于f(t)的频带主要位于[\\omega_{1},\\omega_{2}]，因此 \r f(t)=\\frac{1}{2\\pi}\\int^{\\infty}_{-\\infty}F(\\omega)e^{i\\omega t}d\\omega=\\frac{\\Omega}{2\\pi K}\\sum^{K-1}_{k=0}{F(\\omega_{1}+k\\Delta\\omega)e^{i(\\omega_{1}+k\\Delta\\omega)t}}\\tag{14}\r 在时域的抽样点处，有 \r f(t_{1}+n\\Delta t)=\\frac{\\Omega}{2\\pi K}\\sum^{K-1}_{k=0}{F(\\omega_{1}+k\\Delta\\omega)e^{i(\\omega_{1}+k\\Delta\\omega)(t_{1}+n\\Delta t)}}\\tag{15}\r 公式(12)和(14)体现了离散非周期信号的变换与逆变换，被广泛用于信号分析。 傅里叶变换实例 现在以 f(t)=\\begin{cases}1 &\\lvert{t}\\rvert\\leq{1}\\\\0 &\\text{Others}\\end{cases}为例，画出其频谱及恢复后的波形。 根据式(10) \r F(w)=\\int_{-1}^{1}e^{-i\\omega t}dt=\\frac{1}{w}[\\sin wt+i\\cos wt]\\vert_{-1}^{1}=\\frac{2}{w}\\sin w \\tag{16}\r 也就是说，其频谱为F(w)=\\frac{2}{w}\\sin w，幅度为\\left\\vert F(w)\\right\\vert =\\left\\vert\\frac{2}{w}\\sin w\\right\\vert。 意思就是如下图，原图源自韩昊： Python代码如下： # -*- using: utf-8 -*- import numpy as np import matplotlib.pyplot as plt def fourierTrans(f_t, t, omg): \"\"\" return signal in the frequency domain Paras: f_t: input signal t: a list of sample points in time domain omg: a list of sample points in frequency domain, omg = 2 * pi * f \"\"\" T = t[-1] - t[0] N = len(t) # OMG = omg[-1] - omg[0] K = len(omg) F_omg = np.zeros_like(omg, dtype=complex) # 初始化频谱 for k in range(K): for n in range(N): F_omg[k] = F_omg[k] + T / N * f_t[n] * np.exp( complex(0, -1) * omg[k] * t[n]) return F_omg def ifourierTrans(F_omg, t, omg): \"\"\" return signal in the time domain Paras: F_omg: input, the amplitude in frequency domain t: a list of sample points in time domain omg: a list of sample points in frequency domain \"\"\" # T = t[-1] - t[0] N = len(t) OMG = omg[-1] - omg[0] K = len(omg) fs = np.zeros_like(t, dtype=complex) for n in range(N): for k in range(K): fs[n] = fs[n] + OMG / 2 / np.pi / K * F_omg[k] * np.exp( complex(0, 1) * omg[k] * t[n]) return fs def main(): T = 4 # 时域区间长度 N = 201 # 时域抽样点数 t = np.linspace(-T / 2, T / 2, N) # 时域抽样点 OMG = 16 * np.pi # 频域区间长度 K = 101 # 频域抽样点数 omg = np.linspace(-OMG / 2, OMG / 2, K) # 频域抽样点 f_t = np.zeros_like(t) # 初始化f mlist = [i for i in range(len(t)) if (t[i] -1)] f_t[mlist] = 1 # 设置好f F_omg = fourierTrans(f_t, t, omg) fs = ifourierTrans(F_omg, t, omg) plt.figure(figsize=(12, 4)) ax1 = plt.subplot(1, 2, 1) plt.plot(t, f_t, color='blue', linestyle='-', label='f') plt.plot(t, fs.real, color='red', linestyle=':', label=\"f'\") ax1.set_xlabel('$t$') ax1.set_ylabel('$f(t)$') ax1.legend(loc='upper right') ax2 = plt.subplot(1, 2, 2) plt.plot(omg, F_omg.real, 'k-') ax2.set_xlabel('$\\omega$') ax2.set_ylabel('$F(\\omega)$') plt.show() if __name__ == \"__main__\": main() 做出的图为 快速傅里叶变换 傅里叶变换中，包含了大量的乘方运算，导致计算时间较长。在实际应用中，很难实时地处理问题。于是要加速傅里叶变换，涌现了一批能够执行快速傅里叶变换的算法，统称为快速傅里叶变换(Fast Fourier Transform,FFT)。 \r F_{s}(\\omega_{1}+k\\Delta\\omega)=\\frac{T}{N}\\sum_{n=0}^{N-1}f(t_{1}+n\\Delta t) e^{-i(\\omega_{1}+k\\Delta\\omega) (t_{1}+n\\Delta t)} \\tag{12}\r 直接按这个定义求值需要 O(KN) 次运算：F 共有 K 个输出，每个输出需要 N 项求和。直接使用DFT运算需使用N个复数乘法(4N 个实数乘法)与N-1个复数加法(2N-2个实数加法)，因此，如果认为N与K相当，则计算使用DFT所有K点的值需要K N =N N复数乘法与N * N - N 个复数加法。FFT则是能够用更少次操作计算出相同结果的任何方法。更准确的说，所有已知的FFT算法都需要 O(N log N) 次运算（技术上O只标记上界），虽然还没有已知的证据证明更低的复杂度是不可能的。 要说明FFT节省时间的方式，就得考虑复数相乘和相加的次数。直接计算DFT的值涉及到 N2 次复数相乘和 N(N−1) 次复数相加（可以通过削去琐碎运算（如乘以1）来节省 O(N) 次运算）。众所周知的基2库利-图基算法，N 为2的幂，可以只用 (N/2)log2(N) 次复数乘法（再次忽略乘以1的简化）和 Nlog2(N) 次加法就可以得到相同结果。在实际中，现代计算机通常的实际性能通常不受算术运算的速度和对复杂主体的分析主导，但是从 O(N2) 到 O(N log N) 的总体改进仍然能够体现出来。 FFT算法很多，根据实现运算过程是否有指数因子K,N可分为有、无指数因子的两类算法。 有指数因子的算法 经典库利-图基算法 当输入序列的长度N不是素数(素数只能被1而它本身整除）而是可以高度分解的复合数，即N=N1N2N3…Nr时，若N1=N2=…=Nr=2，N=2则N点DFT的计算可分解为N=2×N/2，即两个N/2点DFT计算的组合，而N/2点DFT的计算又可分解为N/2=2×N/4，即两个N/4点DFT计算的组合。依此类推，使DFT的计算形成有规则的模式，故称之为以2为基底的FFT算法。同理，当N=4时，则称之为以4为基底的FFT算法。当N=N1·N2时，称为以N1和N2为基底的混合基算法。 在这些算法中，基2算法用得最普遍。通常按序列在时域或在频域分解过程的不同，又可分为两种：一种是时间抽取FFT算法（DIT），将N点DFT输入序列x(n)、在时域分解成2个N/2点序列而x1(n)和x2(n)。前者是从原序列中按偶数序号抽取而成，而后者则按奇数序号抽取而成。DIT就是这样有规律地按奇、偶次序逐次进行分解所构成的一种快速算法。 分裂基算法(RSFFT) 1984年由P．杜哈美尔和H．赫尔曼等导出的一种比库利图基算法更加有效的改进算法，其基本思想是在变换式的偶部采用基2算法，在变换式的奇部采用基4算法。优点是具有相对简单的结构，非常适用于实对称数据，对长度N=2能获得最少的运算量(乘法和加法），所以是选用固定基算法中的一种最佳折衷算法。 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-02-12 21:31:39 "},"Hardware/2_SigCirSys/SigProc/wavelet1.html":{"url":"Hardware/2_SigCirSys/SigProc/wavelet1.html","title":"小波变换(一): 为什么需要小波?","keywords":"","body":"小波变换(一): 为什么需要小波? 系列文章列表 本文是《小波变换》系列的第1篇，主要介绍为什么需要小波. 小波变换(一): 为什么需要小波? 小波变换(二): 小波基函数,母小波和父小波 小波变换(三): 从实例代码看Haar小波分解和重构 小波变换(四): 常用小波特点及二维小波变换 小波变换(五): 小波，傅里叶与卷积的关系 从傅里叶变换的不足之处开始说起 理解本文需要先理解傅里叶变换，默认正处在理解了傅里叶但还没理解小波的道路上。 我们知道傅里叶变化可以分析信号的频谱，那么为什么还要提出小波变换？答案就是方沁园所说的，“对非平稳过程，傅里叶变换有局限性”。 看如下的该信号: 做完FFT（快速傅里叶变换）后，可以在频谱上看到清晰的四条线，信号包含四个频率成分。 一切没有问题。但是，如果是频率随着时间变化的非平稳信号呢？ 代码点我可查看 最上边的是频率始终不变的平稳信号。而下边两个则是频率随着时间改变的非平稳信号，它们同样包含和最上信号相同频率的四个成分。做FFT后，我们发现这三个时域上有巨大差异的信号，频谱（幅值谱）却非常一致。 我们从频谱上无法区分下边两个非平稳信号，因为它们包含的四个频率的信号的成分确实是一样的，只是出现的先后顺序不同。 对于这样的非平稳信号，只知道包含哪些频率成分是不够的，我们还想知道各个成分出现的时间。知道信号频率随时间变化的情况，各个时刻的瞬时频率及其幅值——这也就是时频分析。 短时傅里叶变换(Short-Time Fourier Transform, STFT) 一个简单可行的方法就是——加窗。我又要套用方沁园同学的描述了，“把整个时域过程分解成无数个等长的小过程，每个小过程近似平稳，再傅里叶变换，就知道在哪个时间点上出现了什么频率了。”这就是短时傅里叶变换。 看图： 时域上分成一段一段做FFT，不就知道频率成分随着时间的变化情况了吗！用这样的方法，可以得到一个信号的时频图了： 图上既能看到10Hz, 25 Hz, 50 Hz, 100 Hz四个频域成分，还能看到出现的时间。两排峰是对称的，所以大家只用看一排就行了。 是不是棒棒的？时频分析结果到手。但是STFT依然有缺陷。 使用STFT存在一个问题，我们应该用多宽的窗函数？ 窗口太窄：窗内的信号太短，会导致频率分析不够精准，频率分辨率差。 窗口太宽：时域上又不够精细，时间分辨率低。 这里使用窗口为一个高斯函数的形式w(t)=e^{-a*t^2/2},a为窗口的长度，t为时间。 窄窗口 中窗口 宽窗口 用窄窗，时频图在时间轴上分辨率很高，几个峰基本成矩形，而用宽窗则变成了绵延的矮山。但是频率轴上，窄窗明显不如下边两个宽窗精确。 对于时变的非稳态信号，高频适合小窗口，低频适合大窗口。然而STFT的窗口是固定的，在一次STFT中宽度不会变化，所以STFT还是无法满足非稳态信号变化的频率的需求。 小波级数展开与小波变换 STFT是给信号加窗，分段做FFT；而小波直接把傅里叶变换的基给换了——将无限长的三角函数基换成了有限长的会衰减的小波基。这样不仅能够获取频率，还可以定位到时间了。 小波是指能量有限，在时域中是有限长的，会衰减的，较为集中的波函数。小波级数展开就是使用一组小波函数作为基函数进行的级数展开。 再复习一下傅里叶级数和傅里叶变换。 对于连续性周期信号，使用基函数 E=\\{e^{ikωt}\\},k\\in N进行傅里叶级数展开。 \r f(t)=\\sum_{k=-\\infty}^{\\infty}A_{k}\\bullet e^{ikωt},\\quad A_k=\\frac{1}{T} \\int_{-\\frac{T}{2}}^{\\frac{T}{2}}f(t) e^{-ik\\omega t} dt\\tag{1}\r 对于连续性非周期信号(自然信号)，使用傅里叶变换进行频域分析。 \r F(\\omega)=\\int_{-\\infty}^{\\infty}f(t) e^{-i \\omega t} dt,\\quad f(t)=\\frac{1}{2\\pi}\\int^{\\infty}_{-\\infty}F(\\omega)e^{i \\omega t}d\\omega\\tag{2}\r 对于离散性非周期信号(采样的自然信号)，使用离散傅里叶变换进行频域分析。 \r \\begin{aligned}\r F_{s}(\\omega_{1}+k\\Delta\\omega)=\\frac{T}{N}\\sum_{n=0}^{N-1}f(t_{1}+n\\Delta t) e^{-i(\\omega_{1}+k\\Delta\\omega) (t_{1}+n\\Delta t)}\\\\\r f(t_{1}+n\\Delta t)=\\frac{\\Omega}{2\\pi K}\\sum^{K-1}_{k=0}{F(\\omega_{1}+k\\Delta\\omega)e^{i(\\omega_{1}+k\\Delta\\omega)(t_{1}+n\\Delta t)}}\\tag{3}\r \\end{aligned}\r 对于连续的信号，以\\varphi(\\frac{t-\\tau}{a})为基函数的小波变换公式为： \r WT(a,\\tau)=\\frac{1}{\\sqrt{a}}\\int^{\\infty}_{-\\infty}{f(t)*\\varphi(\\frac{t-\\color{red}{\\tau}}{\\color{red}{a}})dt}\\tag{4}\r 对于离散的信号，以\\varphi(2^{j}t-k)为基函数，进行小波级数展开： \r f(t) = \\sum_{j\\in N}\\left\\lbrace\\sum_{k\\in Z} c_{k}\\varphi(2^{j}t-k)\\right\\rbrace,\\text{here}\\;c_{k}\\in R\\tag{5}\r 注意二者的小波基函数\\varphi(2^{j}t-k)或者\\varphi(\\frac{t-\\tau}{a})，本质是一样的。 a=2^{-j}，以及j都起到缩放函数的作用，因此都是尺度因子，对应于傅里叶变换中的\\omega的倒数(周期T)。 \\tau=2^{-j}k，以及k是平移因子。 事实上，给了我们公式(5)，并不能用于信号处理的实践应用，你需要看小波变换(二): 小波基函数,母小波和父小波。 接下来你可能想看： 小波变换(二): 小波基函数,母小波和父小波 参考内容 形象易懂讲解算法I-小波变换 《The Wavelet Tutorial》小波教程 中文翻译（上） python实现小波变换的一个简单例子 小波变换和motion信号处理（一） 小波变换和motion信号处理：第二篇 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-02-10 20:44:13 "},"Hardware/2_SigCirSys/SigProc/wavelet2.html":{"url":"Hardware/2_SigCirSys/SigProc/wavelet2.html","title":"小波变换(二): 小波基函数,母小波和父小波","keywords":"","body":"小波变换(二): 小波基函数,母小波和父小波 系列文章列表 本文是《小波变换》系列的第2篇，主要介绍为什么需要小波. 小波变换(一): 为什么需要小波? 小波变换(二): 小波基函数,母小波和父小波 小波变换(三): 从实例代码看Haar小波分解和重构 小波变换(四): 常用小波特点及二维小波变换 小波变换(五): 小波，傅里叶与卷积的关系 小波级数展开与小波变换 上节我们给出了为啥需要小波变换，并给出了小波基函数，小波变换和小波级数的一般形式： 对于连续的信号，以\\varphi(\\frac{t-\\tau}{a})为基函数的小波变换公式为： \r WT(a,\\tau)=\\frac{1}{\\sqrt{a}}\\int^{\\infty}_{-\\infty}{f(t)\\varphi(\\frac{t-\\color{red}{\\tau}}{\\color{red}{a}})dt}\\tag{1}\r 对于离散的信号，以\\varphi(2^{j}t-k)为基函数，进行小波级数展开： \r f(t) = \\sum_{k\\in Z} c_{k}\\varphi(2^{j}t-k),\\text{here}\\;c_{k}\\in R\\tag{2}\r 注意二者的小波基函数\\varphi(2^{j}t-k)或者\\varphi(\\frac{t-\\tau}{a})，本质是一样的。 a=2^{-j}，以及j都起到缩放函数的作用，因此都是尺度因子，对应于傅里叶变换中的\\omega的倒数(周期T)。 \\tau=2^{-j}k，以及k是平移因子。 已经了解了小波基函数的一般形式，那么其他各种网站，资料，论坛里说的母小波和父小波都是什么东西? 母小波的理解 下面以Haar小波为例，详细理解一下小波级数展开的过程，并介绍一下什么是母小波，什么是父小波。 以下是被好多好多人选择的小波：Haar小波。Haar函数(先记一下，其实Haar小波级数展开的母小波)为： \r \\varphi(t)=\r \\begin{cases}\r 1 &0 \\leq t Haar的时域和频域信号 Haar函数在时域上不连续，性能一般，但胜在计算简单。 如果对其向右平移任意k个单位(k\\in Z)，构成一组函数E=\\{\\varphi(t-k)\\}, 该组函数两两相互正交，易证明 \r \\begin{aligned}\r \\langle\\varphi(t-k),\\varphi(t-k)\\rangle &=\\int^{\\infty}_{-\\infty}\\varphi^{2}(t-k)dt=1\\\\\r \\langle\\varphi(t-k),\\varphi(t-k')\\rangle &\\xlongequal[k,k'\\in Z]{k\\ne k'}\\int^{\\infty}_{-\\infty}\\varphi(t-k\\varphi(t-k')dt=0\r \\end{aligned}\r 因此构成一组正交基，这组正交基的线性组合形成函数空间V_0。 此时如果将\\{\\varphi(t-k)\\}的宽度缩小一半，同时保持缩放前后函数的总能量不变，则形成一组基函数E=\\{\\sqrt{2}\\varphi(2t-k)\\}，同样易证明这是另一组正交基,这组正交基的线性组合形成函数空间V_1。 不断缩小尺度，可形成一组基函数E=\\{\\sqrt{2^{j}}\\varphi(2^{j}t-k)\\},s.t.\\,j\\in Z,这组正交基的线性组合形成函数空间V_j。 在Haar小波变换中，所使用的基函数是V_j空间中的基函数(去除了2^j的系数)： \r \\varphi(2^{j}t-k)\\tag{4}\r V_j空间中的任意函数可以写作(c_j中已经包含了2^{j}，此式等同于式(2))： \r f_{j}(t) = \\sum_{k} c_{k}\\varphi(2^{j}t-k), \\text{here}\\;c_{k}\\in R\\tag{5}\r 现在，我们可以用这个阶梯状的函数去近似任意的原始的时域信号啦，不信你看！ 注意，我们现在从式(3)的\\varphi(t)，经过一步步的缩放，平移形成了很多组基函数，这些基函数可以表达函数空间V_{j}的任意函数。再形象一些，空间V_{j}的任意函数都可以用变形过的\\varphi(t)组合得到，因此，\\varphi(t)就被定义为母小波。 把母小波进行缩放，平移，可以构造出小波基函数。 好了，到这儿应该都没什么问题，那既然母小波已经完全可以表示V_{j}空间中的任意函数f_{j}，为啥还要搞出来一个父小波来pullze me? 接着往下看！ 父小波的理解 在实际的信号处理实践中，使用公式(2)是比较难以操作的。例如，以下图的信号为例，高频的毛刺是我们不需要的，要滤除的。 原始信号中的噪声 haar小波基函数的j越大，信号宽度越小，越接近噪声成分。因此，为了滤除噪声，需要很高的时间分辨率。但在低频部分，需要不太高的时间分辨率，j要小一些。 因此我们需要一种属于V_j但不属于V_{j-1}的尖峰函数，以匹配原始时域信号中的毛刺。 通过观察得到，函数空间V_0的任意基函数\\varphi(t-k)可以被空间V_1中的基函数线性组合得到(如下图(a))，因此V_0是V_1的子空间。以此类推，容易得到 \r \\varphi(2^{j}t)+\\varphi(2^{j}t-1)=\\varphi(2^{j-1}t)\\tag{6}\r 于是V_{j-1}也是V_{j}的子空间。那么就有V_0\\subseteq V_1\\subseteq\\cdots\\subseteq V_j。 如果定义如上图(b)所示的\\psi(t)，则\\psi(t)是V_{1}空间中的一个函数： \\psi(t)=\\varphi(2t)-\\varphi(2t-1)\\tag{7} 容易发现，对于V_{0}空间的任意的基函数\\varphi(t-k)，都有\\langle \\varphi(t-k),\\psi(t)\\rangle=0。事实上，对\\psi(t)平移k个单位后得到的函数\\psi(t-k)=\\varphi[2(t-k)]-\\varphi[2(t-k)-1]，都与V_{0}空间正交。函数\\psi(t-k)的线性组合也都与V_{0}空间正交。 进一步地，V_{j}空间中的函数 \\psi[2^{j-1}(t-k)] = \\varphi[2^{j}(t-k)]-\\varphi[2^{j}(t-k)-1]\\tag{8} 与V_{j-1}空间的所有函数均正交。以公式(8)中函数的线性组合，形成的空间W_{j}，是V_{j}的子集。 当j很大时，空间W_{j}表示的尖峰就与信号中的噪声十分相似了，为了滤掉噪声，可以把W_{j}中的项设为0。 接下来证明V_{j}空间是V_{j-1}空间与W_{j-1}空间的直和(如果V_{j}中的元素不属于V_{j-1}，就一定属于W_{j-1})。 令式(8)中k=0，并联立式(6)，容易得到 \r \\begin{aligned}\r \\varphi(2^{j}t)&=\\frac{1}{2}\\left( \\psi(2^{j-1}t)+ \\varphi(2^{j-1}t) \\right)\\\\\r \\varphi(2^{j}t-1)&=\\frac{1}{2}\\left( \\psi(2^{j-1}t)- \\varphi(2^{j-1}t) \\right)\r \\end{aligned}\r 因此有 \r \\begin{aligned}\r f_{j}(t)&=\\sum_{k \\in Z} c_{k}\\varphi(2^{j}t-k)\\\\\r &=\\begin{matrix}\\underbrace{\\sum_{k \\in Z}c_{2k}\\varphi[2^{j}(t-k)]}\\\\\\text{even}\\end{matrix}+\\begin{matrix}\\underbrace{\\sum_{k \\in Z}c_{2k+1}\\varphi[2^{j}(t-k)-1]}\\\\\\text{odd}\\end{matrix}\\\\\r &=\\frac{1}{2}\\left\\lbrace\\sum_{k \\in Z}c_{2k} \\left[ \\psi(2^{j-1}(t-k))+ \\varphi(2^{j-1}(t-k)) \\right] \\right.\\\\\r &\\quad\\quad +\\left.\\sum_{k \\in Z}c_{2k+1}\\left[ \\psi(2^{j-1}(t-k))- \\varphi(2^{j-1}(t-k)) \\right]\\right\\rbrace\\\\\r &=\\left\\lbrace\\sum_{k \\in Z}\\frac{c_{2k}+c_{2k+1}}{2} \\left[ \\psi(2^{j-1}(t-k))\\right] \\right.\\\\\r &\\quad +\\left.\\sum_{k \\in Z}\\frac{c_{2k}-c_{2k+1}}{2}\\left[ \\varphi(2^{j-1}(t-k)) \\right]\\right\\rbrace\\\\\r &=w_{j-1}+f_{j-1}\r \\end{aligned}\r 因此，容易得到 \r f_{j}(t)=w_{j-1}+f_{j-1}=w_{j-1}+w_{j-2}+w_{j-3}+\\cdots+w_{0}+f_{0}\\tag{9}\r 这表示V_{j}中的任意函数，可以写作W_{j}中的函数和V_{j-1}中函数的线性组合。因此W_{j-1}是V_{j-1}的正交补：W_{j-1}与V_{j-1}相互正交，且互为补集。 \r \\begin{aligned}\r V_{j}&=W_{j-1}\\bigoplus V_{j-1}\\\\\r &=W_{j-1} \\bigoplus W_{j-2} \\bigoplus V_{j-2}\\\\\r &=W_{j-1} \\bigoplus W_{j-2} \\bigoplus \\cdots \\bigoplus W_{0} \\bigoplus V_{0}\r \\end{aligned}\\tag{10}\r 公式(10)意思就是：如果使用公式(2)进行信号近似，本质上是使用\\varphi(t)和不同尺度的\\psi(t)进行近似，也就是使用阶梯和毛刺近似了任意信号f(t)。根据公式(9)，有 \r \\begin{aligned}\r f(t) &\\approx f_{j}(t)\\\\\r &=\\left\\lbrace w_{j-1}+w_{j-2}+\\cdots+w_{0}+f_{0}\\right\\rbrace\\\\\r &=\\sum_{j=1}^{\\infty}\\sum_{k\\in Z}c_{j,k}\\psi[2^{j-1}(t-k)] + \\sum_{k\\in Z}d_{k}\\varphi(t-k)\r \\end{aligned}\\tag{11}\r 看到了吗，任意一个函数f(t)，可以用\\psi经过一系列缩放、平移形成的函数，和\\varphi(t)经过平移形成的函数的线性组合来表达。 也就是说，这里我们只把母小波进行平移，把父小波进行缩放、平移，组合可以得到任意函数。 相信你已经理解父小波为什么还叫做尺度函数(scaling function)了吧！ 为了强化记忆，我们把公式(11)抄写一遍： \r f(t) =\\sum_{j\\in N}\\sum_{k\\in Z}c_{j,k}\\psi[2^{j}(t-k)] + \\sum_{k\\in Z}d_{k}\\varphi(t-k)\\tag{12}\r 事实上，在实践过程中，我们用的更多的是公式(12)而不是公式(2)。首先将信号转换为小波分量，要滤除j对应的毛刺信号，需要将j对应的分量置为0.然后进行小波反变换，转换为时域信号。 小结 小波分解： \r f(t) =\\sum_{j\\in N}\\left\\lbrace\\sum_{i=1}^{j}\\psi[2^{i-1}(t-k)]\\right\\rbrace+\\sum_{j\\in N}\\varphi(t-k)\r 母小波\\varphi(t)一般具有以下性质： 平移正交性：函数自身与平移后的函数相互正交，\\langle \\varphi(t),\\varphi(t-kT)\\rangle =0； 归一化：能量为1，\\langle \\varphi(t),\\varphi(t) \\rangle =\\int^{\\infty}_{-\\infty}\\varphi^{2}(t)dt= 1。 父小波\\psi(t)一般具有以下性质： 平移正交性：函数自身与平移后的函数相互正交，\\langle \\psi(t),\\psi(t-kT)\\rangle =0； 归一化：能量为1，\\langle \\psi(t),\\psi(t) \\rangle =\\int^{\\infty}_{-\\infty}\\psi^{2}(t)dt= 1。 与母小波\\varphi(t)正交。 留个问题：父小波是不是可以和母小波互换呢? 接下来你可能想看： 小波变换(三): 从实例代码看Haar小波分解和重构 参考内容 形象易懂讲解算法I-小波变换 《The Wavelet Tutorial》小波教程 中文翻译（上） python实现小波变换的一个简单例子 小波变换和motion信号处理（一） 小波变换和motion信号处理：第二篇 MathJax.Hub.Config({ TeX: { extensions: [\"extpfeil.js\"] }}); 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-02-11 09:08:05 "},"Hardware/2_SigCirSys/SigProc/wavelet3.html":{"url":"Hardware/2_SigCirSys/SigProc/wavelet3.html","title":"小波变换(三): 从实例代码看Haar小波分解和重构","keywords":"","body":"小波变换(三): 从实例代码看Haar小波分解和重构 系列文章列表 本文是《小波变换》系列的第3篇，主要介绍Haar小波的分解与重构,并给出Python代码实例. 小波变换(一): 为什么需要小波? 小波变换(二): 小波基函数,母小波和父小波 小波变换(三): 从实例代码看Haar小波分解和重构 小波变换(四): 常用小波特点及二维小波变换 小波变换(五): 小波，傅里叶与卷积的关系 小波分解与重构 上一节，我们介绍了父小波和母小波的概念。以及如何将f(t)表示为父小波和母小波的组合，这就是小波分解。 我们把信号 \r f(t) = \\sum_{k\\in Z} b_{k}\\varphi(2^{j}t-k),\\text{here}\\;c_{k}\\in R\\tag{1}\r 进行了小波分解，得到： \r f(t) =\\sum_{j=1}^{\\infty}\\sum_{k\\in Z}c_{j,k}\\psi[2^{j-1}(t-k)] + \\sum_{k\\in Z}d_{k}\\varphi(t-k)\\tag{2}\r 那么在去除V_{j}中的分量之后，需要将小波分量重新表示成式(1)的形式。这就是小波重构。 小波重构是已知(2)中的c_{j,k}和d_{k}，求(1)中b_{k}的过程。 由上节中式(8)可知 \\psi[2^{j-1}(t-k)] = \\varphi[2^{j}(t-k)]-\\varphi[2^{j}(t-k)-1] 代入(2)式后即可重构出小波。 可能看得绕了，没关系，看个例子放松下~ Haar小波实例 怎样计算得到小波分量值? 继续以Haar小波为例，图(a)中\\varphi(t)作为母小波，图(b)中\\psi(t)作为父小波。 根据上面式(2)，我们先用向量表示出\\psi[2^{j}(t-k)]和\\varphi(t-k)这些基函数。 首先，如果用V_{j=1}去近似原始的时域信号，暂时不考虑母小波平移变换得到的基函数，则基函数有且仅有母小波\\varphi和父小波\\psi(t)，基函数数目为N=2^{j}=2，两个基函数可以表示为如下形式： \r N=2,H=\\frac{1}{\\sqrt{2}}\\left[\\begin{matrix}1 & 1\\\\1 & -1\\end{matrix}\\right]\r 其中，矩阵H的两个行向量分别表示母小波\\varphi和父小波\\psi(t)。 进一步地，如果使用V_{j=2}去近似原始的时域信号，同样不考虑母小波平移变换得到的基函数，则基函数除了母小波\\varphi和父小波\\psi(t)，还有对父小波的缩放产生的基函数，基函数数目为N=2^{j}=4，4个基函数可以表示为如下形式： \r N=4,H=\\left[\\begin{matrix}\\frac{1}{2} & \\frac{1}{2} & \\frac{1}{2} & \\frac{1}{2}\\\\\\frac{1}{2} & \\frac{1}{2} & -\\frac{1}{2} & -\\frac{1}{2}\\\\\\frac{1}{\\sqrt{2}} & -\\frac{1}{\\sqrt{2}} & 0 & 0\\\\0 & 0 & \\frac{1}{\\sqrt{2}} & -\\frac{1}{\\sqrt{2}}\\end{matrix}\\right]\r 进一步的，有 \r N=8,H=\\left[\\begin{matrix}\\frac{1}{2\\sqrt{2}} & \\frac{1}{2\\sqrt{2}} & \\frac{1}{2\\sqrt{2}} & \\frac{1}{2\\sqrt{2}} & \\frac{1}{2\\sqrt{2}} & \\frac{1}{2\\sqrt{2}} & \\frac{1}{2\\sqrt{2}} & \\frac{1}{2\\sqrt{2}}\\\\\\frac{1}{2\\sqrt{2}} & \\frac{1}{2\\sqrt{2}} & \\frac{1}{2\\sqrt{2}} & \\frac{1}{2\\sqrt{2}} & -\\frac{1}{2\\sqrt{2}} & -\\frac{1}{2\\sqrt{2}} & -\\frac{1}{2\\sqrt{2}} & -\\frac{1}{2\\sqrt{2}}\\\\\\frac{1}{2} & \\frac{1}{2} & -\\frac{1}{2} & -\\frac{1}{2} & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & \\frac{1}{2} & \\frac{1}{2} & -\\frac{1}{2} & -\\frac{1}{2}\\\\\\frac{1}{\\sqrt{2}} & -\\frac{1}{\\sqrt{2}} & 0 & 0 & 0 & 0 & 0 & 0\\\\0 & 0 & \\frac{1}{\\sqrt{2}} & -\\frac{1}{\\sqrt{2}} & 0 & 0 & 0 & 0\\\\0 & 0 & 0 & 0 & \\frac{1}{\\sqrt{2}} & -\\frac{1}{\\sqrt{2}} & 0 & 0\\\\0 & 0 & 0 & 0 & 0 & 0 & \\frac{1}{\\sqrt{2}} & -\\frac{1}{\\sqrt{2}}\\end{matrix}\\right]\r 上述矩阵叫做哈尔变换矩阵。在每个矩阵中： 任取两个行向量来进行内积的运算，所得到的内积皆为零，表示相互正交。 每个行向量的模长为1，表示能量归一化。 因此，把信号f(t)写成一个列向量\\vec{x}，则式(2)中各基函数的分量值 \r \\vec{c}=H\\vec{x}\r 理论上讲，我们直接用最复杂的基进行分解，能够一次性地得到各小波基函数上的分量。但是再复杂的基都没有信号长度长呀~ 于是，聪明的人类想到了一种办法，用最简单的基，多次分解! 注意到，对于最简单的Haar基，H的行数也就是基函数的个数N=2，几乎肯定小于向量\\vec{x}的行数，也就是信号长度L。但考虑到，我们的基函数还不包括平移得到的一部分基函数，所以我们可以对H中的每个行向量H_{i}平移得到平移后的基函数，连同原本H中的基函数H_{i}，共有L个基函数，就覆盖了整个信号的长度，于是有： \r \\left(\\begin{matrix}c_{1}\\\\c_{2}\\\\\\vdots\\\\c_{L}\\end{matrix}\\right)=\\begin{matrix}&2*L/2\\;\\text{cols}&\\\\L\\;\\text{rows}&\\left\\lbrace\\overbrace{\\left(\\begin{matrix}H_{1} & 0 &\\cdots &0\\\\0 &H_{1} &\\cdots &0\\\\\\vdots &\\vdots &\\ddots &\\vdots\\\\0 &0 &\\cdots &H_{1}\\\\H_{2} & 0 &\\cdots &0\\\\0 &H_{2} &\\cdots &0\\\\\\vdots &\\vdots &\\ddots &\\vdots\\\\0 &0 &\\cdots &H_{2}\\end{matrix}\\right)}\\right.\\end{matrix}\\vec{x}\\tag{3}\r 这就得到了信号f(t)在各个基函数的分量值。 Haar小波分解与重构算法 回过头来，再看最简单的Haar变换矩阵H，可以看到第一个基函数是母小波，因此使用式(3)实现了对信号的平均，得到了低频分量；第二个基函数是父小波，使用式(3)则相应地获得了高频分量。如果对低频分量中的小波系数进一步使用式(3)进行分解，就可以得到更低频的分量，以及次高频的分量。多次分解之后，我们得到了一个系数向量： \r \\vec{c}=\\left[\\cdots\\left[\\left[\\left[V_{0}\\right],W_{0}\\right],W_{1}\\right],\\cdots,W_{n}\\right]^{T}\\tag{4}\r 看到式(4)，再把式(2)拿过来看看，是不是对上了! \r f(t) =\\sum_{j=1}^{\\infty}\\sum_{k\\in Z}c_{j,k}\\psi[2^{j-1}(t-k)] + \\sum_{k\\in Z}d_{k}\\varphi(t-k)\\tag{2}\r 于是，当当当当，我们的小波变换算法已经成型啦： 采用最简单的Haar基(N=2,H=\\frac{1}{\\sqrt{2}}\\left[\\begin{matrix}1 & 1\\\\1 & -1\\end{matrix}\\right])； 对长度为L的信号x(t)执行公式(3)，进行小波变换，得到长度为L的小波系数向量\\vec{c}，覆盖写回x(t)，设置变量n=1； 将x(t)中小波系数向量\\vec{c}分为2^n份； 从x(t)中最左侧取出长度为L/2^n的一小段，执行公式(3)进行小波变换，得到长度为L/2^n的小波系数向量\\vec{c}，覆盖写回x(t)原位置(最左侧)； n=n+1； L/2^n小于N=2时停止，否则重复步骤3，步骤4和步骤5； 那么，再进一步，怎么实现滤波呢? 如果把最终的小波系数向量\\vec{c}中绝对值较小的系数删除掉，则去除了低能量的信号，例如噪声。如果把\\vec{c}尾部的一小段去掉，则去除了高频分量，例如噪声。 滤波之后怎么重构呢? 设置n=1； 从x(t)中最左侧取出长度为2^n的第一份，乘以小波逆变换的变换矩阵(就是式(3)中矩阵的转置,还是它自身)，得到长度为L/2^n的小波系数向量\\vec{c}，覆盖写回x(t)第一份的位置，也就是原位置； n=n+1； 2^n大于L时停止，否则重复步骤9，步骤10； 对应的Python代码为： import math class wave: def __init__(self): M_SQRT1_2 = math.sqrt(0.5) self.h1 = [M_SQRT1_2, M_SQRT1_2] self.g1 = [M_SQRT1_2, -M_SQRT1_2] self.h2 = [M_SQRT1_2, M_SQRT1_2] self.g2 = [M_SQRT1_2, -M_SQRT1_2] # 小波基函数的个数为2 self.nc = 2 self.offset = 0 def __del__(self): return class Wavelet: def __init__(self, n): self._haar_centered_Init() self._scratch = [] for i in range(0, n): self._scratch.append(0.0) return def __del__(self): return def transform_inverse(self, list, stride): self._wavelet_transform(list, stride, -1) return def transform_forward(self, list, stride): self._wavelet_transform(list, stride, 1) return def _haarInit(self): self._wave = wave() self._wave.offset = 0 return def _haar_centered_Init(self): self._wave = wave() self._wave.offset = 1 return def _wavelet_transform(self, list, stride, dir): n = len(list) if (len(self._scratch) = 2): self._step(list, stride, i, dir) i = i >> 1 if (dir == -1): # 逆变换 i = 2 while (i 1e-6): return False else: return True def _step(self, list, stride, n, dir): for i in range(0, len(self._scratch)): self._scratch[i] = 0.0 nmod = self._wave.nc * n nmod -= self._wave.offset n1 = n - 1 nh = n >> 1 if (dir == 1): # 正变换 ii = 0 i = 0 while (i 测试代码为： import numpy as np import matplotlib.pyplot as plt import os, inspect import math def main(): currentdir = os.path.dirname( os.path.abspath(inspect.getfile(inspect.currentframe()))) parentdir = os.path.dirname(currentdir) os.sys.path.insert(0, parentdir) from res.WaveletTrans import Wavelet waveletn = 256 wavelettest = Wavelet(waveletn) t = np.linspace(0, 255, 256) waveletorigindata = np.sin(t) * np.exp(-((t - 100) / 50)**2) + 1 filterFlag = 0 # 滤波方式: 1-按能量滤波; 0-按频率滤波 if (filterFlag): # 按能量大小进行滤波，滤掉将能量较小的分量 # 将小波系数进行降序排列(升序取反) plt.figure(figsize=(12, 10)) for k in range(4): waveletdata = np.sin(t) * np.exp(-((t - 100) / 50)**2) + 1 wavelettest.transform_forward(waveletdata, 1) # 执行小波变换 waveletnc = 20 * (2**k) # 按能量滤波时，保留的分量数 newdata = sorted(waveletdata, key=lambda ele: abs(ele), reverse=True) for i in range(waveletnc, waveletn): # 将能量较小的分量直接置0，删除啦 for j in range(0, waveletn): if (abs(newdata[i] - waveletdata[j]) len(waveletdata) * hFreq[k] ] waveletdata[omg] = 0 wavelettest.transform_inverse(waveletdata, 1) waveleterr = 0.0 for i in range(0, waveletn): waveleterr += abs(waveletorigindata[i] - waveletdata[i]) / abs( waveletorigindata[i]) ax = plt.subplot(2, 2, k + 1) plt.plot(waveletorigindata, color='blue', linestyle='-', label='$f$') plt.plot(waveletdata, color='red', linestyle='-', label=\"$f'$\") ax.set_xlabel('$t(s)$') ax.set_ylabel('$f(V)$') ax.legend(loc='upper right') ax.set_title( \"BandPass[{:.2f},{:.2f}],relative error:{:.3f}\".format( lFreq[k], hFreq[k], waveleterr / waveletn)) plt.show() if __name__ == \"__main__\": main() 测试结果: 按能量滤波时： 按频率滤波时(带通)： 接下来你可能想看： 小波变换(四): 常用小波函数及二维小波变换 参考内容 形象易懂讲解算法I-小波变换 《The Wavelet Tutorial》小波教程 中文翻译（上） python实现小波变换的一个简单例子 小波变换和motion信号处理（一） 小波变换和motion信号处理：第二篇 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-02-10 20:44:05 "},"Hardware/2_SigCirSys/SigProc/wavelet4.html":{"url":"Hardware/2_SigCirSys/SigProc/wavelet4.html","title":"小波变换(四): 常用小波特点及二维小波变换","keywords":"","body":"小波变换(四): 常用小波特点及二维小波变换 系列文章列表 前面三篇我们系统学习了小波变换的基础理论和Haar滤波的方法。那么本文是《小波变换》系列的第4篇，主要介绍常用小波特点及二维小波变换. 小波变换(一): 为什么需要小波? 小波变换(二): 小波基函数,母小波和父小波 小波变换(三): 从实例代码看Haar小波分解和重构 小波变换(四): 常用小波特点及二维小波变换 小波变换(五): 小波，傅里叶与卷积的关系 常用的小波基函数 母小波 正交性 父小波(尺度函数) 图解 Haar \\varphi(t)=\\begin{cases}1 &0 \\leq t 有 \\psi(t)=\\begin{cases}1 &0 \\leq t db4 无 无 无 无 Mexh墨西哥帽 \\varphi(t)=(1-t^{2})e^{t^2/2} 无 无 Morlet \\varphi(t)=Ce^{t^2/2}\\cos{(5t)} 无 无 Meyer 无 无 无 二维小波变换 二维哈尔小波变换是将一个由8*8元素组成的图像块的矩阵，进行小波变换时，对矩阵中的每一行进行行变换，然后对行变换后的矩阵每一列进行列变换，最终得到小波系数矩阵。 接下来你可能想看： 小波变换(五): 小波，傅里叶与卷积的关系 参考内容 形象易懂讲解算法I-小波变换 《The Wavelet Tutorial》小波教程 中文翻译（上） python实现小波变换的一个简单例子 小波变换和motion信号处理（一） 小波变换和motion信号处理：第二篇 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-02-10 20:44:04 "},"Hardware/2_SigCirSys/SigProc/wavelet5.html":{"url":"Hardware/2_SigCirSys/SigProc/wavelet5.html","title":"小波变换(五): 小波变换与卷积","keywords":"","body":"小波变换(五): 小波变换与卷积 系列文章列表 本文是《小波变换》系列的第5篇，主要分析小波变换和卷积的关系。 小波变换(一): 为什么需要小波? 小波变换(二): 小波基函数,母小波和父小波 小波变换(三): 从实例代码看Haar小波分解和重构 小波变换(四): 常用小波特点及二维小波变换 小波变换(五): 小波，傅里叶与卷积的关系 傅里叶滤波和小波滤波的区别是什么? 其实这个问题在小波变换(一): 为什么需要小波?中已经回答过了。 通常意义下的Fourier Transform（我们这里不考虑比如Short-time Fourier Transform之类的局部变化）是一个全局的变换，而可以把小波变换理解成是一个局部的频率变换。那么为什么说Wavelet通常会比Fourier在modeling一些自然信号时候更有优势（更好的稀疏化信号）呢？举个栗子，我们都知道一段全局smooth的信号（比如一条直线），是可以在Fourier Transform里面被稀疏化的。而这类信号经常出现在自然图像里面，比如edge一类的texture。然而如果这条线突然变成了两段，比如中间出现转折，或者断了，对于Fourier来说，他的稀疏性就降低了。这类现象也是经常出现在自然图片里面的。然而Wavelet只是分析局部的频率，他的可稀疏化信号，只需要piece-wise smooth就行了。这大大地扩宽了在自然信号里的普适性，从而使得他在降噪应用里效果拔群。 小波与卷积 小波基函数(能量有限，时间长度有限)本质上就是一个卷积(滤波器)窗口。原始时域信号与小波基函数的内积，代表了信号在该小波基函数方向的分量大小，也就是原始时域信号与滑窗的卷积。因此，小波级数与卷积一样，都是把原始信号分解到一系列的窗函数上。 一维小波基函数对应于变换矩阵的向量，就是一个一维的卷积滑窗。二维小波基函数对应的张量，就是一个二维的卷积滑窗。 恭喜你解锁了小波变换彩蛋: Python中的小波变换库。 参考内容 形象易懂讲解算法I-小波变换 《The Wavelet Tutorial》小波教程 中文翻译（上） python实现小波变换的一个简单例子 小波变换和motion信号处理（一） 小波变换和motion信号处理：第二篇 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-02-10 20:46:38 "},"Hardware/2_SigCirSys/SigProc/wavelet6.html":{"url":"Hardware/2_SigCirSys/SigProc/wavelet6.html","title":"小波变换彩蛋: Python中的小波变换库","keywords":"","body":"小波变换彩蛋: Python中的小波变换库 系列文章列表 小波变换(一): 为什么需要小波? 小波变换(二): 小波基函数,母小波和父小波 小波变换(三): 从实例代码看Haar小波分解和重构 小波变换(四): 常用小波特点及二维小波变换 小波变换(五): 小波，傅里叶与卷积的关系 小波变换彩蛋: Python中的小波变换库。 pywt：Python 小波去噪 在python中使用小波分析进行阈值去噪声,使用pywt.threshold函数。 #coding=utf-8 #使用小波分析进行阈值去噪声,使用pywt.threshold import pywt import numpy as np import pandas as pd import matplotlib.pyplot as plt import math data = np.linspace(1, 10, 10) print(data) # [ 1. 2. 3. 4. 5. 6. 7. 8. 9. 10.] # pywt.threshold(data, value, mode, substitute) mode 模式有4种，soft, hard, greater, less; substitute是替换值 data_soft = pywt.threshold(data=data, value=6, mode='soft', substitute=12) print(data_soft) # [12. 12. 12. 12. 12. 0. 1. 2. 3. 4.] 将小于6 的值设置为12， 大于等于6 的值全部减去6 data_hard = pywt.threshold(data=data, value=6, mode='hard', substitute=12) print(data_hard) # [12. 12. 12. 12. 12. 6. 7. 8. 9. 10.] 将小于6 的值设置为12， 其余的值不变 data_greater = pywt.threshold(data, 6, 'greater', 12) print(data_greater) # [12. 12. 12. 12. 12. 6. 7. 8. 9. 10.] 将小于6 的值设置为12，大于等于阈值的值不变化 data_less = pywt.threshold(data, 6, 'less', 12) print(data_less) # [ 1. 2. 3. 4. 5. 6. 12. 12. 12. 12.] 将大于6 的值设置为12， 小于等于阈值的值不变 ECG小波去噪 import matplotlib.pyplot as plt import pywt # Get data: ecg = pywt.data.ecg() # 生成心电信号 index = [] data = [] for i in range(len(ecg)-1): X = float(i) Y = float(ecg[i]) index.append(X) data.append(Y) # Create wavelet object and define parameters w = pywt.Wavelet('db8') # 选用Daubechies8小波 maxlev = pywt.dwt_max_level(len(data), w.dec_len) print(\"maximum level is \" + str(maxlev)) threshold = 0.04 # Threshold for filtering # Decompose into wavelet components, to the level selected: coeffs = pywt.wavedec(data, 'db8', level=maxlev) # 将信号进行小波分解 plt.figure() for i in range(1, len(coeffs)): coeffs[i] = pywt.threshold(coeffs[i], threshold*max(coeffs[i])) # 将噪声滤波 datarec = pywt.waverec(coeffs, 'db8') # 将信号进行小波重构 mintime = 0 maxtime = mintime + len(data) + 1 plt.figure() plt.subplot(2, 1, 1) plt.plot(index[mintime:maxtime], data[mintime:maxtime]) plt.xlabel('time (s)') plt.ylabel('microvolts (uV)') plt.title(\"Raw signal\") plt.subplot(2, 1, 2) plt.plot(index[mintime:maxtime], datarec[mintime:maxtime-1]) plt.xlabel('time (s)') plt.ylabel('microvolts (uV)') plt.title(\"De-noised signal using wavelet techniques\") plt.tight_layout() plt.show() 运行结果如下： 参考内容 python小波变换去噪 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-02-10 20:50:42 "},"Hardware/3_AnalogCirciut/":{"url":"Hardware/3_AnalogCirciut/","title":"模拟电路基础","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Hardware/4_DigitalCircuit/":{"url":"Hardware/4_DigitalCircuit/","title":"数字电路基础","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Hardware/5_PCB/":{"url":"Hardware/5_PCB/","title":"PCB设计与应用","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Hardware/6_AnalogIC/":{"url":"Hardware/6_AnalogIC/","title":"模拟IC设计","keywords":"","body":"内容列表 回到主页 实例1入门实验反相器的设计与仿真 实例2_放大器的仿真 res 资源(右键打开或下载) 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Hardware/6_AnalogIC/1_Ex1.html":{"url":"Hardware/6_AnalogIC/1_Ex1.html","title":"实例1入门实验反相器的设计与仿真","keywords":"","body":"实例1入门实验反相器的设计与仿真 在学习本节之前,建议先学习电阻、电容等无源器件和半导体器件的相关知识. 准备工作 准备工艺库安装包 安装工艺库是面向工程的,你每新建一个工程目录,就需要重新安装工艺库. 复制SMIC 0.18um工艺库到Linux机器. # 在/opt/eda/ 下新建目录`smic18_pack` cd [安装包目录] mkdir /opt/eda/smic18_pack/ cp ./SMIC0.18库/* /opt/eda/smic18_pack/ # 其中smic18d是数字工艺库,smic18mmrf是模拟和射频工艺库 tar xvf smic18d.tar rm -rf smic18d.tar tar xvf smic18mmrf.tar rm -rf smic18mmrf.tar 启动软件: 首先在终端中创建工作目录,mkdir -p ~/WorkSpace/smic18mmrf,然后进入工作目录cd ~/WorkSpace, 输入 virtuoso&打开Cadence ADE, 其中&表示创建一个新的进程用于执行virtuoso而与当前终端的进程无父子关系. 否则关闭终端窗口时, virtuoso也会关闭. 会打开 Log: /home/[username]/CDS.log的命令窗口,叫做CIW(Command interpreter window). 安装工艺库: 在CIW窗口输入pwd查看当前工作目录,点击Tools>Conversion Toolbox>点CDB to OpenAccess Translator> 设置包括cds.lib文件的目录/opt/eda/smic18/smic18mmrf,然后点Apply,等待一段时间,会自动弹出Library Manager框,里面已经有了smic18mmrf库,可以查看里面的Cell电路单元。如果没有弹出，可以在CIW窗口点Tools>Library Manager查看. 如果失败,在CIW的Log窗口查看日志. 然后把/opt/eda/smic18_pack/中的models文件夹拷贝到WorkSpace目录,此文件夹中包括了工艺库模型信息,在后面仿真要用到. 注意, 这里的Cell是指电路,电路可以用很多种形式描述,例如原理图(Schematic),版图(Layout),Spice代码(Spice)等,每一种形式有着自己的一个视图(view) ,因此对于一个Cell,可以有很多View. 注意: CDB to OpenAccess将工艺库转换成smic18mmrf文件夹,会放在当前工作目录下. 在Library Manager>Edit>Library Path,可以看到当前工作目录下的cds.lib文件的内容: cdsDefTechLib $CDSHOME/tools/dfII/etc/cdsDefTechLib smic18mmrf ./smic18mmrf 再添加以下两行: basic $CDSHOME/tools/dfII/etc/cdslib/basic analogLib $CDSHOME/tools/dfII/etc/cdslib/artist/analogLib 然后File>Exit退出Library Path窗口. 实例-反相器 新建库： 首先使用终端打开工作目录~/WorkSpace, 输入virtuoso&打开Cadence ADE, CIW中File > New >Library. Name填写ADE_test,目录选择自己的工作空间/home/[你的用户名]/WorkSpace. 右侧Technology File选择Attach to an existing technology library, 点击Apply，在弹出的Attach to an existing technology library对话框中,选择smic18mmrf.然后回到New Library窗口点击OK,直接关闭该New Library窗口,在CIW的log中可以看到已经生成. 每次新开始一个项目,需要在工艺库的基础上,建立自己的电路元件库,例如这里我新建一个ADE_test库,用于设计模拟前端芯片中的电路单元. 开始画原理图:CIW窗口中 File > New > CellView, 选择库为ADE_test表示在其中新建电路, Cell是电路名,填写inv,View是视图的名称,填写Schematic，Type是视图类型,选择Schematic. 工具使用默认的Schematic Editor L即可. OK. 弹出电路图对话框. 在工作区右键,或使用快捷键I，插入电路实例。这里选择smic18mmrf中的 p18 和 n18，n18的Total Width设置为2u M,p18的Total Width设置为4u M,长度保持180n M不变,放置进去,按Shift+x键check and save. 继续使用I,选择analogLib库,插入vdd和gnda,然后使用快捷键p，插入输入和输出引脚。按Shift+x键check and save. 选择库一般只需选择工艺库smic18mmrf(实际库,可以在工艺库的安装包目录中找到./docs/PDK_ReferenceManual_018MMRF_1833.pdf查看详细信息)或analogLib库(包括理想元器件、电源、激励源、输入输出端口、接地符号等)。 得到下面电路图,注意要将pmos和nmos的基极也连上。 仿真电路图: 在Schematic Editor界面选择Launch>ADE L,启动ADE. Setup>Stimuli设置激励.然后按下图设置. Setup>Model library设置工艺库模型和工艺角.然后按下图设置. 工艺库模型用于插入工艺上的模型信息,因为实际使用时,芯片四角和中心的温度不同,器件的性能也不一样. 因此要设置 工艺角 , FF表示 Fast NMOS, Fast PMOS,速度较快, TT表示Typical NMOS和Typical PMOS,速度一般.而SS表示Slow NMOS和SLOW PMOS,速度较慢. Analyses>Choose设置仿真类型,选择trans进行瞬态仿真.按下图设置. 选择Output>To be Plotted>Select On Schematic命令,在电路图中单击反相器的输入和输出的连线,添加到Output的栏中. Stimulation>Netlist and Run,开始仿真. 仿真完成后直接弹出仿真波形图. 附 analogLib中的常用元件和电源 类型 Cell名称 类型 Cell名称 电阻 res 电源 vdd 电容 cap 地 gnd 电感 ind 直流电流源 idc 二极管 diode 脉冲电流源 ipulse 肖特基二极管 schottky 正弦电流源 isin npn三极管 npn 线性电流源 ipwl pnp三极管 pnp 直流电压源 vdc 四端口nmos nmos4 脉冲电压源 vpulse 四端口pmos pmos4 正弦电压源 vsin 理想开关 switch 任意波形信号源 vpwl 附 原理图设计中的快捷键 键 功能 键 功能 Shift+LeftClick 加选实例 C 拷贝 Ctrl+LeftClick 减选实例 M 移动 X 保存 S 检查并保存 Ctrl+A 全选 U 撤销1次 Ctrl+D 取消选择 Shift+U 继续撤销 F 显示完整电路 Ctrl+Z,] 放大视图 I 添加实例 Shift+Z,[ 缩小视图 W 添加连线 Esc 退出当前命令 P 添加引脚 L Net Label T 添加文本 B 添加Block Q 编辑属性 Del 删除器件 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-04 14:46:45 "},"Hardware/6_AnalogIC/2_Ex2.html":{"url":"Hardware/6_AnalogIC/2_Ex2.html","title":"实例2_放大器的仿真","keywords":"","body":"实例2_放大器的仿真 交流小信号仿真 本实例以简单放大器的交流小信号仿真为例，重点分析放大器的增益、相位与频率之间的关系。 原理图设计 基于上次的ADE_ex1库,新建一个Cell View，命名为amp; 按快捷键i,调用n33,按q设置其宽长比为1u/5u,调用p33,宽长比设置为1u/0.3u. 从analogLib中调用理想电容,设置电容值为1pF,按下图完成电气连接。 分析：PMOS的栅漏短接,于是 V_{SD}>V_{SG}-|V_{Tp}| , PMOS工作在放大区(饱和区),形成的导通电阻很小,交流小信号的电阻很小。这种电阻叫做 有源电阻 。 仿真设计 Launch >ADE L启动仿真器. 设置激励(Setup>Stimuli): 选择vin的激励项,Function选择为sin,Type选择为voltage,并设置直流偏置(DC voltage)为1.65V,交流幅值(AC magnitude)为1V, 交流相位(AC Phase)输入0。 设置模型库和工艺角; 设置仿真选项(Analyses>Choose):选择ac交流小信号仿真,start和stop分别输入频率扫描的起始(10)和终止频率(1G),扫描类型(Sweep Type)为自动(Automatic)。 开始仿真(Stimulation>Netlist and Run). 查看结果: Results>Direct Plot>Main Form,在弹出的对话框中选择dB20和Phase,然后单击原理图中vout的连线,可以看到如下如果. 瞬态仿真 在给定的输入激励下，在设定的时间范围内计算电路时域瞬态响应。 设置激励: 在上述原理图的基础上,在ADE L仿真器中,设置vin为正弦电压信号,直流偏置(DC Voltage)为1.65V，幅度(Amplitude)为1mV,频率(Frequency)为1M. 设置仿真选项(Analyses>Choose): 仿真类型为trans,设置仿真的终止时间Stop Time为10u,仿真精度默认方案Accuracy Default中选择最高精度conservative。 高精度conservative用于数模混合,ADC仿真等；适中精度moderate适合对一般模拟电路进行仿真; 宽松精度liberal则适合仿真数字电路或变化速度较低的模拟电路. 设置输出(Outputs>To be Plotted>Select On Schematic)在原理图中单击输入和输出的Net； 开始仿真: Stimulation>NetList and Run,在弹出的波形图中点击工具栏的Split All Strips按钮,可以将两个波形图分开.在波形图中按M添加Maker标记,可以查看某个点的值. 分析：输入信号的峰峰值为2mV,输出信号的峰峰值为3mV. 注意,在仿真精度中,可以选择Option设置自定义的精度. 直流仿真 直流工作点的设计: 选择仿真类型(Analyses>Choose)为dc，然后选中Save DC Operating Point保存电路的直流工作点。然后Stimulation>Netlist and Run开始仿真. 仿真完成后 Results>Print>DC Node Voltages点击原理图中的输出节点,测量其输出的直流电压. Results>Print>DC Operating Point点击原理图中的PMOS,可以看到其直流工作状态参数. Results>Annotate>DC Node Voltages在图中标注出直流电压。 直流特性扫描仿真: 在dc对话框中选择Save DC Operating Point保存电路的直流工作点。选择Temperature设置起始和终止温度为-40和125. Outputs>To Be Plotted>Select On Schematic单击放大器的输出.然后Stimulation>Netlist and Run开始仿真. 可以看到电压信号随着温度上升几乎线性增大。 噪声仿真 修改原理图: 将输入vin端口删除,从analogLib中调用port，设置直流偏置电压为1.65V； 设置仿真选项: (Analyses>Choose): 仿真类型为noise,扫描变量选择频率，起始和终止频率分别为1和1G，Output Noise中选择voltage，positive ouput node在原理图中点输出Net,negative则选择为gnd; Input Noise选择为port. 开始仿真: Stimulation>NetList and Run. 查看结果: Results>Direct Plot>Main Form,在弹出的对话框中选择Output noise,V/sqrt(Hz),Magnitude，然后点击Plot。可以看到噪声曲线. 低频时主要是1/f噪声,高频时主要是晶体管热噪声. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-03-29 11:30:02 "},"Hardware/7_DigitalIC/":{"url":"Hardware/7_DigitalIC/","title":"数字IC RTL设计","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Hardware/8_CPU/":{"url":"Hardware/8_CPU/","title":"CPU设计","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Hardware/9_SoC/":{"url":"Hardware/9_SoC/","title":"SoC设计","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Hardware/A_EDA/":{"url":"Hardware/A_EDA/","title":"EDA安装","keywords":"","body":"内容列表 回到主页 本教程包含了以下EDA工具的安装说明。 win10安装centos7双系统 CentOS 使用基础 Cadence工具安装I-模拟部分 Cadence工具安装II-数字部分 Synopsys工具安装II-数字前端 Synopsys工具安装II-数字后端 res 资源(右键打开或下载) CentOS安装IC618和calibre2019.pdf libstdc++.so.6.0.26 PingFangSC.zip SynopsysEDA安装教程.pdf wps_symbol_fonts.tar.gz 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Hardware/A_EDA/1_Introduction.html":{"url":"Hardware/A_EDA/1_Introduction.html","title":"本教程包含了以下EDA工具的安装说明。","keywords":"","body":"本教程包含了以下EDA工具的安装说明。 项 曾用名/全名 领域 说明 相应教程 virtuoso IC618 模拟 Cadence,电路设计/仿真软件 MMSIM15 Spectre 模拟 Cadence,模拟电路仿真 Incisive NC-verilog Simulator 数字 Cadence,数字电路仿真、验证 innovus encounter 数字 Cadence,布局布线 XCELIUM - 数字 Cadence,验证平台 Calibre - 模拟,数字 Mentor,LVS ModelSim - 数字 Mentor,数字电路仿真 HSpice - 模拟 Synopsys,器件模型仿真 Synplify Design Compiler(DC) 数字 Synopsys,前端综合 ICC IC Compiler 数字 Synopsys,布局布线 VCS - 数字 Synopsys,仿真工具 verdi - 数字 Synopsys,验证工具 starRC - 数字 Synopsys,提取寄生参数 PT Prime Time 数字 Synopsys,时序分析 Formality - 数字 Synopsys,后端形式验证 Power 数字 Synopsys,功耗分析 目录 简介 安装CentOS 了解CentOS 安装IC618,Spectre,Calibre 安装NC-verilog,Innovus 安装HiSpice,DC,VCS 安装ICC,PT,Formality 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-03-12 21:50:41 "},"Hardware/A_EDA/2_InstallCentOS.html":{"url":"Hardware/A_EDA/2_InstallCentOS.html","title":"win10安装centos7双系统","keywords":"","body":"win10安装centos7双系统 准备工作： 1.1 磁盘分区 * 右击此电脑>>管理>>磁盘管理>>找到要压缩的盘,这里F盘**剩余空间**较大,选择F盘>>右键压缩卷>>输入要压缩的空间大小,这里输入`102400`(MB)，也就是为CentOS创建100G的空间. * 耐心等待,直到压缩完成.别手贱再把分出来的空间在Windows里面“添加卷”，linux安装时，只认空白硬盘。 * 如果压缩卷过慢,你又着急的话，找一个文件少的盘符，把数据转移出去，然后直接格式化吧~ * 使用`DiskGenius`软件，将要安装Linux的目标硬盘的分区表类型修改为GPT，具体方法可以百度。 1.2 制作启动盘 * 国内下载源和版本选择：https://blog.csdn.net/xiaojin21cen/article/details/83713559 ，这里我是为了安装IC的EDA工具,因此下载了`CentOS-6.10-x86_64-bin-DVD1_2.iso`。 * 打开UltraISO(也叫软碟通)>>文件菜单>>打开>>选择刚下载好的ISO文件,会加载出几个文件夹>>选中在层次图的根部,也就是显示光盘图标的那个项上>>启动菜单>>写入硬盘映像>>硬盘驱动器选择U盘，写入方式改为USB-HDD+，隐藏自动分区改为无，格式化之后点击开始写入. * 耐心等待,直到刻录成功. 开始安装 笔记本bios设置U盘自启动 神舟笔记本开机后，按F2进入BIOS，设置第一个启动项为U盘，选择 带有U盘标志的启动选项,例如: UEFI: KingstonDataTraveler等; UEFI: SanDisk等; KingstonDataTraveler等; USB:Generic Flash Disk等 USB-HDD等. 在BIOS中设置SATA Controller Mode为AHCI模式; 设置启动选项为UEFI Only/Legacy. 关闭安全选项,等. 安装过程 电脑重启后，进入CentOS 7菜单选项，选中Install CentOS Linux 7，按e键进入编辑模式后，在屏幕的最下面会出现当前运行的脚本命令。 setparams 'Install CentOS Linux 7' linuxefi/images/pxeboot/vmlinuz inst.stage2=hd:LABEL=CentOS\\x207\\x20x86_64 quiet initrdefi/images/pxeboot/initrd.img 修改其中选中的部分为 setparams 'Install CentOS Linux 7' linuxefi/images/pxeboot/vmlinuz linux dd quiet initrdefi/images/pxeboot/initrd.img 然后按Ctrl+X执行该脚本，等待执行结果，可以看到U盘所在的盘符为sdc4(你的可能不一样)，记下该sdc4，按Ctrl+Alt+Delete重启电脑. 电脑重启后，进入CentOS 7菜单选项，选中Install CentOS Linux 7，按e键进入编辑模式，将脚本改为 setparams 'Install CentOS Linux 7 linuxefi/images/pxeboot/vmlinuz inst.stage2=hd:/dev/sdc4 quiet initrdefi/images/pxeboot/initrd.img 这儿是指定安装U盘所在路径。然后按Ctrl+X执行该脚本。 之后出现语言选择界面，选择“中文-简体中文” 安装位置 选中我想手动分区,在弹出的界面点击自动配置分区，这时系统会默认为把最大的分区分给/home。 除了swap分区和/boot/efi外，其他文件系统格式都更改为ext4，Ext4 分别支持 1EB（1,048,576TB， 1EB=1024PB， 1PB=1024TB）的文件系统，以及 16TB 的文件，你的文件再大也足够用了。 /　　 50G 系统根目录 /home 40G　　 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user.主要是桌面系统使用， 60G足够了 /opt 200G 用户级的程序目录，额外安装的可选应用程序包所放置的位置,EDA will be installed here。 /usr 80G 系统级的程序目录，各个用户公用的程序. |--lib 常用的动态链接库目录 |--include 包含目录,头文件目录. |--doc Linux文档目录 |--sbin 超级用户的一些管理程序目录 |--bin 可执行二进制程序目录 |--man 帮助文档目录 |--src 源码目录,Linux源码存在于/usr/src/linux中 |--local |--bin: 本机系统管理员安装的 可执行二进制程序 |--lib: 本机系统管理员增加的库目录 /swap 8G 这里需要注意的是swap的大小，一般来说，应该是实际内存的两倍，但是实际内存很大的话，设置8G也够了 /boot 1G 存放用于系统引导时使用的各种文件. /etc 系统管理和配置文件的目录 /bin 系统可执行二进制程序目录 确认之后,开始自动安装.此时,可以: 设置root密码,这里设置为123,提示过短,直接无视,连续点击左上角完成按钮即可. 设置用户名和密码,这里用户名为姓名首字母拼音abc,密码同样设置123,并将此账户设置为管理员. 挂载Windows硬盘到CentOS 添加repo源到配置文件:wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 安装ntfs-3g: yum -y install ntfs-3g 如果这里出错file contains no head section,你需要删除rm -f /etc/yum.repos.d/epel.repo,更换网络,重新添加repo源到配置文件. 检查第1块硬盘并确认你要访问(挂载)的Windows硬盘上的分区：fdisk -l /dev/sda,检查第2块硬盘fdisk -l /dev/sdb，经过核对硬盘大小,这里确认挂载sdb2; 新建目标文件夹:mkdir /mnt/WinDiskG 将已选择的分区映射(挂载)到目标文件夹:mount -t ntfs-3g /dev/sdb2 /mnt/WinDiskG 检查/mnt/WinDisk目录,查看是否已能正常访问目标分区. 为了以后自动挂载分区到文件夹,需要修改配置文件:vi /etc/fstab. 将语句/dev/sdb2 /mnt/WinDiskG ntfs-3g defaults 0 0添加到文件最后一行. 重启即可. 修改默认boot菜单 su以切换到root,cd /boot/efi/EFI/centos打开文件夹,vim grub.cfg打开grub配置选项 输入:进入vim的命令行模式,输入set nu显示行号; 在大概 60 多行的地方，将两个set timeout=15,等待时间默认 15s. 110 行左右，可以看到 menuentry 开头,要修改启动项名称直接对单引号内内容进行修改,这里直接将windows boot mannager改成Windows 10 x64 EnterPrise. cd /boot/grub2,打开文件夹,vim grubenv,将saved_entry=Windows 10 x64 EnterPrise,修改默认启动项为Win10系统. 注意: 如果后来在保持双系统情况下,又重新安装了Windows系统,则需要在Cent OS中用root账户执行grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg重新生成boot菜单,然后才可以修改. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-03-23 10:44:28 "},"Hardware/A_EDA/3_CentOSBiasicUsage.html":{"url":"Hardware/A_EDA/3_CentOSBiasicUsage.html","title":"CentOS 使用基础","keywords":"","body":"CentOS 使用基础 切换用户 任意界面右键打开终端 su:切换到root,root对应的根目录为/,可以cd / su [username]:切换到普通用户,对应的home目录为~,可以cd ~ /表示根目录 ~表示当前用户的home目录 .表示当前目录 帮助和手册 帮助: [命令] --help查看某命令的帮助菜单. 用法: [命令] --usage查看某命令的使用说明. 手册: man [命令]查看命令的手册, 如man rpm可以查看rpm的命令手册. 软件包的管理 查询软件信息 查询某软件包的信息: rpm -qa | grep -i [软件关键词] 查询系统中已经安装的软件: rpm -qa 查询一个已经安装的文件du于哪个软件包；rpm -qf 文件名的绝对路径 查询已安装软件包都安装到何处；rpm -ql 软件名 查询一个已安装软件包的信息:rpm -qi 软件名 查看一下已安装软件的配置文件； rpm -qc 软件名 查看一个已经安装软件的文档安装位置：rpm -qd 软件名 查看一下已安装软件所依赖的软件包及文件；rpm -qR 软件名 安装软件 安装yum install [软件名] 使用本地源安装 yum install [软件名] 本地包文件 or rpm -ivh [本地包文件] 卸载软件 卸载软件: sudo yum remove [软件名] 删除已安装的软件(卸载依赖包): sudo rpm -e -- [软件名] 删除软件(不卸载依赖包): sudo rpm -e --nodeps [软件名] 查找软件可以去 Here 和 here. 善用搜索功能 find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression] 为文件夹创建快捷方式 在合适地方/opt/idata建立一个可执行打开/mnt/WinDiskG/Charleechan/Desktop/EDA工具安装包文件夹的命令文件godata.sh. #!/bin/sh nautilus /mnt/WinDiskG/Charleechan/Desktop/EDA工具安装包 并放一个合适的图标文件. 将该godata.sh文件添加可执行权限:chmod +x godata.sh 在桌面打开终端,输入vim godata.desktop,添加以下代码, [Desktop Entry] Encoding=UTF-8 Version=1.0 Name=GoData Comment=Goto_data Exec=/opt/idata/godata.sh Icon=/opt/idata/godata.PNG Terminal=false StartupNotify=true Type=Application Categories=Applications vim 常用快捷键 清屏 clear : 终端屏幕向下翻一页，较为常用。 reset : 清空终端屏幕所有信息。 解压文件 根据压缩文件的后缀名,使用不同的解压命令解压. .tar 用 tar xvf 解压 .gz 用 gzip -d或者gunzip 解压 .tar.gz和.tgz 用 tar xzf 解压 .bz2 用 bzip2 -d或者用bunzip2 解压 .tar.bz2用tar –xjf 解压 .Z 用 uncompress 解压 .tar.Z 用tar xZf 解压 .rar 用 unrar e解压 .zip 用 unzip 解压 其中7z文件需要安装p7zip. yum install p7zip # .7z解压, x 表示解压缩, -r 递归解压缩, -o./, 注意-o和./之间无空格 7za x test.7z -o./ rar文件需要编译安装rar. wget https://www.rarlab.com/rar/rarlinux-x64-6.0.1b1.tar.gz tar -zxvf rarlinux-x64-6.0.1b1.tar.gz cd rar make 运行rar 命令，如果出现该错误rar: error while loading shared libraries: libstdc++.so.6: cannot open shared object file: No such file or directory, 则执行该命令：cp rar_static /usr/local/bin/rar 分卷解压 分卷.tar文件： find ./ -print -name 'Base_IC06.18.000*.tar' -exec tar xvf {} \\; 分卷.z01,.z02,.zip文件: # 合并文件 cat weblogic-linux.* > all.zip # 修复已损坏的压缩文件 zip -F all.zip # 正常解压 unzip all.zip 使用截图工具 在命令行中查man gnome-screenshot，设置自己最常用的截图选项，这里我根据个人习惯，使用gnome-screenshot -abp进行框选截图(带光标).使用gnome-screenshot -wbp进行窗口截图带光标。 打开如下选项：Applications(应用)-系统工具-Settings(设置)-设备-Keyboard(键盘)； 下拉到最后，点+号新增快捷键，输入快捷键名称，上述命令，和快捷键。 安装VS Code 需要下载安装libXss.so,执行yum install libXScrnSaver或者去这里下载,更改执行权限,chmod +x libXScrnSaver-1.2.2-6.1.el7.x86_64.rpm,然后安装rpm -ivh libXScrnSaver-1.2.2-6.1.el7.x86_64.rpm, 如果提示需要其他的依赖，则增加--nodeps选项:rpm -ivh --nodeps libXScrnSaver-1.2.2-6.1.el7.x86_64.rpm. 访问Visual Studio Code官网,会自动下载一个code-stable-x64-1614898391.tar.gz文件. 解压文件:tar xzf code-stable-x64-1614898391.tar.gz. 移动到附加软件的目录:sudo mv VSCode-linux-x64 /opt/vscode. 添加可运行权限: sudo chmod +x /opt/vscode/code. 复制sudo cp /opt/vscode/resources/app/resources/linux/code.png /usr/share/icons/. 创建快捷方式到左上角的应用程序菜单中: sudo vim /usr/share/applications/VSCode.desktop [Desktop Entry] Name=Visual Studio Code Comment=Multi-platform code editor for Linux Exec=/opt/vscode/code --no-sandbox Icon=/usr/share/icons/code.png Type=Application StartupNotify=true Categories=TextEditor;Development;Utility; MimeType=text/plain; 运行VS Code: /opt/vscode/code --no-sandbox,也许会出错,报/usr/lib64/libstdc++.so.6: version 'CXXABI_1.3.9' not found,以及usr/lib64/libstdc++.so.6: version 'GLIBCXX_3.4.21' not found的错,原因是GCC编译器版本低,或者已安装过高版本GCC编译器但未链接. 解决办法如下: 查看libstdc++.so.6的软连接信息: 切换到/usr/lib64目录,ls -l libstdc++.so*,发现现在libstdc++.so.6连接到libstdc++.so.6.0.19. 查看libstdc++.so.6包含哪些动态库: strings /usr/lib64/libstdc++.so.6 | grep GLIBC, strings /usr/lib64/libstdc++.so.6|grep CXXABI,发现的确没有CXXABI_1.3.9和GLIBCXX_3.4.21. 方法一: 更新GCC编译器 确定当前GCC版本,gcc --version,发现是gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44). 在这里查询到,GCC 5.1.0: GLIBCXX_3.4.21, CXXABI_1.3.9,因此要安装GCC 5.1.0之后的版本. 下载wget http://ftp.tsukuba.wide.ad.jp/software/gcc/releases/gcc-5.2.0/gcc-5.2.0.tar.bz2,解压tar -xvf gcc-5.2.0.tar.bz2 进入解压目录: cd gcc-5.2.0, 下载编译gcc所需的依赖文件和库 ./contrib/download_prerequisites 建立输出目录，用于存放编译时所有产生的中间文件,mkdir gcc-temp,进入输出目录,cd gcc-temp 执行configure配置,../configure --enable-checking=release --enable-languages=c,c++ --disable-multilib 编译gcc，指定编译使用的线程数为8，编译耗时较长，可能需要几个小时,make -j8,这里为了避免影响系统的稳定性， 执行\"make install\"和替换系统默认版本的gcc 查找本机已有的libstdc++.so文件:find / -name \"libstdc++.so*\",找到新安装的libstdc++.so所在位置,并切换到该位置. 方法二: 在这里查询到,GCC 5.1.0: GLIBCXX_3.4.21, CXXABI_1.3.9,还查询到GCC 5.1.0: libstdc++.so.6.0.21,因此要安装6.0.21及之后的版本. 在网上找到了一个libstdc.so_.6.0.26.zip,使用unzip libstdc.so_.6.0.26.zip将其解压. 或者直接点我下载, 把下载或安装GCC得到的libstdc++.so.6.*.*拷贝到/usr/lib64目录: sudo cp ./libstdc++.so.6.0.26 /usr/lib64/libstdc++.so.6.0.26 备份原来的libstdc++.so.6符号链接: sudo cp /usr/lib64/libstdc++.so.6 /usr/lib64/libstdc++.so.6.bak 删除原来的符号连接: sudo rm -rf /usr/lib64/libstdc++.so.6 新建新符号连接: sudo ln -s /usr/lib64/libstdc++.so.6.0.26 /usr/lib64/libstdc++.so.6 查看当前libstdc++.so.6中包含哪些动态库: strings /usr/lib64/libstdc++.so.6 | grep GLIBC, strings /usr/lib64/libstdc++.so.6|grep CXXABI. 执行文件关联 cd /usr/share/applications,su [你的用户名] 执行文件关联： xdg-mime default VSCode.desktop text/markdown. 查询文件关联: xdg-mime query default text/markdown. 安装搜狗输入法 搜狗和谷歌输入法等使用的是fcitx框架，需要安装fcitx! 不可直接卸载自带的ibus 输入法. 单独卸载ibus软件, 不卸载依赖包: rpm -e --nodeps ibus 安装epel库源 yum -y install epel-release 安装fcitx yum -y install fcitx fcitx-pinyin fcitx-configtool 设置fcitx为自启动项：打开 应用程序>附件>优化>开机启动程序>添加fcitx为自启动项 在 /etc/profile.d 中增加一个配置脚本命名为 fcitx.sh: vim /etc/profile.d/fcitx.sh export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=@im=fcitx 修改重启或关机时 systemd 等待 fcitx 进程的时长, 避免自启动后开关机时间过长, 需要修改fcitx配置文件: vim /etc/systemd/system.conf, 将其中的 #DefaultTimeoutStopSec=90s这一行前面的 #去掉，然后将其赋值改为10s保存. 安装搜狗输入法依赖软件 : yum install qtwebkit -y 在火狐浏览器中,下载搜狗输入法. http://cdn2.ime.sogou.com/dl/index/1524572264/sogoupinyin_2.2.0.0108_amd64.deb?st=jpTlz-vO-Of4mW1f10EBCg&e=1570252581&fn=sogoupinyin_2.2.0.0108_amd64.deb 安装dpkg包：yum -y install dpkg 安装alien包: yum -y install alien deb -> rpm包转换: sudo alien -r --scripts sogoupinyin_2.2.0.0108_amd64.deb, 直到转换完成sogoupinyin-2.2.0.0108-2.x86_64.rpm generated rpm包安装 : sudo rpm -ivh --force sogoupinyin-2.2.0.0108-2.x86_64.rpm 搜狗拼音的库,创建软链接： sudo ln -s /usr/lib/x86_64-linux-gnu/fcitx/fcitx-sogoupinyin.so /usr/lib64/fcitx/fcitx-sogoupinyin.so sudo ln -s /usr/lib/x86_64-linux-gnu/fcitx/fcitx-punc-ng.so /usr/lib64/fcitx/fcitx-punc-ng.so 重启系统。输入fcitx-configtool启动，添加键盘时取消勾选，输入sogou过滤，看到Sogou Pinyin输入法，点击添加进去. 设置其键盘布局为 汉语. 并在系统设置中设置默认的键盘 然后按SHIFT键切换输入法，测试中文输出即可。 安装苹方字体 首先将平方字体文件拷贝到Linux机器上。 # centos 安装fontconfig 工具包 yum install -y fontconfig mkfontscale # ubuntu上 # sudo apt-get -y install fontconfig xfonts-utils # 查看已经安装的中文字体 fc-list :lang=zh # 安装微软雅黑字体 # 1. 把MSYH.TTF复制到/usr/share/fonts/目录下，使用如下命令： cd /root/ cp MSYH.TTF /usr/share/fonts/ # 2. 然后建立字体索引信息，更新字体缓存，使用如下命令： cd /usr/share/fonts/ mkfontscale mkfontdir fc-cache # 查看是否已安装成功 fc-list :lang=zh 然后打开 应用程序>附件>优化>字体, 修改窗口标题、界面、文档、等宽字体等，然后reboot即可。 执行某程序时报错 例如,提示报错缺少 libXp.so.6,去这里搜索libXp.so.6,可以发现其位于libXp库,于是 # 安装32位libXp yum install libXp.i686 # 安装64位libXp yum install libXp 安装WPS 安装WPS必须字体 首先下载字体,解压 mkdir -p /usr/share/fonts/wps_symbol_fonts cp -r ./wps_symbol_fonts/* /usr/share/fonts/wps_symbol_fonts/ # 权限设置操作如下： cd /usr/share/fonts/ chmod 755 wps_symbol_fonts cd /usr/share/fonts/wps_symbol_fonts chmod 644 * # 接着生存缓存配置信息，具体操作如下： cd /usr/share/fonts/wps_symbol_fonts mkfontdir mkfontscale fc-cache 使用Firefox浏览器去WPS官网点击下载，选择 64位RPM格式中的 For x64. 找到下载的安装包,安装之: rpm -ivh wps-office-11.1.0.10161-1.x86_64.rpm. 在终端输入wps可以启动WPS. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-03-12 17:00:24 "},"Hardware/A_EDA/4_InstallCDStools.html":{"url":"Hardware/A_EDA/4_InstallCDStools.html","title":"Cadence工具安装I-模拟部分","keywords":"","body":"Cadence工具安装I-模拟部分 本环境包括 IC617, MMSIM151和 Calibre2019. 本教程的所有操作均在 root 权限下进行。 可参考CentOS安装IC618和calibre2019. 安装前的准备 新建安装目录, 建议把这种大型软件装在 /usr 目录下。 mkdir -p /opt/eda/cadence/patch mkdir -p /opt/eda/cadence/iscape mkdir -p /opt/eda/mentor/calibre2019 -p选项是直接建立父目录。 安装 cd [安装包路径] su # 将IC618、SPECTRE18、和patch工具复制到`cadence`目录,文件较大，请耐心待。 cp ./IC06.18.000/* /opt/eda/cadence/ cp ./patch/* /opt/eda/cadence/patch cp ./SPECTRE18.10.077/* /opt/eda/cadence/ # 解压IC618的安装包 cd /opt/eda/cadence/ tar xvf /opt/eda/cadence/Base_IC06.18.000_lnx86_1of3.tar tar xvf /opt/eda/cadence/Base_IC06.18.000_lnx86_2of3.tar tar xvf /opt/eda/cadence/Base_IC06.18.000_lnx86_3of3.tar # 删除IC618的安装包 rm /opt/eda/cadence/Base_IC06.18.000_lnx86_1of3.tar rm /opt/eda/cadence/Base_IC06.18.000_lnx86_2of3.tar rm /opt/eda/cadence/Base_IC06.18.000_lnx86_3of3.tar # 解压SPECTRE的安装包 tar xvf /opt/eda/cadence/Base_SPECTRE18.10.077_lnx86_1of2.tar tar xvf /opt/eda/cadence/Base_SPECTRE18.10.077_lnx86_2of2.tar # 删除SPECTRE的安装包 rm /opt/eda/cadence/Base_SPECTRE18.10.077_lnx86_1of2.tar -f rm /opt/eda/cadence/Base_SPECTRE18.10.077_lnx86_2of2.tar -f mkdir -p /opt/eda/cadence/IC618 mkdir -p /opt/eda/cadence/SPECTRE181 # 运行安装脚本 /opt/eda/cadence/IC06.18.000_lnx86.Base/CDROM1/SETUP.SH 会弹出一个界面，直接按Enter,然后按提示输入IC618安装目录/opt/eda/cadence/IC618. 由于没有事先安装InstallScape，这里按提示依次输入n, y. 然后输入iscape安装目录/opt/eda/cadence/iscape 弹出InstallScape界面，选择Local directory/Media install，点Browse，选择安装包的路径, /opt/eda/cadence/IC06.18.000_lnx86.Base/CDROM1 点击Continue。 弹出来的界面中，勾选IC_06.18.000后，点击Next。 弹出来的界面中，选择好IC618的安装路径/opt/eda/cadence/IC618后，点击Start开始安装。 完成后，提示配置失败. 另外开一个终端,执行su,yum install xterm -y以安装xterm库,安装完成后关闭该终端即可. 在installScape界面,点击 菜单View> Configurable releases>勾选IC618> 点击右下角 Configure,开始配置 大部分的配置可以直接按Enter，有两个需要注意一下：一个是提示要不要安装库文件，可以选择安装；另外一个是提示要不要使用默认的OpenAcess路径，建议选择默认的(输入n)就行。 配置完成后，完成了IC618的安装，不要关掉iscape界面，继续进行SPECTRE18的安装。 与上面一样，不再赘述。等待安装完成。 然后删除安装包文件。 rm -rf /opt/eda/cadence/IC06.18.000_lnx86.Base/ rm -rf /opt/eda/cadence/SPECTRE18.10.077_lnx86.Base/ # 开始安装Calibre # 复制安装包文件到目录中 cd [安装包路径] cp ./calibre/* /opt/eda/mentor/ cd /opt/eda/mentor/ # 解压安装包 # 合并分卷文件 cat aoj_cal_2019.3_15.11_mib.* > all.zip # 正常解压 unzip all.zip # 增加可执行权限 chmod +x ./aoj_cal_2019.3_15.11_mib.exe mv ./aoj_cal_2019.3_15.11_mib.exe ./calibre2019/aoj_cal_2019.3_15.11_mib.exe rm -f aoj_cal_2019.3_15.11_mib.z01 rm -f aoj_cal_2019.3_15.11_mib.zip rm -f all.zip cd calibre2019 # 执行安装程序 ./aoj_cal_2019.3_15.11_mib.exe # 提示缺少ld-linux.so.2，需要先安装32位的glibc库, yum -y install glibc.i686 www.cit.cn # 重新执行安装程序 ./aoj_cal_2019.3_15.11_mib.exe # What would you like to do? > # 输入d, 按Enter # 输入yes，按Enter # 等待,安装完成 rm -f aoj_cal_2019.3_15.11_mib.exe # 开始破解 cd /opt/eda/cadence/patch ./1patch.sh /opt/eda/cadence/IC618/ # 提示缺少libstdc++.so.6 yum -y install libstdc++.i686 # 重新运行破解IC618 ./1patch.sh /opt/eda/cadence/IC618/ # 破解SPECTRE181 ./1patch.sh /opt/eda/cadence/SPECTRE181/ # 破解calibre2019 ./1patch.sh /opt/eda/mentor/calibre2019/ # 生成Cadence的所有工具套装license python cdslicgen.py mkdir /opt/eda/cadence/license mv ./license.dat /opt/eda/cadence/license/license.dat # 查看mac地址 ifconfig # ether后面的就是mac地址,copy一下,产生Calibre的license python mgclicgen.py 80:fa:5b:39:ac:12 mkdir /opt/eda/mentor/license mv license.dat /opt/eda/mentor/license/license.dat # 修改主机名为eda vim /etc/hosts #在末尾行添加 127.0.0.1 eda # 在hostname文件 vim /etc/hostname #修改主机名为”eda” eda #在 network 文件 vim /etc/sysconfig/network #在末尾添加 HOSTNAME=eda 测试 首次使用需要配置: # 切换到个人账户 su [你的账户名] cd [安装包的目录] cp ./patch/.cshrc ~/.cshrc vim ~/.cshrc #将第三行的 setenv LANG C # 改成 setenv LANG zh_CN.UTF-8 #如果你用fcitx或搜狗输入法,需要在本文件头部增加 setenv GTK_IM_MODULE fcitx setenv QT_IM_MODULE fcitx setenv XMODIFIERS @im=fcitx # 然后切换到个人账户的home目录 cd ~ su root # 将个人用户的shell改为csh usermod -s /bin/csh [你的账户名] 测试一下: # 切换到个人账户 su [你的账户名] cd ~ # 加载环境变量 source .cshrc # 启动IC618，输入virtuoso virtuoso & # 提醒 bash: /opt/eda/cadence/IC618/bin/virtuoso: /bin/ksh: 坏的解释器: 没有那个文件或目录 yum install ksh # 启动IC618，输入virtuoso virtuoso & # 提示 没有libGLU.so.1 yum install mesa-libGLU.i686 # 启动IC618，输入virtuoso virtuoso & # 提示 sh: lsb_release: command not found yum install -y redhat-lsb # 输入exit退出软件 exit 以后每次使用只需: 启动virtuoso # 切换到个人账户 su [你的账户名] # 启动IC618，输入virtuoso virtuoso & 启动calibre # 切换到个人账户 su [你的账户名] # 启动calibre calibre -gui 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-03-12 21:20:23 "},"Hardware/A_EDA/5_InstallCDStools2.html":{"url":"Hardware/A_EDA/5_InstallCDStools2.html","title":"Cadence工具安装II-数字部分","keywords":"","body":"Cadence工具安装II-数字部分 本教程将安装INSIVE151(NC-verilog),Innovus. 本教程以root用户安装。 安装INCISIVE 15.10 mkdir -p /opt/eda/cadence/INCISIVE151 cd [安装包路径] cp ./INCISIVE151/INCISIVE15.10.010_Hotfix.7z.00* /opt/eda/cadence/ cd /opt/eda/cadence/ # 合并安装包 cat INCISIVE15.10.010_Hotfix.7z.00*>INCISIVE15.10.010_Hotfix.7z rm -f INCISIVE15.10.010_Hotfix.7z.00* 7za x INCISIVE15.10.010_Hotfix.7z -o./ rm -f INCISIVE15.10.010_Hotfix.7z # 运行iscape脚本,进入iscape安装界面 cd ./iscape/iscape cd bin ./iscape.sh 点击 Load directory/Media install,选择安装包路径/opt/eda/cadence/INCISIVE15.10.010_Hotfix 弹出界面,勾选incisive, 点右下角Next. 弹出页面,选择所有组件,设置安装目录/opt/eda/cadence/INCISIVE151. 点start开始安装，在安装过程中弹出的对话框都写yes回车,碰到license不通过的写no回车。 安装INNOVUS mkdir INNOVUS181 cd [安装包路径] cp INNOVUS18.10.000/* /opt/eda/cadence/ cd /opt/eda/cadence/ # 解压安装包 tar xvf /opt/eda/cadence/Base_INNOVUS18.10.000_lnx86_1of2.tar tar xvf /opt/eda/cadence/Base_INNOVUS18.10.000_lnx86_2of2.tar rm -f Base_INNOVUS18.10.000_lnx86_*of2.tar # 运行iscape脚本,进入iscape安装界面 cd ./iscape/iscape cd bin ./iscape.sh 点击 Load directory/Media install,选择安装包路径/opt/eda/cadence/INNOVUS18.10.000_lnx86.Base/CDROM1 弹出界面,勾选INNOVUS, 点右下角Next. 弹出页面,选择所有组件,设置安装目录/opt/eda/cadence/INNOVUS181. 提示要不要使用默认的OpenAcess路径，建议选择默认的(输入n)就行。 破解 安装完成后,开始破解. cd /opt/eda/cadence/patch ./1patch.sh /opt/eda/cadence/INCISIVE151/ ./1patch.sh /opt/eda/cadence/INNOVUS181/ # 打开用户脚本,设置环境变量 su [username] cd ~ vim ./cshrc # 在合适位置处,添加以下几行 setenv INCISIVE_HOME ${CADHOME}/INCISIVE151 setenv LD_LIBRARY_PATH ${INCISIVE_HOME}/tools/lib/64bit:${INCISIVE_HOME}/tools setenv PATH ${PATH}:${INCISIVE_HOME}/tools/bin setenv INNOVUS_HOME ${CADHOME}/INNOVUS181 setenv LD_LIBRARY_PATH ${INNOVUS_HOME}/tools/lib/64bit:${INNOVUS_HOME}/tools setenv PATH ${PATH}:${INNOVUS_HOME}/tools/bin 由于上节中生成的license.dat已经包括了INCISIVE和INNOVUS,因此直接尝试运行. 在终端输入 simvision 可以打开 simvision 界面. 在终端输入 innovus 提示报错缺少 libXp.so.6,去这里搜索libXp.so.6,可以发现其位于libXp库,于是 # 安装32位libXp yum install libXp.i686 # 安装64位libXp yum install libXp 输入 innovus 可以打开 innovus 界面. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-03-12 21:20:07 "},"Hardware/A_EDA/6_InstallSYNtools.html":{"url":"Hardware/A_EDA/6_InstallSYNtools.html","title":"Synopsys工具安装II-数字前端","keywords":"","body":"Synopsys工具安装II-数字前端 本环境包括 Synplify18,HiSpice,VCS. 可参考Synopsys EDA安装教程. 安装前的准备 新建安装目录, 建议把这种大型软件装在 /opt/ 目录下。 su root # synopsys 软件安装程序 的存放目录 mkdir -p /opt/eda/synopsys/installer # synopsys 软件安装程序 的安装包文件目录 mkdir -p /opt/eda/synopsys/installer_pack # synplify2018 的安装目录 mkdir -p /opt/eda/synopsys/syn # synplify2018 的安装包文件目录 mkdir -p /opt/eda/synopsys/syn_pack # 许可程序scl 的安装目录 mkdir -p /opt/eda/synopsys/scl # 许可程序scl 的安装包文件目录 mkdir -p /opt/eda/synopsys/scl_pack # 存放 license.dat 文件 mkdir -p /opt/eda/synopsys/license # 临时存放目录 mkdir -p /opt/eda/synopsys/temp chmod 777 /opt/eda/synopsys/ chmod 777 /opt/eda/synopsys/temp chmod 777 /opt/eda/synopsys/syn chmod 777 /opt/eda/synopsys/scl -p选项是直接建立父目录。 安装DC, SCL cd [安装包目录] # 复制 synopsysinstaller_v5.0.rar 到 /opt/eda/synopsys/installer_pack/ cp ./synopsysinstaller_v5.0.rar /opt/eda/synopsys/installer_pack/ # 复制 ./syn_vO-2018.06-SP1/* 到 /opt/eda/synopsys/syn_pack/ cp ./syn_vO-2018.06-SP1/* /opt/eda/synopsys/syn_pack/ # 复制 ./scl_v2018.06-SP1/* 到 /opt/eda/synopsys/scl_pack/ cp ./scl_v2018.06-SP1/* /opt/eda/synopsys/scl_pack/ cd /opt/eda/synopsys/installer_pack/ # 解压 unrar e synopsysinstaller_v5.0.rar chmod +x SynopsysInstaller_v5.0.run # 执行setup.sh ./SynopsysInstaller_v5.0.run # 提示制定安装目录,输入 /opt/eda/synopsys/installer # 删除 installer_pack cd .. rm -rf ./installer_pack cd installer/ # 以普通用户身份安装 chmod +x setup.sh su [你的用户名] ./setup.sh 在弹出的页面中Site ID填写000, Site Administrator留空, Contact Information填写ccl@(none),点Next 弹出页面Source选/opt/eda/synopsys/syn_pack/ 弹出页面Temp Path选/opt/eda/synopsys/temp 弹出页面Target Dir选/opt/eda/synopsys/syn 弹出页面勾选所有组件 弹出页面Target Dir选/opt/eda/synopsys/syn 安装完成之后点X关闭页面,不要点finish避免出错. 然后继续执行安装脚本安装scl # 执行setup.sh ./setup.sh 在弹出的页面中Site ID填写000, Site Administrator留空, Contact Information填写ccl@(none),点Next 弹出页面Source选/opt/eda/synopsys/scl_pack/ 弹出页面Temp Path选/opt/eda/synopsys/temp 弹出页面Target Dir选/opt/eda/synopsys/scl 弹出页面勾选所有组件 弹出页面Target Dir选/opt/eda/synopsys/scl 安装完成之后点X关闭页面,不要点finish避免出错. 安装HSPICE cd [安装包目录] mkdir /opt/eda/synopsys/hspice mkdir /opt/eda/synopsys/hspice_pack chmod 777 /opt/eda/synopsys/hspice cp ./hspice_vN-2017.12-SP2/* /opt/eda/synopsys/hspice_pack/ cd installer/ # 以普通用户身份安装 chmod +x setup.sh su [你的用户名] ./setup.sh 在弹出的页面中Site ID填写000, Site Administrator留空, Contact Information填写ccl@(none),点Next 弹出页面Source选/opt/eda/synopsys/hspice_pack/ 弹出页面Temp Path选/opt/eda/synopsys/temp 弹出页面Target Dir选/opt/eda/synopsys/hspice 弹出页面勾选所有组件 弹出页面Target Dir选/opt/eda/synopsys/hspice 安装完成之后点X关闭页面,不要点finish避免出错. 安装VCS cd [安装包目录] mkdir /opt/eda/synopsys/vcs mkdir /opt/eda/synopsys/vcs_pack chmod 777 /opt/eda/synopsys/vcs cp ./vcs_vO-2018.09-SP2/* /opt/eda/synopsys/vcs_pack/ cd installer/ # 以普通用户身份安装 chmod +x setup.sh su [你的用户名] ./setup.sh 在弹出的页面中Site ID填写000, Site Administrator留空, Contact Information填写ccl@(none),点Next 弹出页面Source选/opt/eda/synopsys/vcs_pack/ 弹出页面Temp Path选/opt/eda/synopsys/temp 弹出页面Target Dir选/opt/eda/synopsys/vcs 弹出页面勾选所有组件 弹出页面Target Dir选/opt/eda/synopsys/vcs 安装完成之后点X关闭页面,不要点finish避免出错. 破解 找到你的lmhostid和 hostname 在你的 linux 中输入 ifconfig ，得到MAC地址,是一串12位的字符串（由0-9和a-f组成），如果得到的是几个字符串，那就随便选一个，例如是80fa5b39ac12。 在你的 linux 中输入 hostname ，得到你 linux 的名字，记录下来，例如是 eda ； 在任意Windows机器上, 打开 [安装包目录]/synopsys crark/scl_keygen.exe 程序；把MAC地址80fa5b39ac12填入HOST ID Daemon和 HOST ID Feature 中，把 hostname 也就是 eda 填入到HOST name中，检查EXPIRE中的日期是否满足要求。 点击 Generate 后，会在目录下生成 Synopsys.dat 文件，该文件就是得到的 license ，将该文件重命名为license.dat。 修改license.dat的前3行为： SERVER eda 80fa5b39ac12 27000 DAEMON snpslmd /opt/eda/synopsys/scl/suse64/bin/snpslmd USE_SERVER INCREMENT SSS snpslmd 1.0 12-dec-2029 1 6F52542CDB8822322E1D \\ VENDOR_STRING=\"28A69 CAA0B A99A7 BE9FB AD385 BDC1E 5F0F6 217B5 \\ EEC64 786\" ISSUER=\"Synopsys, Inc. [1/8/2014 0:43:49 26356 3.16.2]\" \\ NOTICE=\"Licensed to student@eetop [DO NOT DELETE/MODIFY SSS OR ANY \\ OTHER KEYS IN THIS FILE]\" SN=RK:0:0:1 PACKAGE snps_lic_1 snpslmd 2019.2019 10A030F1A319D126BD85 COMPONENTS=\"3D \\ 3P \" ck=205 ... 将生成好的license文件导入linux系统的/opt/eda/synopsys/license中，执行/opt/eda/synopsys/scl/suse64/bin/sssverify /opt/eda/synopsys/license/license.dat可以看到License file integrity check PASSED!则license文件创建成功. # 使用普通用户身份 su [你的用户名] vim ~/.cshrc # 在`.cshrc`文件的末尾添加如下命令： setenv SYNOPSYS_HOME /opt/eda/synopsys setenv LM_LICENSE_FILE ${SYNOPSYS_HOME}/license/license.dat setenv SNPSLMD_LICENSE_FILE ${SYNOPSYS_HOME}/license/license.dat ${SYNOPSYS_HOME}/scl/suse64/bin/lmgrd -c ${SYNOPSYS_HOME}/license/license.dat -l ~/synopsys_lic.log #add DC to PATH setenv PATH ${PATH}:${SYNOPSYS_HOME}/syn/amd64/syn/bin #add SCL to PATH setenv PATH ${PATH}:${SYNOPSYS_HOME}/scl/suse64/bin #add hspice to PATH setenv PATH ${PATH}:${SYNOPSYS_HOME}/hspice/hspice/bin #add vcs to PATH setenv PATH ${PATH}:${SYNOPSYS_HOME}/vcs/amd64/bin 然后在终端执行source ~/.cshrc，更新环境变量. 重启系统 测试 在终端中输入dc_shell打开DC。 报错找不到libtiff.so.3,去这里搜索libtiff,系统选择centos,下载安装64位版libtiff-4.0.3-35.el7.x86_64.rpm 然后rpm -ivh libtiff-4.0.3-35.el7.x86_64.rpm,安装RPM包. 执行sudo ln -s /usr/lib64/libtiff.so.4 /usr/lib64/libtiff.so.3建立符号链接. 输入dc_shell打开DC。 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-03-12 22:44:09 "},"Hardware/A_EDA/7_InstallSYNtools2.html":{"url":"Hardware/A_EDA/7_InstallSYNtools2.html","title":"Synopsys工具安装II-数字后端","keywords":"","body":"Synopsys工具安装II-数字后端 本环境包括 ICC,PT,Formality。 安装ICC cd [安装包目录] mkdir /opt/eda/synopsys/icc mkdir /opt/eda/synopsys/icc_pack chmod 777 /opt/eda/synopsys/icc cp ./ic_compiler_vO-2018.06-SP1/* /opt/eda/synopsys/icc_pack/ cd installer/ # 以普通用户身份安装 chmod +x setup.sh su [你的用户名] ./setup.sh 在弹出的页面中Site ID填写000, Site Administrator留空, Contact Information填写ccl@(none),点Next 弹出页面Source选/opt/eda/synopsys/icc_pack/ 弹出页面Temp Path选/opt/eda/synopsys/temp 弹出页面Target Dir选/opt/eda/synopsys/icc 弹出页面勾选所有组件 弹出页面Target Dir选/opt/eda/synopsys/icc 安装完成之后点X关闭页面,不要点finish避免出错. 安装PT cd [安装包目录] mkdir /opt/eda/synopsys/pt mkdir /opt/eda/synopsys/pt_pack chmod 777 /opt/eda/synopsys/pt cp ./pt_vO-2018.06-SP1/* /opt/eda/synopsys/pt_pack/ cd installer/ # 以普通用户身份安装 chmod +x setup.sh su [你的用户名] ./setup.sh 在弹出的页面中Site ID填写000, Site Administrator留空, Contact Information填写ccl@(none),点Next 弹出页面Source选/opt/eda/synopsys/pt_pack/ 弹出页面Temp Path选/opt/eda/synopsys/temp 弹出页面Target Dir选/opt/eda/synopsys/pt 弹出页面勾选所有组件 弹出页面Target Dir选/opt/eda/synopsys/pt 安装完成之后点X关闭页面,不要点finish避免出错. 安装Formality cd [安装包目录] mkdir /opt/eda/synopsys/fm mkdir /opt/eda/synopsys/fm_pack chmod 777 /opt/eda/synopsys/fm cp ./fm_vO-2018.06-SP1/* /opt/eda/synopsys/fm_pack/ cd installer/ # 以普通用户身份安装 chmod +x setup.sh su [你的用户名] ./setup.sh 在弹出的页面中Site ID填写000, Site Administrator留空, Contact Information填写ccl@(none),点Next 弹出页面Source选/opt/eda/synopsys/fm_pack/ 弹出页面Temp Path选/opt/eda/synopsys/temp 弹出页面Target Dir选/opt/eda/synopsys/fm 弹出页面勾选所有组件 弹出页面Target Dir选/opt/eda/synopsys/fm 安装完成之后点X关闭页面,不要点finish避免出错. 修改.cshrc脚本 # 使用普通用户身份 su [你的用户名] vim ~/.cshrc # 在`.cshrc`文件的末尾添加如下命令： #add ICC to PATH setenv PATH ${PATH}:${SYNOPSYS_HOME}/icc/amd64/syn/bin #add PT to PATH setenv PATH ${PATH}:${SYNOPSYS_HOME}/pt/amd64/syn/bin #add FM to PATH setenv PATH ${PATH}:${SYNOPSYS_HOME}/fm/suse64/fm/bin 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-03-12 22:45:09 "},"Hardware/B_HDL/":{"url":"Hardware/B_HDL/","title":"Verilog/SV","keywords":"","body":"内容列表 回到主页 SV Verilog VHDL 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Software/1_CSTM32/":{"url":"Software/1_CSTM32/","title":"C程序与驱动开发","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Software/2_CppQt/":{"url":"Software/2_CppQt/","title":"CPP程序与Qt开发","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Software/3_Datas/":{"url":"Software/3_Datas/","title":"数据结构与数据库","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Software/4_DSPISP/":{"url":"Software/4_DSPISP/","title":"信号/图像处理","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Software/5_PythonAI/":{"url":"Software/5_PythonAI/","title":"Python与AI","keywords":"","body":"内容列表 回到主页 Python开发环境的配置 使用Matplotlib绘制动图 pyplot在一个坐标系里画多个子图 Pytorch 使用autograd.grad()计算导数与偏导 Pytorch开发环境搭建 res 资源(右键打开或下载) get-pip.py MakeGif.py Tensorflow Tensorflow开发环境搭建 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Software/5_PythonAI/DevEnvDeploy.html":{"url":"Software/5_PythonAI/DevEnvDeploy.html","title":"Python开发环境的配置","keywords":"","body":"Python开发环境的配置 Python简介 Python是一种脚本语言，脚本文件名后缀为.py； 与C语言不同，它不需要编译链接的过程，而是由一个应用程序直接对代码进行解释，然后执行；这个用来解释脚本代码并执行的应用程序叫做解释器。 通常，为了代码可读性，把一个很长的脚本文件分成多个脚本文件，几个脚本组合成一个软件包，叫做模块。一个模块一般是一个文件夹。 有许多通用的模块，会随着Python的官方版本发布，形成内置模块。 还有一些用处比较专业的模块，就是第三方模块，一般使用PIP进行第三方模块的安装，更新，卸载等。 笔者推荐使用 VScode 进行 Python 程序的开发。 环境系统：Windows 10 x64 Enterprise。 下载并安装便携版Python 去Python官网，在左侧Stable Releases一栏下载Python的可移植包Windows x86-64 embeddable zip file，根据需要选择Python版本，这里下载的是python-3.6.8-embed-amd64.zip，大小只有不到7MB。 安装Python：解压 zip 文件到你想安装的路径，重命名文件夹为Python,可以看到其中已经有一个 python.exe ，在CMD中定位到此Python文件夹，输入python后按回车，进入python命令行环境，输入以下命令: import sys print('hello, python!') print(sys.path) 按回车，print(sys.path)可以看到Python 模块的路径，包括了python36.zip及本程序的目录Python。 双击打开python36.zip，可以看到其中已经内置了一些基本的模块，包括json,html等。 设置环境变量PATH：添加该Python目录到系统环境变量Path(或PATH，不区分大小写)。 设置环境变量之后，以后在任意路径打开命令行，输入python，都会调用该PATH中包含的路径下的python.exe。如果没有打开Python命令行，你需要重启系统以更新环境变量的设置。 你也可以把步骤2中的代码写入一个脚本文件hello.py，然后在该脚本文件所在路径打开命令行，执行python hello.py，让解释器执行该脚本。 安装第三方Python模块 安装模块管理工具PIP:下载get-pip.py或get-pip.py到文件夹Python中，在CMD中定位到此Python文件夹,运行python get-pip.py，安装完成后修改python36._pth的内容为： python36.zip . # Uncomment to run site.main() automatically import site 该文件中定义了python解释器的搜索路径，包括 python36.zip文件包，.表示当前路径，以及site指定的路径。 可以在此文件中任意添加路径,以包含你自定义的包,因此遇到ModuleNotFoundError: No module named错误时,可尝试修改此文件. 可以看到Python/Scripts目录下已经有pip.exe等几个pip应用程序。把该Python/Scripts目录也添加到系统环境变量PATH。 安装第三方模块：使用pip管理python软件包，直接在cmd窗口中输入pip命令，会显示pip所有的参数使用方法； 模块的安装包文件名是.whl,你可以去以下站点下载要安装的包 Python Package Index 清华镜像站 阿里镜像源 以下是常用的pip命令： pip install [PackageName] # 安装某个模块 pip install [PackageName]==[VersionNum] # 安装指定版本的模块 pip install --upgrade [PackageName] # 升级某个模块 pip install [Package.whl] # 根据本地安装文件安装 pip show [PackageName] # 展示已安装的某个模块的信息 pip uninstall [PackageName] # 卸载某个模块 pip list # 列出已安装的模块 pip list --outdated # 查看有新版本的第三方库 pip download [PackageName] # 下载某个模块 以下是常用的第三方模块 pip install pillow # 图像处理标准库 pip install requests # 访问网络资源 pip install matplotlib # 数据2维可视化，作图神器 pip install numpy # 数组与矩阵运算 pip install sympy # 强大的符号计算体系完成诸如多项式求值、求极限、解方程、求积分、微分方程、级数展开、矩阵运算等等 pip install SciPy # 基于numpy 信号处理，数学、科学、工程计算功能库 pip install pandas # 数据分析高层次应用库 pip install Tensorflow # 机器学习研究，能够更快更好地将科研原型转化为生产项目 pip install pyspider # 强大的Web页面爬取系统 pip install BeautifulSoup #HTML和XML的解析库 pip install Tkinter # 可视化界面 pip install PySide # PyQt5的免费版 pip install PyQt5 # Qt开发框架的Python接口 pip install PyInstaller # 将 Python 源文件打包，通过对源文件打包， Python 程序可以在没有安装 Python 的环境中运行 pip install pipreqs #分析python文件依赖关系 配置PIP安装软件资源站(清华): 直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini，内容如下 [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple 在VS Code中开发Python 打开VS Code，点击左侧插件按钮，安装插件Python； 安装Pylance之后，在VS Code中按Ctrl+,键，打开设置，输入python auto complete搜索，点击Edit in setting.json，在 \"python.analysis.extraPaths\"`的方括号中添加以下两行，加入Python路径: \"python.analysis.extraPaths\": [ \"D:\\\\Program\\\\Python\\\\Scripts\", \"D:\\\\Program\\\\Python\\\\Lib\\\\site-packages\" ] 代码出错提示：打开命令行，输入 pip install flake8，安装flake8成功后，打开VScode，按Ctrl+,键，打开设置，输入python linting flake8 enabled，勾选选项。 自动格式化代码：打开命令行，输入pip install yapf，安装yapf之后，打开VScode，按Ctrl+,键，打开设置，输入python formatting provider，后面编辑Python代码时，在VScode中按Alt+Shift+F即可自动格式化代码。 在安装完成基础环境之后，你可能会想 安装Tensorflow开发环境。 安装Pytorch开发环境。 打包你的脚本文件给一个没有安装Python环境的机器中运行。 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-02-08 17:25:07 "},"Software/5_PythonAI/MakeAGif.html":{"url":"Software/5_PythonAI/MakeAGif.html","title":"使用Matplotlib绘制动图","keywords":"","body":"使用Matplotlib绘制动图 如果我们想用matplotlib的save方法渲染GIF动图，就需要安装ImageMagick，按照自己的电脑系统下载对应版本. import seaborn # 酷炫点的主题,可以去掉 import sys import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation fig, ax = plt.subplots() fig.set_tight_layout(True) plt.style.use('seaborn-pastel') # 询问图形在屏幕上的大小和DPI（每英寸点数） # 注意当把图形保存为文件时，需要为此单独再提供一个DPI print('fig size: {0} DPI, size in inches {1}'.format(fig.get_dpi(), fig.get_size_inches())) # 绘制一个保持不变（不会被重新绘制）的散点图以及初始直线 x = np.arange(0, 20, 0.1) ax.scatter(x, x + np.random.normal(0, 3.0, len(x))) line, = ax.plot(x, x - 5, 'r-', linewidth=2) def update(i): label = 'timestep {0}'.format(i) print(label) # 更新直线和轴（用一个新X轴标签） # 以元组形式返回这一帧需要重新绘制的物体 line.set_ydata(x - 5 + i) ax.set_xlabel(label) return line, ax if __name__ == '__main__': # 会为每一帧调用Update函数 # 这里FunAnimation设置一个10帧动画，每帧间隔200ms anim = FuncAnimation(fig, update, frames=np.arange(0, 10), interval=200) if len(sys.argv) > 1 and sys.argv[1] == 'save': anim.save('line.gif', dpi=80, writer='imagemagick') else: plt.show() 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-03-28 16:46:38 "},"Software/5_PythonAI/MultiPlotInAAxes.html":{"url":"Software/5_PythonAI/MultiPlotInAAxes.html","title":"pyplot在一个坐标系里画多个子图","keywords":"","body":"pyplot在一个坐标系里画多个子图 代码 import numpy as np import matplotlib.pyplot as plt x = np.linspace(0, 10) plt.axes([0.1, 0.5, 0.8, 0.4], ylim=(-1.2, 1.2)) plt.grid(True) plt.plot(np.sin(x)) plt.axes([0.1, 0.1, 0.8, 0.4], ylim=(-1.2, 1.2)) plt.grid(True) plt.plot(np.cos(x)) plt.show() 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-03-28 10:58:59 "},"Software/5_PythonAI/Pytorch/autograd_gradientInPytorch.html":{"url":"Software/5_PythonAI/Pytorch/autograd_gradientInPytorch.html","title":"使用autograd.grad()计算导数与偏导","keywords":"","body":"使用autograd.grad()计算导数与偏导 代码 import torch from torch import autograd x = torch.rand(3, 4) x.requires_grad_() y = torch.sum(x) print(\"-\"*30,\"\\n x= \\n\",x) print(\"-\"*30,\"\\n y= x_1 + x_2 + x_3 +... =\\n\",y) print(\"-\"*30,\"\\n dy/dx= \") print(autograd.grad(outputs=y, inputs=x)[0]) print(\"-\"*30,\"\\n dy/dx= \") print(autograd.grad(outputs=y, inputs=x,grad_outputs=torch.ones_like(y))[0]) y = x[:,0] +x[:,1]**2 print(\"-\"*30,\"\\n x= \\n\",x) print(\"-\"*30,\"\\n y=x[:,0] + x[:,1]**2 =\\n\",y) grad3 = autograd.grad(outputs=y, inputs=x, grad_outputs=torch.ones_like(y), create_graph=True)[0] grad4 = autograd.grad(outputs=grad3, inputs=x, grad_outputs=torch.ones_like(grad3))[0] print(\"-\"*30,\"\\n dy/dx= \") print(grad3) print(\"-\"*30,\"\\n d2y/dx2=\") print(grad4) print(\"-\"*30) 输出为 ------------------------------ x= tensor([[0.6896, 0.3966, 0.2412, 0.5902], [0.0767, 0.2957, 0.2829, 0.3379], [0.1813, 0.3087, 0.8247, 0.9677]], requires_grad=True) ------------------------------ y= x_1 + x_2 + x_3 +... = tensor(5.1931, grad_fn=) ------------------------------ dy/dx= tensor([[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]]) ------------------------------ dy/dx= tensor([[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]]) ------------------------------ x= tensor([[0.6896, 0.3966, 0.2412, 0.5902], [0.0767, 0.2957, 0.2829, 0.3379], [0.1813, 0.3087, 0.8247, 0.9677]], requires_grad=True) ------------------------------ y=x[:,0] + x[:,1]**2 = tensor([0.8468, 0.1642, 0.2765], grad_fn=) ------------------------------ dy/dx= tensor([[1.0000, 0.7931, 0.0000, 0.0000], [1.0000, 0.5914, 0.0000, 0.0000], [1.0000, 0.6174, 0.0000, 0.0000]], grad_fn=) ------------------------------ d2y/dx2= tensor([[0., 2., 0., 0.], [0., 2., 0., 0.], [0., 2., 0., 0.]]) ------------------------------ 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-02-07 16:33:37 "},"Software/5_PythonAI/Pytorch/DevEnvDeploy.html":{"url":"Software/5_PythonAI/Pytorch/DevEnvDeploy.html","title":"Pytorch开发环境搭建","keywords":"","body":"Pytorch开发环境搭建 本安装包的版本搭配 可视化：满足tensorboardX的要求。 使用Pytorch GPU的版本。 包含Tensorflow GPU的版本。 写在前面 要求已搭建好基本的Python环境，如果你未搭建，点我查看如何搭建基本的Python环境。 可视化要求搭建好Tensorflow环境，点我查看如何搭建Tensorflow环境。 系统: Windows Enterprise 10 x64 CPU：Intel(R) Core(TM) i7-8700 CPU @ 3.20GHz GPU: NVIDIA GeForce GTX 1050 Ti 所以本笔记记录Win10 64位系统下，TensorFlow的GPU版开发环境的搭建。 离线安装所需资源列表 tensorflow_gpu-1.10.0-cp36-cp36m-win_amd64.whl，会同时安装tensorboard版本:1.10.0； cuda_9.2.148_win10.exe； cuda_9.2.148.1_windows.exe.exe； pytorch-1.3.1-py3.6_cuda92_cudnn7_0.tar.bz2; torchvision-0.4.1-py36_cu92.tar.bz2; msgpack-0.6.2-cp36-cp36m-win_amd64.whl. 安装步骤： 在电脑任务栏，右键NVIDIA 控制面板>帮助菜单>系统信息>组件选项卡，可以看到显卡驱动支持的CUDA版本号为9.2。 去NVIDIA CUDA 和NVIDIA CUDNN 分别下载CUDA和CUDNN相应的版本：cuda_9.2.148_win10和patch包；以及cudnn7.2。安装CUDA及patch包；然后将解压Cudnn后得到的三个小文件夹(include,bin,lib)复制到CUDA的安装目录(默认安装目录C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.2)即可； 进入PyTorch官网，依次选择你电脑的配置 然后根据配置，去页面选择文件：找到CUDA版本为9.2，Python版本为3.6，平台为Win64的1.3.1版本的cu92/torch-1.3.1%2Bcu92-cp36-cp36m-win_amd64.whl文件,将其下载下来。 安装: 在该whl文件所在目录打开CMD命令行，执行pip install torch-1.3.1-cu92-cp36-cp36m-win_amd64.whl即可。 安装完成后也许会提示msgpack找不到，需要再额外安装一个，去页面，运行pip install msgpack-0.6.2-cp36-cp36m-win_amd64.whl安装好即可。 去为了进行可视化，去页面下载后pip install torchvision-0.4.1-cp36-cp36m-win_amd64.whl进行安装。 环境测试 输入python并回车，进入PYTHON环境，运行以下命令： import torch torch.__version__ # 应该得到结果'1.4.0+cu92' print(torch.cuda.is_available()) # 应该得到结果True 在Visual Studio Code中，只要有Python插件，即可打开后缀名为ipynb和py的Python代码，而且可以执行Python程序。 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-02-07 23:17:05 "},"Software/6_MD/":{"url":"Software/6_MD/","title":"Markdown","keywords":"","body":"内容列表 回到主页 Markdown公式代码大全 Markdown支持绘制脑图啦 使用WaveDrom画时序图或电路图 使用mermaid绘制流程图/脑图 在Markdown中使用FontAwesome 在Markdown中使用Javascript res 资源(右键打开或下载) 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Software/6_MD/EquationInMD.html":{"url":"Software/6_MD/EquationInMD.html","title":"Markdown公式代码大全","keywords":"","body":"Markdown公式代码大全 下面给出了Markdown中的公式代码。 在Word中的Latex公式代码与下面略有不同，详情点我查看 样例 \\LaTeX代码 \\LaTeX {% mathblock %}\\LaTeX{% endmathblock %} \\dot{a} \\ddot{a} \\acute{a} \\grave{a} \\dot{a} \\ddot{a} \\acute{a} \\grave{a} \\check{a} \\breve{a} \\tilde{a} \\bar{a} \\check{a} \\breve{a} \\tilde{a} \\bar{a} \\hat{a} \\widehat{a} \\vec{a} \\hat{a} \\widehat{a} \\vec{a} \\exp_a b=a^b \\exp_a b=a^b \\exp b=e^b \\exp b=e^b \\sin,\\cos,\\tan \\sin,\\cos,\\tan \\sec,\\csc,\\cot \\sec,\\csc,\\cot \\arcsin,\\arccos,\\arctan \\arcsin,\\arccos,\\arctan \\sinh,\\cosh,\\tanh,\\coth \\sinh,\\cosh,\\tanh,\\coth \\arg z \\arg z \\left\\vert a\\right\\vert \\lVert z\\rVert \\left\\vert a\\right\\vert \\lVert z\\rVert \\min x \\max y \\inf s \\sup t \\min x \\max y \\inf s \\sup t \\lim u \\liminf v \\limsup w \\lim u \\liminf v \\limsup w \\dim p \\deg q \\det m \\ker\\phi \\dim p \\deg q \\det m \\ker\\phi dt \\mathrm{d}t \\partial t \\nabla\\psi dt \\mathrm{d}t \\partial t \\nabla\\psi \\prime \\backprime f^\\prime f' f'' f^{(3)} \\dot{y} \\ddot{y} \\prime \\backprime f^\\prime f' f'' f^{(3)} \\dot{y} \\ddot{y} \\infty \\aleph \\complement \\backepsilon \\eth \\Finv \\hbar \\infty \\aleph \\complement \\backepsilon \\eth \\Finv \\hbar \\Im \\imath \\jmath \\Bbbk \\ell \\mho \\wp \\Re \\circledS \\Im \\imath \\jmath \\Bbbk \\ell \\mho \\wp \\Re \\circledS a\\equiv1\\pmod{m} a\\equiv1\\pmod{m} a\\bmod b a\\bmod b \\gcd(m,n) \\operatorname{lcm}(m,n) \\gcd(m,n) \\operatorname{lcm}(m,n) \\mid \\nmid \\shortmid \\nshortmid \\mid \\nmid \\shortmid \\nshortmid \\| \\nmid \\shortmid \\nshortmid \\| \\nmid \\shortmid \\nshortmid a\\%b a\\%b \\surd \\sqrt{2} \\sqrt[n]{} \\sqrt[n]{x} \\surd \\sqrt{2} \\sqrt[n]{} \\sqrt[n]{x} + - \\pm \\mp \\dotplus + - \\pm \\mp \\dotplus \\times \\div \\divideontimes / \\backslash \\times \\div \\divideontimes / \\backslash \\cdot \\ast * \\star \\circ \\bullet \\cdot \\ast * \\star \\circ \\bullet \\boxplus \\boxminus \\boxtimes \\boxdot \\boxplus \\boxminus \\boxtimes \\boxdot \\oplus \\ominus \\otimes \\oslash \\odot \\oplus \\ominus \\otimes \\oslash \\odot \\circleddash \\circledcirc \\circledast \\circleddash \\circledcirc \\circledast \\bigoplus \\bigotimes \\bigodot \\bigoplus \\bigotimes \\bigodot \\{ \\} \\emptyset \\varnothing \\{ \\} \\emptyset \\varnothing \\in \\notin \\not\\in \\ni \\not\\ni \\in \\notin \\not\\in \\ni \\not\\ni \\cap \\Cap \\sqcap \\bigcap \\cap \\Cap \\sqcap \\bigcap \\cup \\Cup \\sqcup \\bigcup \\bigsqcup \\uplus \\biguplus \\cup \\Cup \\sqcup \\bigcup \\bigsqcup \\uplus \\biguplus \\setminus \\smallsetminus \\times \\setminus \\smallsetminus \\times \\subset \\Subset \\sqsubset \\subset \\Subset \\sqsubset \\supset \\Supset \\sqsupset \\supset \\Supset \\sqsupset \\subseteq \\nsubseteq \\subsetneq \\varsubsetneq \\sqsubseteq \\subseteq \\nsubseteq \\subsetneq \\varsubsetneq \\sqsubseteq \\supseteq \\nsupseteq \\supsetneq \\varsupsetneq \\sqsupseteq \\supseteq \\nsupseteq \\supsetneq \\varsupsetneq \\sqsupseteq \\subseteqq \\nsubseteqq \\subsetneqq \\varsubsetneqq \\subseteqq \\nsubseteqq \\subsetneqq \\varsubsetneqq \\supseteqq \\nsupseteqq \\supsetneqq \\varsupsetneqq \\supseteqq \\nsupseteqq \\supsetneqq \\varsupsetneqq = \\ne \\neq \\equiv \\not\\equiv = \\ne \\neq \\equiv \\not\\equiv \\doteq \\doteqdot \\overset{\\underset{def}{}}{=} := \\doteq \\doteqdot \\overset{\\underset{def}{}}{=} := \\sim \\nsim \\backsim \\thicksim \\simeq \\backsimeq \\eqsim \\cong \\ncong \\sim \\nsim \\backsim \\thicksim \\simeq \\backsimeq \\eqsim \\cong \\ncong \\approx \\thickapprox \\approxeq \\asymp \\propto \\varpropto \\approx \\thickapprox \\approxeq \\asymp \\propto \\varpropto > \\ngtr \\gg \\not\\gg \\ggg \\not\\ggg \\gtrdot > \\ngtr \\gg \\not\\gg \\ggg \\not\\ggg \\gtrdot \\le \\leq \\lneq \\leqq \\nleq \\nleqq \\lneqq \\lvertneqq \\le \\leq \\lneq \\leqq \\nleq \\nleqq \\lneqq \\lvertneqq \\ge \\geq \\gneq \\geqq \\ngeq \\ngeqq \\gneqq \\gvertneqq \\ge \\geq \\gneq \\geqq \\ngeq \\ngeqq \\gneqq \\gvertneqq \\lessgtr \\lesseqgtr \\lesseqqgtr \\gtrless \\gtreqless \\gtreqqless \\lessgtr \\lesseqgtr \\lesseqqgtr \\gtrless \\gtreqless \\gtreqqless \\leqslant \\nleqslant \\eqslantless \\leqslant \\nleqslant \\eqslantless \\geqslant \\ngeqslant \\eqslantgtr \\geqslant \\ngeqslant \\eqslantgtr \\lesssim \\lnsim \\lessapprox \\lnapprox \\lesssim \\lnsim \\lessapprox \\lnapprox \\gtrsim \\gnsim \\gtrapprox \\gnapprox \\gtrsim \\gnsim \\gtrapprox \\gnapprox \\prec \\nprec \\preceq \\npreceq \\precneqq \\prec \\nprec \\preceq \\npreceq \\precneqq \\parallel \\nparallel \\shortparallel \\nshortparallel \\parallel \\nparallel \\shortparallel \\nshortparallel \\perp \\angle \\sphericalangle \\measuredangle 45^\\circ \\perp \\angle \\sphericalangle \\measuredangle 45^\\circ \\Box \\blacksquare \\diamond \\Diamond \\lozenge \\blacklozenge \\bigstar \\Box \\blacksquare \\diamond \\Diamond \\lozenge \\blacklozenge \\bigstar \\bigcirc \\triangle \\bigtriangleup \\bigtriangledown \\bigcirc \\triangle \\bigtriangleup \\bigtriangledown \\vartriangle \\triangledown \\triangleleft \\triangleright \\vartriangle \\triangledown \\triangleleft \\triangleright \\blacktriangle \\blacktriangledown \\blacktriangleleft \\blacktriangleright \\blacktriangle \\blacktriangledown \\blacktriangleleft \\blacktriangleright \\forall \\exists \\nexists \\forall \\exists \\nexists \\therefore \\because \\And \\& \\therefore \\because \\And \\& \\bar{q} \\bar{abc} \\overline{q} \\overline{abc} \\bar{q} \\bar{abc} \\overline{q} \\overline{abc} \\Rrightarrow \\Lleftarrow \\Rrightarrow \\Lleftarrow \\Rightarrow \\nRightarrow \\Longrightarrow \\implies \\Rightarrow \\nRightarrow \\Longrightarrow \\implies \\Leftarrow \\nLeftarrow \\Longleftarrow \\Leftarrow \\nLeftarrow \\Longleftarrow \\Leftrightarrow \\nLeftrightarrow \\Longleftrightarrow \\iff \\Leftrightarrow \\nLeftrightarrow \\Longleftrightarrow \\iff \\Uparrow \\Downarrow \\Updownarrow \\Uparrow \\Downarrow \\Updownarrow \\leftarrow \\rightarrow \\nleftarrow \\nrightarrow \\longleftarrow \\longrightarrow \\leftarrow \\rightarrow \\nleftarrow \\nrightarrow \\longleftarrow \\longrightarrow \\leftrightarrow \\nleftrightarrow \\longleftrightarrow \\leftrightarrow \\nleftrightarrow \\longleftrightarrow \\uparrow \\downarrow \\updownarrow \\nearrow \\searrow \\nwarrow \\swarrow \\uparrow \\downarrow \\updownarrow \\nearrow \\searrow \\nwarrow \\swarrow \\mapsto \\longmapsto \\mapsto \\longmapsto \\rightharpoonup \\rightharpoondown \\leftharpoonup \\leftharpoondown \\rightharpoonup \\rightharpoondown \\leftharpoonup \\leftharpoondown \\upharpoonleft \\upharpoonright \\downharpoonleft \\downharpoonright \\upharpoonleft \\upharpoonright \\downharpoonleft \\downharpoonright \\leftrightharpoons \\rightleftharpoons \\leftrightharpoons \\rightleftharpoons \\twoheadrightarrow \\twoheadleftarrow \\twoheadrightarrow \\twoheadleftarrow \\xleftarrow{left} \\xrightarrow{right} \\xleftarrow{left} \\xrightarrow{right} \\xleftrightarrow{left\\& right} \\xleftrightarrow{left\\& right} \\xlongequal[cond1]{cond2} \\xlongequal[cond1]{cond2} \\amalg \\% \\dagger \\ddagger \\ldots \\cdots \\amalg \\% \\dagger \\ddagger \\ldots \\cdots \\diamondsuit \\heartsuit \\clubsuit \\spadesuit \\diamondsuit \\heartsuit \\clubsuit \\spadesuit \\Game \\flat \\natural \\sharp \\Game \\flat \\natural \\sharp {}^2_1\\!X^3_4 {}^2_1\\!X^3_4 \\vec{x} \\overleftarrow{AB} \\overrightarrow{AB} \\widehat{AB} \\vec{x} \\overleftarrow{AB} \\overrightarrow{AB} \\widehat{AB} \\overset{\\frown}{AB} \\overset{\\frown}{AB} \\overline{ABC} \\underline{ABC} \\overline{ABC} \\underline{ABC} \\overbrace{1+2+\\cdots+100} \\overbrace{1+2+\\cdots+100} \\begin{matrix}5050\\\\\\overbrace{1+2+\\cdots+100}\\end{matrix} \\begin{matrix}5050\\\\\\overbrace{1+2+\\cdots+100}\\end{matrix} \\underbrace{1+2+\\cdots+100} \\underbrace{1+2+\\cdots+100} \\begin{matrix}\\underbrace{1+2+\\cdots+100}\\\\5050\\end{matrix} \\begin{matrix}\\underbrace{1+2+\\cdots+100}\\\\5050\\end{matrix} \\sum_{i=1}^na_i \\sum\\limits_{i=1}^na_i \\sum_{i=1}^na_i \\sum\\limits_{i=1}^na_i \\prod_{i=1}^na_i \\prod\\limits_{i=1}^na_i \\prod_{i=1}^na_i \\prod\\limits_{i=1}^na_i \\coprod_{i=1}^na_i \\coprod\\limits_{i=1}^na_i \\coprod_{i=1}^na_i \\coprod\\limits_{i=1}^na_i \\lim_{n\\to\\infty}x_n \\lim\\limits_{n\\to\\infty}x_n \\lim_{n\\to\\infty}x_n \\lim\\limits_{n\\to\\infty}x_n \\int_{-N}^{N}e^x\\,dx \\int_{-N}^{N}e^x\\,dx \\iint_M^Ndx\\,dy \\iint_M^Ndx\\,dy \\iiint_M^Ndx\\,dy\\,dz \\iiint_M^Ndx\\,dy\\,dz \\oint_Cx^3\\,dx+4y^2\\,dy \\oint_Cx^3\\,dx+4y^2\\,dy \\bigcap_1^np \\bigcap\\limits_1^np \\bigcap_1^np \\bigcap\\limits_1^np \\bigcup_1^np \\bigcup\\limits_1^np \\bigcup_1^np \\bigcup\\limits_1^np \\frac{1}{2}=0.5 \\frac{1}{2}=0.5 \\tfrac{1}{2}=0.5 \\tfrac{1}{2}=0.5 \\dfrac{1}{2}=0.5 \\dfrac{1}{x+\\dfrac{3}{y+\\dfrac{1}{5}}} \\dfrac{1}{2}=0.5 \\dfrac{1}{x+\\dfrac{3}{y+\\dfrac{1}{5}}} \\dbinom{n}{m}=\\dbinom{n}{n-m}=C_n^m=C_n^{n-m} \\dbinom{n}{m}=\\dbinom{n}{n-m}=C_n^m=C_n^{n-m} \\tbinom{n}{m}=\\tbinom{n}{n-m}=C_n^m=C_n^{n-m} \\tbinom{n}{m}=\\tbinom{n}{n-m}=C_n^m=C_n^{n-m} \\binom{n}{m}=\\binom{n}{n-m}=C_n^m=C_n^{n-m} \\binom{n}{m}=\\binom{n}{n-m}=C_n^m=C_n^{n-m} \\begin{matrix}a&b\\\\c&d\\end{matrix} \\begin{matrix}a&b\\\\c&d\\end{matrix} \\begin{vmatrix}a&b\\\\c&d\\end{vmatrix} \\begin{vmatrix}a&b\\\\c&d\\end{vmatrix} \\begin{Vmatrix}a&b\\\\c&d\\end{Vmatrix} \\begin{Vmatrix}a&b\\\\c&d\\end{Vmatrix} \\begin{bmatrix}a&\\cdots&b\\\\\\vdots&\\ddots&\\vdots\\\\c&\\cdots&d\\end{bmatrix} \\begin{bmatrix}a&\\cdots&b\\\\\\vdots&\\ddots&\\vdots\\\\c&\\cdots&d\\end{bmatrix} \\begin{Bmatrix}a&c\\\\b&d\\end{Bmatrix} \\begin{Bmatrix}a&c\\\\b&d\\end{Bmatrix} \\begin{pmatrix}a&c\\\\b&d\\end{pmatrix} \\begin{pmatrix}a&c\\\\b&d\\end{pmatrix} f(x)=\\begin{cases}x-1&x\\leqslant3\\\\x^2+3x-1&x>3\\end{cases} f(x)=\\begin{cases}x-1&x\\leqslant3\\\\x^2+3x-1&x>3\\end{cases} \\begin{cases}2x+9y-5z=10\\\\4x+20y+z=24\\\\x-\\dfrac{1}{2}y+3z=8\\end{cases} \\begin{cases}2x+9y-5z=10\\\\4x+20y+z=24\\\\x-\\dfrac{1}{2}y+3z=8\\end{cases} \\begin{aligned}f(x) & = (x + 1)^2 \\\\ & = x^2 + 2x + 1\\end{aligned} \\begin{aligned}f(x) & = (x + 1)^2 \\\\ & = x^2 + 2x + 1\\end{aligned} \\alpha\\beta\\gamma\\delta\\epsilon\\zeta\\eta\\theta \\alpha\\beta\\gamma\\delta\\epsilon\\zeta\\eta\\theta \\iota\\kappa\\lambda\\mu\\nu\\xi\\omicron\\pi \\iota\\kappa\\lambda\\mu\\nu\\xi\\omicron\\pi \\rho\\sigma\\tau\\upsilon\\phi\\chi\\psi\\omega \\rho\\sigma\\tau\\upsilon\\phi\\chi\\psi\\omega \\varepsilon\\digamma\\varkappa\\varpi \\varepsilon\\digamma\\varkappa\\varpi \\varrho\\varsigma\\vartheta\\varphi \\varrho\\varsigma\\vartheta\\varphi \\mathbb{ABCDEFGHI} \\mathbb{ABCDEFGHI} \\mathit{A} \\mathit{A} \\mathtt{ABCDEFGHI} \\mathtt{ABCDEFGHI} \\mathrm{ABCDEFGHI} \\mathrm{ABCDEFGHI} \\mathcal{ABCDEFGHI} \\mathcal{ABCDEFGHI} \\text{x y z} \\text{中文} \\text{x y z} \\text{中文} (\\dfrac{1}{2}) (\\dfrac{1}{x+\\dfrac{2}{3}}) (\\dfrac{1}{2}) (\\dfrac{1}{x+\\dfrac{2}{3}}) \\left(\\dfrac{1}{2}\\right) \\left(\\dfrac{1}{x+\\dfrac{2}{3}}\\right) \\left(\\dfrac{1}{2}\\right) \\left(\\dfrac{1}{x+\\dfrac{2}{3}}\\right) \\left[\\dfrac{1}{2}\\right] \\left[\\dfrac{1}{2}\\right] \\left\\{\\dfrac{1}{2}\\right\\} \\left\\{\\dfrac{1}{2}\\right\\} \\left\\langle\\dfrac{1}{2}\\right\\rangle \\left\\langle\\dfrac{1}{2}\\right\\rangle \\left\\vert\\dfrac{1}{2}\\right\\vert \\left\\vert\\dfrac{1}{2}\\right\\vert \\left\\|\\dfrac{1}{2}\\right\\| \\left\\|\\dfrac{1}{2}\\right\\| \\left\\lfloor\\dfrac{1}{2}\\right\\rfloor \\left\\lfloor\\dfrac{1}{2}\\right\\rfloor \\left\\lceil\\dfrac{1}{2}\\right\\rceil \\left\\lceil\\dfrac{1}{2}\\right\\rceil \\left/\\dfrac{1}{2}\\right/ \\left/\\dfrac{1}{2}\\right/ \\left\\backslash\\dfrac{1}{2}\\right\\backslash \\left\\backslash\\dfrac{1}{2}\\right\\backslash \\left(\\dfrac{1}{2}\\right. \\left(\\dfrac{1}{2}\\right. \\left.\\dfrac{1}{2}\\right] \\left.\\dfrac{1}{2}\\right] xy xy x\\,y x\\,y x\\;y x\\;y x\\ y x\\ y x\\quad y x\\quad y \\qquad y \\qquad y x=\\dfrac{-b\\pm\\sqrt{\\color{Red}b^2-4ac}}{\\color{Blue}2a} x=\\dfrac{-b\\pm\\sqrt{\\color{Red}b^2-4ac}}{\\color{Blue}2a} \\boxed{\\sum\\limits_{i = 1}^{n} i = \\dfrac{n(n - 1)}{2}} \\boxed{\\sum\\limits_{i = 1}^{n} i = \\dfrac{n(n - 1)}{2}} \\color{Blue}\\colorbox{Yellow}{LaTeX公式大全} {% mathblock %}\\color{Blue}\\colorbox{Yellow}{LaTeX公式大全}{% endmathblock %} 另外，表格： \r \\begin{array}\r {|c|c||c|}\r x&y&z\\\\\r 8&2&4\\\\\r 2&3&9\\\\\r 10&\\dfrac{3}{4}&\\sqrt{3}\\\\\r a&b&c\r \\end{array}\r 的代码 \\begin{array} {|c|c||c|} x&y&z\\\\ 8&2&4\\\\ 2&3&9\\\\ 10&\\dfrac{3}{4}&\\sqrt{3}\\\\ a&b&c \\end{array} MathJax.Hub.Config({ TeX: { extensions: [\"extpfeil.js\",\"color.js\",\"mhchem.js\"] }}); 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-02-11 09:39:37 "},"Software/6_MD/PlotMindMap.html":{"url":"Software/6_MD/PlotMindMap.html","title":"Markdown支持绘制脑图啦","keywords":"","body":"Markdown支持绘制脑图啦 使用插件mind-maps 绘制脑图. 代码块标识 mind, 选项有height=300,title=a mind map of something,color # 1 ## 1.1 ### 1.1.1 ## 1.2 # 2 # 3 对应的脑图为 脑图示例 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-01-25 10:38:16 "},"Software/6_MD/PlotTimingDiagram.html":{"url":"Software/6_MD/PlotTimingDiagram.html","title":"使用WaveDrom画时序图或电路图","keywords":"","body":"使用WaveDrom画时序图或电路图 WaveDrom.js是一个JS脚本. VS Code中的使用方法 VS Code的Markdown Preview Enhanced插件已经支持wavedrom.可以直接使用代码块标识wavedrom使用.例如 {signal: [ {name: \"Alfa\", wave: \"01.zx=ud.23.456789\" }, {name: 'clk', wave: 'p.....|P..'}, {name: 'dat', wave: 'x.345x|=.x', data: ['head', 'body', 'tail', 'data']}, {name: 'req', wave: '0.1..0|1.0'}, {name: 'ack', wave: '1.....|01.'} ]} {signal: [ {name: \"Alfa\", wave: \"01.zx=ud.23.456789\" }, {name: 'clk', wave: 'p.....|P..'}, {name: 'dat', wave: 'x.345x|=.x', data: ['head', 'body', 'tail', 'data']}, {name: 'req', wave: '0.1..0|1.0'}, {name: 'ack', wave: '1.....|01.'} ]} Gitbook网页端,不会显示本图.请使用Gitbook中的使用方法 Gitbook中的使用方法 在Markdown文件的末尾放入以下代码 在要插入时序图的位置,插入以下代码 {signal: [ {name: \"Alfa\", wave: \"01.zx=ud.23.456789\" }, {name: 'clk', wave: 'p.....|P..'}, {name: 'dat', wave: 'x.345x|=.x', data: ['head', 'body', 'tail', 'data']}, {name: 'req', wave: '0.1..0|1.0'}, {name: 'ack', wave: '1.....|01.'} ]} 渲染效果: {signal: [ {name: \"Alfa\", wave: \"01.zx=ud.23.456789\" }, {name: 'clk', wave: 'p.....|P..'}, {name: 'dat', wave: 'x.345x|=.x', data: ['head', 'body', 'tail', 'data']}, {name: 'req', wave: '0.1..0|1.0'}, {name: 'ack', wave: '1.....|01.'} ]} 时序图语法 signal元素是波形图的数组,包含若干个波形. 每个波形图至少包含两个域,分别是信号名name和波形数据wave. wave字符串中的每个字符都代表了一个时钟周期. .: 延续上一周期的状态. wave中的字符中,用于时钟信号的值: p: 上升沿开始的时钟信号(50%); P: 带箭头的、上升沿开始的时钟信号(50%); n: 下降沿沿开始的时钟信号(50%); N: 带箭头的、下降沿开始的时钟信号(50%); h: 高电平,如果有跳变,边沿是平的. H: 带箭头的、高电平. l: 低电平,如果有跳变,边沿是平的. L: 带箭头的、低电平. wave中的字符中,用于数据信号的值: 0: 低电平,如果有跳变,边沿是斜的. 1: 高电平,如果有跳变,边沿是斜的. x: 不确定. z: 高阻态. u: exp型上升线. d: exp型下降线. =: 引用data域的字符,背景色为白色. 2: 引用data域的字符,背景色透明. 3/4/5/6/7/8/9: 引用data域的字符,并加不同的背景色 综合 {signal: [ {name: \"Alfa\", wave: \"01.zx=ud.23.456789\" }, {name: 'clk', wave: 'p.....|P..'}, {name: 'dat', wave: 'x.345x|=.x', data: ['head', 'body', 'tail', 'data']}, {name: 'req', wave: '0.1..0|1.0'}, {name: 'ack', wave: '1.....|01.'} ]} 的效果 {signal: [ {name: \"Alfa\", wave: \"01.zx=ud.23.456789\" }, {name: 'clk', wave: 'p.....|P..'}, {name: 'dat', wave: 'x.345x|=.x', data: ['head', 'body', 'tail', 'data']}, {name: 'req', wave: '0.1..0|1.0'}, {name: 'ack', wave: '1.....|01.'} ]} 信号分组 { signal: [ { name: 'clk', wave: 'p..Pp..P'}, ['Master', ['ctrl', {name: 'write', wave: '01.0....'}, {name: 'read', wave: '0...1..0'} ], { name: 'addr', wave: 'x3.x4..x', data: 'A1 A2'}, { name: 'wdata', wave: 'x3.x....', data: 'D1' }, ], ['Slave', ['ctrl', {name: 'ack', wave: 'x01x0.1x'}, ], { name: 'rdata', wave: 'x.....4x', data: 'Q2'}, ] ]} { signal: [ { name: 'clk', wave: 'p..Pp..P'}, ['Master', ['ctrl', {name: 'write', wave: '01.0....'}, {name: 'read', wave: '0...1..0'} ], { name: 'addr', wave: 'x3.x4..x', data: 'A1 A2'}, { name: 'wdata', wave: 'x3.x....', data: 'D1' }, ], ['Slave', ['ctrl', {name: 'ack', wave: 'x01x0.1x'}, ], { name: 'rdata', wave: 'x.....4x', data: 'Q2'}, ] ]} 周期与相位控制 DDR Read transaction时序图的代码 { signal: [ { name: \"CK\", wave: \"P.......\", period: 2 }, { name: \"CMD\", wave: \"x.3x=x4x=x=x=x=x\", data: \"RAS NOP CAS NOP NOP NOP NOP\", phase: 0.5 }, { name: \"ADDR\", wave: \"x.=x..=x........\", data: \"ROW COL\", phase: 0.5 }, { name: \"DQS\", wave: \"z.......0.1010z.\" }, { name: \"DQ\", wave: \"z.........5555z.\", data: \"D0 D1 D2 D3\" } ]} { signal: [ { name: \"CK\", wave: \"P.......\", period: 2 }, { name: \"CMD\", wave: \"x.3x=x4x=x=x=x=x\", data: \"RAS NOP CAS NOP NOP NOP NOP\", phase: 0.5 }, { name: \"ADDR\", wave: \"x.=x..=x........\", data: \"ROW COL\", phase: 0.5 }, { name: \"DQS\", wave: \"z.......0.1010z.\" }, { name: \"DQ\", wave: \"z.........5555z.\", data: \"D0 D1 D2 D3\" } ]} 标题,脚注和缩放 {signal: [ {name:'clk', wave: 'p....' }, {name:'Data', wave: 'x345x', data: 'a b c' }, {name:'Request', wave: '01..0' } ], config: { hscale: 3}, head:{ text:'WaveDrom example', tick:0, }, foot:{ text:'Figure 100', tock:9 }, } {signal: [ {name:'clk', wave: 'p....' }, {name:'Data', wave: 'x345x', data: 'a b c' }, {name:'Request', wave: '01..0' } ], config: { hscale: 3}, head:{ text:'WaveDrom example', tick:0, }, foot:{ text:'Figure 100', tock:9 }, } 带箭头 { signal: [ { name: 'A', wave: '01........0....', node: '.a........j' }, { name: 'B', wave: '0.1.......0.1..', node: '..b.......i' }, { name: 'C', wave: '0..1....0...1..', node: '...c....h..' }, { name: 'D', wave: '0...1..0.....1.', node: '....d..g...' }, { name: 'E', wave: '0....10.......1', node: '.....ef....' } ], edge: [ 'a~b t1', 'c-~a t2', 'c-~>d time 3', 'd~-e', 'e~>f', 'f->g', 'g-~>h', 'h~>i some text', 'h~->j' ] } { signal: [ { name: 'A', wave: '01........0....', node: '.a........j' }, { name: 'B', wave: '0.1.......0.1..', node: '..b.......i' }, { name: 'C', wave: '0..1....0...1..', node: '...c....h..' }, { name: 'D', wave: '0...1..0.....1.', node: '....d..g...' }, { name: 'E', wave: '0....10.......1', node: '.....ef....' } ], edge: [ 'a~b t1', 'c-~a t2', 'c-~>d time 3', 'd~-e', 'e~>f', 'f->g', 'g-~>h', 'h~>i some text', 'h~->j' ] } 组合逻辑电路 { assign:[ [\"out\", [\"|\", [\"&\", [\"~\", \"a\"], \"b\"], [\"&\", [\"~\", \"b\"], \"a\"] ] ] ]} { assign:[ [\"out\", [\"|\", [\"&\", [\"~\", \"a\"], \"b\"], [\"&\", [\"~\", \"b\"], \"a\"] ] ] ]} { assign:[ [\"out\", [\"XNOR\", [\"NAND\", [\"INV\", \"a\"], [\"NOR\", \"b\", [\"BUF\",\"c\"]] ], [\"AND\", [\"XOR\", \"d\", \"e\", [\"OR\",\"f\",\"g\"]], \"h\" ] ] ] ]} { assign:[ [\"out\", [\"XNOR\", [\"NAND\", [\"INV\", \"a\"], [\"NOR\", \"b\", [\"BUF\",\"c\"]] ], [\"AND\", [\"XOR\", \"d\", \"e\", [\"OR\",\"f\",\"g\"]], \"h\" ] ] ] ]} 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-01-28 17:02:32 "},"Software/6_MD/PlotVariousChart.html":{"url":"Software/6_MD/PlotVariousChart.html","title":"使用mermaid绘制流程图/脑图","keywords":"","body":"使用mermaid绘制流程图/脑图 mermaid.js是一个JS脚本. 代码块标识: mermaid mermaid流程图(flowchart)的折线变成贝塞尔曲线: mermaid.min.js中的 flowchart:{... curve:\"linear\"}变成flowchart:{... curve:\"basis\"}. 示例1:节点,连线,子图的样式控制 代码 graph LR; subgraph line A1 --> B1 A2 --- B2 A3 -.- B3 A4 -.-> B4 A5 ==> B5 A6 -- 描述 --- B6 A7 -- 描述 --> B7 A8 -. 描述 .-> B8 A9 == 描述 ==> B9 end subgraph node C1[带文本的矩形] C2(带文本的圆角矩形) C3>带文本的不对称的矩形] C4{带文本的菱形} C5((带文本的圆形)) C1 --> A1 C1 --> A2 C2 --> A2 C3 --> A3 end style C2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5; 对应的流程图 graph LR; subgraph line A1 --> B1 A2 --- B2 A3 -.- B3 A4 -.-> B4 A5 ==> B5 A6 -- 描述 --- B6 A7 -- 描述 --> B7 A8 -. 描述 .-> B8 A9 == 描述 ==> B9 end subgraph node C1[带文本的矩形] C2(带文本的圆角矩形) C3>带文本的不对称的矩形] C4{带文本的菱形} C5((带文本的圆形)) C1 --> A1 C1 --> A2 C2 --> A2 C3 --> A3 end style C2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5; 示例2:统一样式控制 代码 graph LR classDef default fill:#f90,stroke:#555,stroke-width:4px; classDef Cssinput fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray:5,5; classDef Cssprint fill:#ed6,stroke:#333,stroke-width:0px; start(\"fa:fa-twitter start\") --> input[输入A,B,C] input --> conditionA{A是否大于B} conditionA -- YES --> conditionC{A是否大于C} conditionA -- NO --> conditionB{B是否大于C} conditionC -- YES --> printA[输出A] conditionC -- NO --> printC[输出C] conditionB -- YES --> printB[输出B] conditionB -- NO --> printC[输出C] printA --> stop(\"fa:fa-camera-retro end\") printC --> stop printB --> stop class input Cssinput; class printA,printB,printC Cssprint; 对应的图 graph LR classDef default fill:#f90,stroke:#555,stroke-width:4px; classDef Cssinput fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray:5,5; classDef Cssprint fill:#ed6,stroke:#333,stroke-width:0px; start(\"fa:fa-twitter start\") --> input[输入A,B,C] input --> conditionA{A是否大于B} conditionA -- YES --> conditionC{A是否大于C} conditionA -- NO --> conditionB{B是否大于C} conditionC -- YES --> printA[输出A] conditionC -- NO --> printC[输出C] conditionB -- YES --> printB[输出B] conditionB -- NO --> printC[输出C] printA --> stop(\"fa:fa-camera-retro end\") printC --> stop printB --> stop class input Cssinput; class printA,printB,printC Cssprint; 使用mermaid.js绘制序列图 代码 sequenceDiagram participant Alice participant Bob Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight against hypochondria end Note right of John: Rational thoughts prevail! John-->>Alice: Great! John->>Bob: How about you? Bob-->>John: Jolly good! 对应的序列图为 sequenceDiagram participant Alice participant Bob Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight against hypochondria end Note right of John: Rational thoughts prevail! John-->>Alice: Great! John->>Bob: How about you? Bob-->>John: Jolly good! 使用mermaid.js画甘特图 代码: gantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid excludes weekdays 2014-01-10 section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d 对应的甘特图为: gantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid excludes weekdays 2014-01-10 section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d 使用mermaid.js画日程图 journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me 对应的图 journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me 使用mermaid.js画饼图 代码 pie title Pie Chart \"Dogs\" : 386 \"cats\" : 567 \"rabbit\" : 700 \"pig\":365 \"tiger\" : 15 对应的饼图: pie title Pie Chart \"Dogs\" : 386 \"cats\" : 567 \"rabbit\" : 700 \"pig\":365 \"tiger\" : 15 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-01-26 09:13:13 "},"Software/6_MD/UseFontAwesomeInMD.html":{"url":"Software/6_MD/UseFontAwesomeInMD.html","title":"在Markdown中使用FontAwesome","keywords":"","body":"在Markdown中使用FontAwesome 准备 要在 Markdown 文档中输入 Font Awesome，需要在文档中任意位置贴粘入如下语句（可以放在文档结尾处，以不影响直接在 Markdown 文档中的阅读）. 获取符号名称 在符号列表中搜索,获得符号编码. 之后就可以直接插入了,代码    符号格式 尺寸 可选项fa-xs,fa-sm,fa-lg,fa-2x,fa-3x,...,fa-10x    转动    首字下沉 Ais the first letter in alphabet. Ais the first letter in alphabet. 文末彩蛋 两张并排的图片 对应的显示 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-01-26 21:28:04 "},"Software/6_MD/UseJavascriptInMD.html":{"url":"Software/6_MD/UseJavascriptInMD.html","title":"在Markdown中使用Javascript","keywords":"","body":"在Markdown中使用Javascript 在VS code的Markdown Preview Enhanced中,不会实时渲染,但是在Gitbook生成的html中已经可以实时渲染. 插入wavedrom时序图 在Markdown文件的末尾放入以下代码 在要插入时序图的位置,插入以下代码 {signal: [ {name: \"Alfa\", wave: \"01.zx=ud.23.456789\" }, {name: 'clk', wave: 'p.....|P..'}, {name: 'dat', wave: 'x.345x|=.x', data: ['head', 'body', 'tail', 'data']}, {name: 'req', wave: '0.1..0|1.0'}, {name: 'ack', wave: '1.....|01.'} ]} 渲染效果: {signal: [ {name: \"Alfa\", wave: \"01.zx=ud.23.456789\" }, {name: 'clk', wave: 'p.....|P..'}, {name: 'dat', wave: 'x.345x|=.x', data: ['head', 'body', 'tail', 'data']}, {name: 'req', wave: '0.1..0|1.0'}, {name: 'ack', wave: '1.....|01.'} ]} 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-02-06 14:43:33 "},"Software/7_HCJ/":{"url":"Software/7_HCJ/","title":"HTML/CSS/Javascript","keywords":"","body":"内容列表 回到主页 HTML的基础知识 把博客园装饰得美丽大方 HBuilderX 1-引言 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Software/7_HCJ/1_HTMLBasics.html":{"url":"Software/7_HCJ/1_HTMLBasics.html","title":"HTML的基础知识","keywords":"","body":"HTML的基础知识 (Hyper Text Markup Language, 超文本标记语言) 内容概要 饭后甜点 HTML速查 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-15 17:36:00 "},"Software/7_HCJ/DecorateYourCnblogs.html":{"url":"Software/7_HCJ/DecorateYourCnblogs.html","title":"把博客园装饰得美丽大方","keywords":"","body":"把博客园装饰得美丽大方 使用Github 开源项目 装点你的博客园. 以下是安装 步骤: 本主题需要JS权限，没有的请先在博客园管理后台申请权限。 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2020-12-31 14:48:07 "},"Software/7_HCJ/HBuilderXTutorial_1_Introduction.html":{"url":"Software/7_HCJ/HBuilderXTutorial_1_Introduction.html","title":"HBuilderX 1-引言","keywords":"","body":"HBuilderX 1-引言 要做一款安卓APP,咱们得先学安卓开发语言,例如java,前端后端。那么没有这些开发语言基础,咱们怎么做呢？其实现在有比较好的开发方案就是做webAPP,咱们可以用web前端知识构建安卓客户端,用php构建服务端。 html+css+js+Hbuilder开发一款安卓APP,根本不用学Android开发！ html负责页面内容,js负责效果以及调用原生app方法,ui框架负责样式! html负责页面内容,js负责效果以及调用原生app方法,ui框架负责样式! html负责页面内容,js负责效果以及调用原生app方法,ui框架负责样式! HBuilderX可以将html+js+ui打包成apk或者ipa,制作安卓/苹果安装包. 类似的Electron可以将html+js+ui打包成exe,在桌面运行. 预备知识 html+css+js基础知识,这是web前端开发最基础的 php后端,mysql数据库基础知识 HbuilderX,这是一款IDE,集成代码编辑器,运行,真机模拟,调试等工具,还支持在线打包,也就是说你不用配置什么java开发环境就可以开发安卓软件,戳这里下载软件 前端UI框架,本次教程我使用的是谷歌的MDUI框架,请戳这里下载 当然,如果学习能力强,以上都不是问题.你可以直接下手搞! 开始HBuilderX之旅 先打开HbuilderX（以下简称HB） 创建一个webapp工程(也就是移动App),空模板就行; 可以创建在桌面,然后就可以看到整个工程的目录了,但系统默认生成的文件,可以删掉,留下一个manifest.json; 然后把我们提前下载好的前端UI所有文件Copy进来,我用的是MDUI; 将此文件夹压缩成zip,方便以后使用,解压就可以用; 如果需要JRE(Java Runtime Environment)环境,自己安装后添加PATH变量即可; 打开HBuilder之后默认会有一个项目\"HelloHBuilder\",里面有HBuilder使用的介绍; 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-07 22:31:47 "},"Software/8_H5App/":{"url":"Software/8_H5App/","title":"HTML5移动/桌面APP","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Software/9_QML/":{"url":"Software/9_QML/","title":"QML(不建议学习)","keywords":"","body":"内容列表 回到主页 Qt Quick开发教程1:安卓开发环境的配置 Qt Quick开发教程2:QML语法 Qt Quick开发教程3:导出C++到QML Qt Quick开发教程4:设计规则与流程 Qt Quick开发教程5:动画 建立自己的QML Style Sheet文件 Qt 5.15在的部署过程 assets 资源(右键打开或下载) DesignRules_print.pdf QML_tutorials.zip 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Software/9_QML/QtQuickTutorial_1_DevEnvDeploy.html":{"url":"Software/9_QML/QtQuickTutorial_1_DevEnvDeploy.html","title":"Qt Quick开发教程1:安卓开发环境的配置","keywords":"","body":"Qt Quick开发教程1:安卓开发环境的配置 Qt Widget已发展成熟，但不适合在移动设备(Android 手机、平板)上使用。Qt Quick使用QML的开发方式。 现在对Android开发环境进行配置1。 所需文件: Java SE Development Kit (JDK) version 6, or later. You can also use OpenJDK on Linux. Gradle for building application packages for Android devices (APK). Gradle is delivered with Qt 5.9, and later. Because Gradle scripts are not delivered with Android SDK Tools since version 26.0.0, they are delivered with Qt 5.9 and 5.6.3. Note: Using Ant to build APKs is no longer supported.。 A tool chain for building applications for Android devices provided by the Android NDK from Google. Android SDK Tools Platform tools Build tools At least one SDK platform Android Debug Bridge (ADB) driver on the Windows platform to enable USB debugging. The default USB driver on Windows does not allow debugging. After installing the driver, try running a few basic adb commands to check it. 这里使用的分别是： qt-opensource-windows-x86-5.11.0.exe jdk-8u171-windows-x64.exe; gradle-4.4-all.zip; android-ndk-r17-windows-x86_64.zip android-sdk_r24.4.1-windows.zip adb driver.Qt的安装 安装JDK和JRE 配置一下环境变量: JAVA_HOME 值： C:\\Program Files\\Java\\jdk1.8.0_171 CLASSPATH 值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; 安装完成后，在命令行中输入java -version和javac -version，可以查看安装的版本。如果不显示版本号，则未安装完成，可能是环境变量未设置好。安装Gradle2 下载好gradle-4.4-all.zip，然后解压到D:/Programs/Gradle目录。 配置环境变量PATH，添加目录D:/Programs/Gradle。 在命令行中输入gradle -v查看版本号，以验证安装完成。安装NDK 直接解压到D:\\Program\\Android_NDK即可。安装Android sdk 将android-sdk_r24.4.1-windows.zip直接解压到D:\\Program\\Android_SDK即可。 配置一下环境变量: ANDROID_HOME 值： D:\\Program\\Android_SDK\\android-sdk-windows 双击SDK Manager.exe，Option里选择HTTP代理地址为mirrors.neusoft.edu.cn，端口为80，勾选\"Force HTTPS\"选项，然后安装你需要的SDK Tools,SDK Platform-tools,SDK platform及Android ..(API 2),安装Android Support Repository，Google Repository和Google USB Driver，Emulator等。 如果双击时一闪而过，请将android-sdk_r24.4.1-windows.zip再重新解压到该目录，冲突文件进行覆盖。 现在的Android SDK Tools版本为24.4.1，不要更新，以免Qt不兼容。安装ADB driver 该驱动用于调试，安装后方可以连接手机进行调试。 安装后在命令行运行adb　version进行检查。 配置Qt 打开Qt creator，工具>>选项>>设备； 添加Android SDK路径； 添加Android NDK路径； 添加JDK路径。 工具>>选项>>构建与运行 测试环境 新建工程：Qt Quick Application - Empty>>Build system选择qmake，选择构建套件(Kits)，这里将Desktop和Android都勾选。 将main.qml更改为： ```xml import QtQuick 2.9 import QtQuick.Window 2.2 Window { visible: true width: 640 height: 480 title: qsTr(\"Hello World\") Text { anchors.centerIn: parent text: qsTr(\"Hello Android\") } MouseArea { anchors.fill: parent onClicked: Qt.quit() } } ``` 左下角按钮先选择在Desktop上构建；试运行。 连接手机打开调试，选择在Android上构建；运行。 如果出现要下载gradle-3.4-bin.zip的情况，将其复制到C:\\Users\\CharleeChan.gradle\\wrapper\\dists\\gradle-3.4-bin\\aeufj4znodijbvwfbsq3044r0。 如果你的手机是Android 9版本，可以按以下设置。 可以下载教程示例工程同步学习. 1. https://doc.qt.io/qtcreator/creator-developing-android.html ↩ 2. https://gradle.org/install/ ↩ 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-06 17:12:50 "},"Software/9_QML/QtQuickTutorial_2_QML_Basics.html":{"url":"Software/9_QML/QtQuickTutorial_2_QML_Basics.html","title":"Qt Quick开发教程2:QML语法","keywords":"","body":"Qt Quick开发教程2:QML语法 可以下载教程示例工程同步学习. // 下面是导入语句 import QtQuick 2.9 import QtQuick.Window 2.2 /* QML文档可以看做是一个QML对象树,这里创建了Window根对象 和它的子对象Text */ Window { visible: true width: 640 height: 480 title: qsTr(\"Hello World\") Text { id: text1 text: qsTr(\"hello QML!\") } } import语句 使用QML需要导入QtQuick模块。 如果需要使用Window，则还要导入QtQuick.Window 模块 版本号指示了本代码使用的Qt模块版本，Qt模块的版本是向下兼容的。 QML数据类型 基本类型 int,string等你熟悉的类型和QML模块自带的基本类型如date,point,rect,size等类型。 QML对象类型 定义一个对象：类型名称{对象特性}。对象中可以包含其他对象。如，上面代码中Window对象中包含了一个Text对象。 JavaScript类型 QML支持JavaScript对象和数组，可以通过var 类型创建并存储任何标准的JavaScript类型。 import QtQuick 2.0 Item { property var theArray: [] property var theDate: new Date() Component.onCompleted: { for (var i = 0; i 属性 每个对象可以有一或多个属性。 属性:值的写法可以给属性赋值，可以是静态值，也可以是表达式。 每个属性的值可以使用本对象的值计算，也可用其他对象的值参与计算 注意，每个对象都有一个id，你可以理解为一个对象的id是它特殊的属性。例如前面代码中Text 对象的 id 为 text1，所以可以在其他对象中通过 text1.text 来获取 Text 对象中的 text 属性的值,但无法通过text1.id 来获取 id 的值。 注释 注释的写法与C++相似。 单行注释：// 多行注释：/和/ 布局 QML的主要功能是用来布局的，它将替代ui_mainwindow.ui进行UI的渲染。 anchors: 将对象锚定 anchors是一种对象的类。它可用的属性有： 属性 值的类型 举例 anchors.top AnchorLine obj1.bottom - 将其的top与对象obj1的bottom锚定在一起 anchors.bottom AnchorLine obj1.bottom - 将其的top与对象obj1的bottom锚定在一起 anchors.left AnchorLine obj1.left - 将其的left与对象obj1的left锚定在一起 anchors.right AnchorLine obj1.left - 将其的right与对象obj1的left锚定在一起 anchors.horizontalCenter AnchorLine obj1.horizontalCenter - 将其的horizontalCenter与对象obj1的horizontalCenter锚定在一起 anchors.verticalCenter AnchorLine obj1.horizontalCenter - 将其的verticalCenter与对象obj1的verticalCenter锚定在一起 anchors.baseline AnchorLine anchors.fill Item parent - 将其父对象填充 anchors.centerIn Item parent - 表示在其父对象的中心 anchors.margins real anchors.topMargin real anchors.bottomMargin real anchors.leftMargin real anchors.rightMargin real anchors.horizontalCenterOffset real anchors.verticalCenterOffset real anchors.baselineOffset real anchors.alignWhenCentered bool 测试 import QtQuick 2.9 import QtQuick.Window 2.2 Window { visible: true width: 640 height: 480 title: qsTr(\"Hello World\") Text { id: text1 anchors.centerIn: parent text: qsTr(\"Hello Android\") font.bold: true font { pointSize: 14; capitalization: Font.AllUppercase } Behavior on rotation { NumberAnimation { duration: 500 } } } Rectangle { id: colorRect width: 20 * 2 height: width radius: 20 border.color: \"green\" anchors.left: text1.right anchors.leftMargin: 10 anchors.verticalCenter: text1.verticalCenter MouseArea { anchors.fill: parent onClicked: { console.debug(\"colorRect: \", parent.border.color) text1.rotation += 360 text1.color = parent.border.color } } Rectangle { width: 12 * 2 height: width radius: 12 color: parent.border.color anchors.centerIn: parent } } } 测试一下上述代码的效果。 添加图片 在源码目录放置文件夹images，将图片放置其中。在qml.qrc上右键选择Open in Editor，添加资源。 然后在qml文件中添加以下代码： Image { id: backImg source: \"images/bg1.png\" width: parent.width anchors.bottom: parent.bottom fillMode: Image.PreserveAspectFit //缩放时保留宽高比 } 自定义对象类型 在项目里右键/，添加新文件，选择Qt类，然后选择QML File。文件名为ColorText。 然后将下列代码拷贝进去。 import QtQuick 2.9 Item { id: root Text { id: text1 anchors.centerIn: parent text: qsTr(\"Hello Android\") font.bold: true font { pointSize: 14; capitalization: Font.AllUppercase } Behavior on rotation { NumberAnimation { duration: 500 } } } Rectangle { id: colorRect width: 20 * 2 height: width radius: 20 border.color: \"green\" anchors.left: text1.right anchors.leftMargin: 10 anchors.verticalCenter: text1.verticalCenter MouseArea { anchors.fill: parent onClicked: { console.debug(\"colorRect: \", parent.border.color) text1.rotation += 360 text1.color = parent.border.color } hoverEnabled: true onEntered: { parent.width = 32 parent.color = \"black\" } onExited: { parent.width = 40 parent.color = \"white\" } } Rectangle { width: 12 * 2 height: width radius: 12 color: parent.border.color anchors.centerIn: parent } } } 在main.qml中添加以下代码： import QtQuick 2.9 import QtQuick.Window 2.2 Window { visible: true width: 640 height: 480 title: qsTr(\"Hello World\") ColorText { anchors.centerIn: parent } } 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-06 17:13:13 "},"Software/9_QML/QtQuickTutorial_3_QML_CPP.html":{"url":"Software/9_QML/QtQuickTutorial_3_QML_CPP.html","title":"Qt Quick开发教程3:导出C++到QML","keywords":"","body":"Qt Quick开发教程3:导出C++到QML 元对象系统(Meta-Object System)：只要一个CPP类进入了元对象系统，类的方法和属性就可以在QML中访问。 1 导出 类 到QML 要导出的类需要有以下这种形式： class QQuickText : public QQuickImplicitSizeItem //必须继承自QObject类或QObject派生类 { Q_OBJECT //必须使用Q_OBJECT宏 Q_PROPERTY(type name READ getFunction WRITE setFunction RESET resetFunction NOTIFY notifySignal) Q_PROPERTY(QString text READ text WRITE setText NOTIFY textChanged) /*定义元对象系统可访问的属性,定义了一个类型为QString的名为text的属性, 通过text()和setText()进行访问和赋值,当text的内容改变,用户要触发textChanged信号,以通知QML该属性已改变*/ Q_PROPERTY(QFont font READ font WRITE setFont NOTIFY fontChanged) //... public: QQuickText(QQuickItem *parent=0); ~QQuickText();//构造函数与析构函数 enum HAlignment { AlignLeft = Qt::AlignLeft, AlignRight = Qt::AlignRight, AlignHCenter = Qt::AlignHCenter, AlignJustify = Qt::AlignJustify }; Q_ENUM(HAlignment) //定义元对象系统可访问的枚举类型 QString m_text; //text()和setText()不能被QML访问 QString text() const{ return m_text; } void setText(const QString & text) { m_text = text; emit textChanged(); } //... //doLayout()可被QML访问 Q_INVOKABLE void doLayout(); // ### Qt 6: remove //所有signals均可以被QML访问 signals: //... //所有slots均可以被QML访问 slots: //... } 类实现完成之后，一般在main.cpp里进行注册 //qmlRegisterType(\"uri\",1,0,\"qmlName\"); qmlRegisterType(\"PackageName\",1,0,\"qmlName\"); 要在QML中使用，还需要再QML文件中导入： import PackageName 1.0 Rectangle{ width:360 height:360 qmlName{ id:... //PropertyName: text:... } } 2 导出 对象/变量 到QML 以下是将Cpp中名为objectName2的对象/变量导出到QML中objectName1的步骤： 1 注册属性: 在main.cpp中engine.load...之前添加一句: engine.rootContext()->setContextProperty(\"objectName1\",objectName2); 2 使用属性： 导出的属性可以直接使用，与属性关联的对象，它的信号，槽，可调用方法，属性均可以在QML使用。 导出QML到C++ 要在C++中使用QML, import QtQuick 2.2 import QtQuick.Controls 1.2 import QtQuick.Window 2.1 Window{ obejectName: \"rootObject\" width: 360 height: 360 visible: true Text{ objectName: \"textLabel\" text: \"Hello World\" anchors.centerIn: parent font.pixelSize: 26 } Button{ anchors.right: parent.right anchors.rightMargin: 4 anchors.bottom: parent.bottom anchors.bottomMargin: 4 text: \"exit\" objectName: \"quitButton\" } } 在Cpp中将通过对象名objectName来访问其属性。 要访问该页面的rootObject及其他Object，一般在main.cpp中实现： //Step1: 找rootObject QObject *root = NULL; QList rootObjects = engine.rootObjects(); int count = rootObjects.size(); for(int i=0;iobjectName() == \"rootObject\") { root = rootObjects.at(i); break; } } //Step2: 找object QObject *quitButton = root->findChild(\"quitButton\"); //Step3: Process if(quitButton) { QObject::connect(quitButton, SIGNAL(clicked(),&app,SLOT(quit()))); } //Step2: 找Object QObject *textLabel = root->findChild(\"textLabel\"); //Step3: Process if(textLabel) { textLabel->setProperty(\"color\", QColor::fromRgb(255,0,0)); bool bRet = QMetaObject::invokeMethod(textLabel,\"doLayout\"); } 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-01-29 08:47:14 "},"Software/9_QML/QtQuickTutorial_4_QML_DesignRules.html":{"url":"Software/9_QML/QtQuickTutorial_4_QML_DesignRules.html","title":"Qt Quick开发教程4:设计规则与流程","keywords":"","body":"Qt Quick开发教程4:设计规则与流程 QML支持的函数: Math.round(5*1.3),Qt.quit(),qsTr(“myButton”),console.log(\"hello\"),Screen.width, Image类中: 使用变量progress查询加载进度; 变量Image.status(值为ready表示图片已加载); QML界面设计规则 一般顶层的Rectangle的ID为root; .qmlproject可以设置QML文件,JS文件及图片文件的目录 QML 的窗体界面设计如下: 下面对其中的内容进行详细介绍: Window :window: 主窗体 属性 W:640 H:480 方法 onCompleted,window创建完成时会调用,如window.showMaximized. ScrollView:mainView: 主窗体的视图格式,可以是ScrollView,Stacked View,Flickable. 属性 W:1.W H:1.H Item:mainContent: 属性 W:1.W H:6.H+7.H+200 Item:leftMargin: 属性 W:3.marginWidth Item:rightMargin: 属性 W:3.marginWidth Text:header: 属性 W:contentWidth,H:contentHeight,text,color,font,Anchors{top,bottom,horizontalCenter} Column:mainLayout: 属性 Anchors{top,topMargin,left,right},spacing 其他 Grid:subLayout,spacing,columns import QtQuick 2.12 import QtQuick.Window 2.12 import QtQuick.Controls 2.14 import \"flatui\" as Flat //import the ui library //Platform Title1 Title2 NromalText marginWidth spacing Screen.Size //Win 50 30 18 100 50 1920*1080 //Android 30 24 16 5 30 **** //层次如下: Window >> Flickable/ScrollView >> Item(mainContent) >> header+leftMargin+rightMargin+Column(mainLayout) //mainLayout中尽量只使用Flow布局和Column布局,如果需要使用Row布局,其中尽可能只包含一个Child,避免安卓上的不适配 Window { id: window visible: true width: 680 height: 480 property int title1Size: (Qt.platform.os == \"android\")?30:50 property int title2Size: (Qt.platform.os == \"android\")?24:30 property int normalTextSize: (Qt.platform.os == \"android\")?16:18 property int spacingSize: (Qt.platform.os == \"android\")?30:50 Flickable{ width: mainContent.width height: window.height contentHeight: mainContent.height contentWidth: Math.min(window.width,Screen.width) Item { id: mainContent width: Math.min(window.width,Screen.width) height: header.height + mainLayout.height + 200 readonly property int marginWidth: (Qt.platform.os == \"android\")?5:100 Item { id: leftMargin anchors.left: parent.left anchors.top: parent.top anchors.bottom: parent.bottom width: parent.marginWidth } Item { id: rightMargin anchors.right: parent.right anchors.top: parent.top anchors.bottom: parent.bottom width: parent.marginWidth } Text { id: header anchors.horizontalCenter: parent.horizontalCenter anchors.top: parent.top anchors.bottomMargin: 10 text: \"Flat UI\" width: contentWidth height: contentHeight color: Flat.FlatUI.midnightBlue font { family: Flat.FlatUI.latoBlackFont.name bold: true pointSize: window.title1Size } } Column { id: mainLayout anchors.top: header.bottom anchors.topMargin: 30 anchors.left: leftMargin.right anchors.right: rightMargin.left spacing: window.spacingSize Text { text: \"Basic elements\" width: contentWidth height: contentHeight color: Flat.FlatUI.midnightBlue font { family: Flat.FlatUI.latoRegularFont.name bold: true pointSize: window.title2Size } } Text { text: \"Buttons\" width: contentWidth height: contentHeight color: Flat.FlatUI.midnightBlue font { family: Flat.FlatUI.latoRegularFont.name bold: true pointSize: window.normalTextSize } } //Flow's Usage: Must Specify the width so that it can wrap. Flow{ layoutDirection: Qt.LeftToRight spacing: window.spacingSize width: parent.width //flow: width > height ? GridLayout.LeftToRight : GridLayout.TopToBottom Flat.PrimaryButton { text: \"FileDialog\" } Flat.PrimaryButton{} } } } } } 常用的控件类及其属性、信号、方法等 Anchors includes: top, topMargin, horizontalCenter Text includes:id, text, anchors, font.pixelSize, horizontalAlignment, color TextInput includes:id, anchors, onAccepted, text,font.pixelSize, horizontalAlignment, color MouseArea includes:id, anchors, onClicked (,hoverEntered)(,onEntered)(,onExited) Rectangle includes:id,width,height,color(,x)(,y)(,anchors)(border.color)(border.width)(radius)(,Text)(,MouseArea) Image includes:id,source,sourceSize.height,sourceSize.width,anchors,onProgressChanged,onStatusChanged(,Text)(,MouseArea) AnimatedImage includes:id,source,(x),(y),anchors,onProgressChanged,onStatusChanged(,Text)(,MouseArea) Flickable(滚动条) includes:id,width,height(滚动区域), contentWidth, contentHeight(要滚动的内容), contentY(当前显示内容相对于Flickable区域左上角的Y offset值), 垂直滚动的设置: Math.min(contentHeight-height, Math.max(0,player.y-height/2))), boundsBehavior: Flickable.StopAtBounds, interactive: true Item的所有子类: AnimatedSprite, BorderImage, Canvas, Column, ColumnLayout, Flickable, Flipable, Flow, FocusScope, Grid, GridLayout, Image, Loader, MouseArea, MultiPointTouchArea, ParticlePainter, PathView, PinchArea, Rectangle, Repeater, Row, RowLayout, ShaderEffect, ShaderEffectSource, Shape, SignalSpy, SpriteSequence, StackLayout, TestCase, Text, TextEdit, and TextInput. 自定义控件类 自定义Item includes: 先定义属性(property bool/string/int/double [属性名]:初始值),信号(signal buttonClicked,使用时直接buttonClicked()即触发信号), 再实例化内部需要的其他控件. 使用自定义Item: 控件类名(=自定义Item所在文件名){… 设置属性…,… 实现槽函数onButtonClicked:{console.log(“I’m slot”)} } 快速例化 Repeater类:包含一个model和一个delegate,model常为数值(例如5),delegate可以是任意Item类. Repeater一般被包含在Row,Column,Grid类的实例中，生成一行/列/框相类似的Item. 其他Trick 系统窗口的渐变色gradient: Gradient{GradientStop{position:0.9;color:Qt.darker(palette.window, 1.8)} SystemPalette 使用系统自带配色 Loader 加载页面(*.qml),Timer 定时器,并行动画ParallelAnimation,顺序动画SequentialAnimation XmlListModel使用互联网API生成线性Model (属性title和pubDate可直接被View访问) import QtQuick 2.0 import QtQuick.XmlListModel 2.0 XmlListModel { id: xmlModel source: \"http://www.mysite.com/feed.xml\" query: \"/rss/channel/item\" XmlRole { name: \"title\"; query: \"title/string()\" } XmlRole { name: \"pubDate\"; query: \"pubDate/string()\" } } 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-06 22:18:02 "},"Software/9_QML/QtQuickTutorial_5_QML_Animation.html":{"url":"Software/9_QML/QtQuickTutorial_5_QML_Animation.html","title":"Qt Quick开发教程5:动画","keywords":"","body":"Qt Quick开发教程5:动画 第一种-Behavior on property 第1种动画实现的方式 Behavior on property:当属性的值发生变化时,将会触发下面的动作 Behavior on scale{ NumberAnimation{ //持续800ms duration: 800 easing.type:Easing.OutBounce } } 第二种 动画实现的方式 PropertyAnimation是用来为属性提供动画的最基本的动画元素，可以用来为 real 、 int 、 color 、 rect 、 point 、 size 和 vector3d 等属性设置动画， NumberAnimation 、colorAnimation 、 RotationAnimation 和 Vector3dAnimation 等元素继承。 NumberAnimation 对 real 和 int 属性提供了更高效的实现； Vector3dAnimation 对 vector3d 属性提供了更高效的支持； ColorAnimation 和 RotationAnimation 分别对 color 和 rotation 属性变化动画提供了特定的属性支持。 在需要触发时进行 scaleAnimation.start() 即可 PropertyAnimation{ id:scaleAnimation target: imageOfElement property: \"scale\" from:0 to:1 duration: 1000 easing.type: Easing.OutBack } //NumberAnimation修改某属性的数值 NumberAnimation{ id:opacityAnimation target: imageOfElement property: \"opacity\" from:0 to:1 duration: 2800 easing.type: Easing.OutBack } 第三种 使用状态机分别写状态和跳转 State 中实现 AnchorChanges , PropertyChanges 等的赋值 Transition 中实现状态跳转时发生的动画,如果只有一 State,则只有一个 Transition 跳转条件:在需要触发处对rect2.state赋值即可 Rectangle{ id: rect2 width: Screen.width/2 height: Screen.height/12 color:\"transparent\" radius: 20 states: [ State { name: \"ENTERED\" PropertyChanges { target: rect2 color:\"orange\" } }, State { name: \"EXITED\" PropertyChanges { target: rect2 color:\"transparent\" } } ] transitions: [ Transition { from: \"EXITED\" to: \"ENTERED\" ColorAnimation {target:rect2;duration: 1200} }, Transition { from: \"ENTERED\" to: \"EXITED\" ColorAnimation{ target: rect2; duration:1200} } ] } 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-06 17:40:13 "},"Software/9_QML/QtQuickTutorial_6_QML_StyleSheet.html":{"url":"Software/9_QML/QtQuickTutorial_6_QML_StyleSheet.html","title":"建立自己的QML Style Sheet文件","keywords":"","body":"建立自己的QML Style Sheet文件 可以通过建立自定义的Style Sheet文件,来管理各个不同页面(QML)的风格. 具体方法是, 在要定义样式的QML脚本中使用pragma Singleton,声明这是一个单例文件. 将该样式的组件定义为单例; 导入到要使用的QML界面中. 下面是一个实例. 声明一个单例的样式QML脚本文件 //MyStyleObject.qml pragma Singleton import QtQuick 2.0 Item { readonly property string colourBlue: \"blue\" readonly property string colourRed: \"red\" readonly property int fontPointSize: 16 } 注册单例组件 两个方法:在C++代码中注册;或者使用qmldir文件注册.本着前后端尽量分离的原则,建议使用第二种. 第一个方法: #include ... qmlRegisterSingletonType( QUrl(\"file:///absolute/path/MyStyleObject.qml\"), \"ca.imaginativethinking.tutorial.style\", 1, 0, \"MyStyle\" ); ... 第二个方法:在MyStyleObject.qml所在目录添加一个qmldir文件: 当import一个目录时,QML Engine会首先查找qmldir文件,并根据该目录导入相应的脚本文件. 如果目录结构如下所示: /root + absolute | + path | | + qmldir | | + MyStyleObject.qml | | + AnotherObject.qml | | + MyButton.qml | | + MySwitch.qml | + main.qml 相应的qmldir文件的内容: singleton MyStyle 1.0 MyStyleObject.qml MyOtherObject 1.0 AnotherObject.qml MyButton 1.0 MyButton.qml 注意,虽然qmldir中没写MySwitch.qml,但仍然会按默认的设置进行导入. 导入并使用单例 如果使用C++注册的方法,则需要在QML脚本中导入qmlRegisterSingletonType函数的第2个形参(包名). 如果使用qmldir的方法,只需要导入该目录即可 import QtQuick 2.0 import \"path\" Rectangle { anchors.fill: parent color: MyStyle.colourBlue // 注意:即使main.qml在此path目录中,你仍然需要导入该目录import \"path\",因为自动导入系统中不会读取qmldir. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-07 11:13:50 "},"Software/9_QML/QtQuickTutorial_7_DevEnvDeploy.html":{"url":"Software/9_QML/QtQuickTutorial_7_DevEnvDeploy.html","title":"Qt 5.15在的部署过程","keywords":"","body":"Qt 5.15在的部署过程 警告：从 Qt 5.15 起，开源用户需自已编译 构建二进制安装包。 具体可参考http://dts.digitser.cn/zh-CN/download/qt.html#qt5. 注意:想一下为什么Qt会趋向于QML? 这是因为基于html+js+css的设计模式已经改变了世界了. 现在你还会学QML吗? 学Qt只需要学Qt4的核心功能,只用于单机 以及 嵌入式应用. 一旦涉及到互联网,请有限考虑html+js+css. 本教程不再更新. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-07 21:51:19 "},"Tricks/Game/":{"url":"Tricks/Game/","title":"游戏","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Image/":{"url":"Tricks/Image/","title":"图像图表软件","keywords":"","body":"内容列表 回到主页 GIMP GIMP快速指南 res 资源(右键打开或下载) GIMP-keys.pdf Origin 使用Graph Anim插件绘制动图 Visio 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Image/GIMP/":{"url":"Tricks/Image/GIMP/","title":"GIMP","keywords":"","body":"内容列表 回到主页 GIMP快速指南 res 资源(右键打开或下载) GIMP-keys.pdf 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Image/GIMP/GIMPDefaultKeys.html":{"url":"Tricks/Image/GIMP/GIMPDefaultKeys.html","title":"GIMP快速指南","keywords":"","body":"GIMP快速指南 打印版 帮助 快捷键 说明 F1 帮助 Shift F1 上下文帮助 选择工具与选区 快捷键 说明 R 矩形选择 E 椭圆形选择 F 自由选择 U 模糊选择/魔术棒 Shift O 按颜色选择 I 智能剪刀 Ctrl A 选中全部 Ctrl I 反向选择 Ctrl Shift A 取消选中 Ctrl Shift L 选择浮动部分 Ctrl Shift L 选择浮动部分 编辑 快捷键 说明 Ctrl Z 撤销上一个操作 Ctrl Y 恢复上一个操作 Ctrl C 复制选择部分 Ctrl X 剪切选择部分 Ctrl V 粘贴到浮动图层 Ctrl H 固定浮动图层 Ctrl Shift C 复制可见部分 Ctrl Shift V 粘贴作为新图像 Ctrl Alt V 粘贴到原位 Delete 清空 Ctrl , 用前景色填充 Ctrl . 用背景色填充 Ctrl ; 用图案填充 绘画工具 快捷键 说明 Shift B 油漆桶填充 A 喷枪 G 渐变工具 N 铅笔 P 刷子/画笔 Shift E 橡皮擦 K 墨水 C 克隆/印章工具 H 修复 Shift U 模糊/锐化 S 污点/涂抹 Shift D 减淡/加深 变换工具 快捷键 说明 Q 对齐 M 移动 Shift M 测量 Shift C 剪裁 Shift R 旋转 Shift S 缩放 Shift H 切变 Shift P 透视 Shift W 3D变换 Shift T 统一变换 Shift L 控制柄变换 Shift F 翻转/镜像 Shift G 框架变换 W 扭曲变换 颜色与综合工具 快捷键 说明 B 路径 T 文本 双击工具按钮 打开工具选项 O 颜色拾取器 X 交换颜色 D 默认颜色 点击调色板 改变至点击颜色 文件 快捷键 说明 Ctrl N 新图像 Ctrl O 打开图像 Ctrl Alt O 作为新图层打开图像 Ctrl D 复制图像 Ctrl 数字键 打开最近图像的第数字个 Ctrl S 保存 Ctrl Shift S 另存为 Ctrl E 导出到 Ctrl Shift S 导出.. Ctrl Q 退出 对话 快捷键 说明 Ctrl L 图层 Ctrl G 渐变 Ctrl P 打印 Ctrl W 关闭窗口 Ctrl Shift T 工具选项 Ctrl Shift B 刷子 Ctrl Shift P 仿照 Ctrl Shift I 信息窗口 Ctrl Shift N 浏览窗口 Enter 设置新值 视图 快捷键 说明 F10 主菜单 Shift F10 or 右键 右键下拉菜单 F11 切换全屏 Shift Q 使能快速掩膜 + 放大 - 缩小 1 原始大小 Ctrl E 调整窗口适合至图像 Ctrl T 使能选区 Ctrl Shift E 调整图像适合至窗口 Shift 滚轮 缩放 Shift J 将图像置于窗口中心 Ctrl 方向键 移动画布 Shift 方向键 移动画布 按下滚轮 拖动 移动画布 按下滚轮 拖动 移动画布 滚轮 垂直移动画布 Ctrl 滚轮 水平移动画布 从尺子拖动到 生成参考线 拖动参考线到尺子 移除参考线 空格 拖动 从尺子中拖下采样点 Ctrl Shift R 使能尺子 Ctrl Shift T 使能参考线 图像 快捷键 说明 Ctrl D 复制图像 Ctrl M 合并可见图层 Ctrl N 新建.. Ctrl Shift N 新建图层 Alt Enter 图像属性 Ctrl Shift D 复制图层 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-01-16 15:08:09 "},"Tricks/Image/Origin/":{"url":"Tricks/Image/Origin/","title":"Origin","keywords":"","body":"内容列表 回到主页 使用Graph Anim插件绘制动图 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Image/Origin/PlotGif.html":{"url":"Tricks/Image/Origin/PlotGif.html","title":"使用Graph Anim插件绘制动图","keywords":"","body":"使用Graph Anim插件绘制动图 概述 Graph Anim插件是由Antoine Couturier开发的，最低版本要求是OriginPro 2017，可以让任何类型的图形动起来，并保存为gif或者mp4。 安装方法 去官网使用大学邮箱注册一个学生版,可以使用6个月的License,只有一个限制是12个窗口. 按照提示下载Origin 安装包,执行之,选择install product,提示输入序列号时,输入邮箱里的序列号; 安装后,在许可证激活窗口,填写邮箱里的Product Key,点击激活. 在Origin里View>Apps>Add Apps中搜索安装Graph Anim.或者去官网搜索Graph Anim,然后拖放到Origin软件主窗口以安装. 使用方法 绘制好静态的图形，打开Graph Anim插件，设置相应的Output File、Animation、Dataplots to Animate等选项，点击Preview预览结果，点击OK自动导出为动图或者视频。 参数设置 Output File：设置导出的文件名及文件格式，可以选gif或者mp4。 Number of Frames：帧数，按需设置，数值越大，时间越长。 Frames per Second：每秒帧数，按需设置，数值越大，速度越快。 Preview：点击该按钮可以预览效果。 Animation：用于设置动画的样式。 Draw：逐渐显示，就像使用画笔绘制一样。可选项包括 Motion Chart：逐行显示，可以设置一起显示的行数。 Morph：一起出现，有5种Morph Style。 Direction：从哪儿开始出现，有Rightward, Leftward和From Center Outwards三种选项。 Add Drawing Pen：选择画笔的类型。 Pen Size：画笔的大小。 Initialization：最初图形是如何出现的，一起出现（Simultaneous），还是依次出现（Sequential）。 Animation Order：选择曲线一起动（Simultaneous），还是依次动（Sequential）。 Effect：曲线如何出现。 Dataplots to Animate：选择哪些曲线要动起来，同时在选择Morph时，可以设置基线，选择从哪儿开始出现。 更多示例文件，下载链接：https://pan.baidu.com/s/1ESlprTJWBLApi7AZq5wCBQ，提取码：sdxo。 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-03-28 08:43:51 "},"Tricks/Image/Visio/":{"url":"Tricks/Image/Visio/","title":"Visio","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Manage/":{"url":"Tricks/Manage/","title":"管理类软件","keywords":"","body":"内容列表 回到主页 Git 结合Github Pages使用GitBook 使用Github的基本流程 本Wiki维护教程 res 资源(右键打开或下载) index.js mermaid.min.js mj-single.js Inlook Inlook - 你的个人工作助手 Inlook用户指南 img 资源(右键打开或下载) res 资源(右键打开或下载) 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Manage/Git/":{"url":"Tricks/Manage/Git/","title":"Git","keywords":"","body":"内容列表 回到主页 结合Github Pages使用GitBook 使用Github的基本流程 本Wiki维护教程 res 资源(右键打开或下载) index.js mermaid.min.js mj-single.js 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Manage/Git/GitbookUsage.html":{"url":"Tricks/Manage/Git/GitbookUsage.html","title":"结合Github Pages使用GitBook","keywords":"","body":"结合Github Pages使用GitBook 参考 概述 GitBook 是一个 Node.js 环境下，用于构建电子书的工具。 GitBook 让你能够使用 Markdown 来编排一本电子书，GitBook 能够根据 Markdown 文档，生成 PDF、ePub 或 Mobi 文档，还可以生成静态网页。 你可以将 GitBook 生成的静态资源放到某个静态网站的托管平台上（如 GitHub Pages），以便他人可以在线阅读你创作的内容。 GitBook 工作在 Node.js 环境下，因此，你需要确保你已经配置好 Node.js 环境。 安装Node.js 下载node.js并安装（可能操作不对，.zip结尾的不知道怎么的不好用，我用的.msi结尾的正常） 测试下是否安装完成, 安装完成后，点击node.exe，输入：console.log(\"Hello,World!\"); 回车能正常显示hello，world就OK 在cmd中设置node.js的文件夹 npm config set prefix \"C:\\Program Files\\nodejs\\node_modules\\node_global\" npm config set cache \"C:\\Program Files\\nodejs\\node_modules\\node_cache\" 新增用户环境变量NODE_PATH,值为C:\\Program Files\\nodejs\\node_modules\\node_global; 设置用户环境变量PATH,把其中node的路径值改成C:\\Program Files\\nodejs\\node_modules\\node_global 如果是公司网络需要设置代理，则设置npm代理和git代理: 设置npm代理: npm config set proxy http://127.0.0.1:1080,npm config set https-proxy http://127.0.0.1:1080; 代理需要认证的话:npm config set proxy http://username:password@server:port,npm config set https-proxy http://username:pawword@server:port; 设置git代理: git config --global http.proxy http://127.0.0.1:1080,git config --global https.proxy https://127.0.0.1:1080 安装 gitbook-cli 通过cmd调用窗口，进入安装nodeJs的目录，输入命令全局安装gitbook gitbook-cli：npm install gitbook-cli -g 如果报错rollbackFailedOptional verb npm-session,则需要把npm代理和git代理去掉:npm config rm proxy,npm config rm https-proxy;git config --global --unset http.proxy,git config --global --unset https.proxy.然后设置镜像源: npm config set registry http://registry.npm.taobao.org,最后检查镜像源npm config get registry. 输入命令：mkdir MyWiki，创建文件夹 执行下面命令，查看 gitbook 的版本，会自动安装Gitbook 3.2.3。 gitbook -V CLI version: 2.3.2 gitbook version: 3.2.3 可能会报错if (cb) cb.apply(this, arguments),　打开polyfills.js文件，在第62-64行调用了这个函数,因此把62-64行注释掉,注释掉之后重新执行gitbook -V查看版本.时间较长,需要耐心等待! 开始 在CMD中找到你要新建gitbook的位置,执行下面命令，gitbook 将完成一些准备工作。 gitbook init 实际上，上面命令生成了下面 2 个文件。 ├── README.md └── SUMMARY.md README.md 将包含电子书的简介 SUMMARY.md 将包含电子书的目录 有了这两个文件，就是一本结构完整的电子书了。 编辑电子书内容 初始化后的目录中会出现README.md（电子书简介文件）和SUMMARY.md（导航目录文件）两个基本文件。除此之外还可以手动新建其它Glossary.md（书尾的词汇表）、book.json（电子书配置文件）。 电子书的正文内容可以根据自己的喜好创建新的后缀为 .md 文件，如“chapter01.md”，然后用 MarkDown 编写具体的文本内容即可。下面对这些文件分别做详细介绍。 README.md 此文件是简单的电子书介绍，可以把您所制作的电子书做一下简单的描述： # 简介 这是我的第一本使用 GitBook 制作的电子书。 SUMMARY.md 此为电子书的导航目录文件，每当新增一个章节文件就需要向此文件中添加一条记录。对于 Kindle 电子书来说，此文件所呈现的目录结构就是开头的目录内容和“前往”的目录导航。 # Summary * [简介](README.md) * [第一章](section1/README.md) * [第二章](section2/README.md) 如果需要“子章节”可以使用 Tab 缩进来实现（最多支持三级标题），如下所示： # Summary * [第一章](section1/README.md) * [第一节](section1/example1.md) * [第二节](section1/example2.md) * [第二章](section2/README.md) * [第一节](section2/example1.md) Glossary.md 对于电子书内容中需要解释的词汇可在此文件中定义。词汇表会被放在电子书末尾。其格式如下所示： # 电子书 电子书是指将文字、图片、声音、影像等讯息内容数字化的出版物和植入或下载数字化文字、图片、声音、影像等讯息内容的集存储和显示终端于一体的手持阅读器。 # Kindle Amazon Kindle 是由 Amazon 设计和销售的电子书阅读器（以及软件平台）。用户可以通过无线网络使用 Amazon Kindle 购买、下载和阅读电子书、报纸、杂志、博客及其他电子媒体。 book.json “book.json”是电子书的配置文件，可以看作是电子书的原数据，比如 title、description、isbn、language、direction、styles 等，更多点击这里查看。它的基本结构如下所示： { \"title\": \"我的第一本電子書\", \"description\": \"用 GitBook 制作的第一本電子書！\", \"isbn\": \"978-3-16-148410-0\", \"language\": \"zh-tw\", \"direction\": \"ltr\" } 普通章节.md 文件 普通章节.md 文件可以使用您感觉顺手的文本编辑器编写。MarkDown 的写法可以点击这里查看相关示例。每编写一个 .md 文件，不要忘了在SUMMARY.md文件中添加一条记录哦。 电子书封面图片 GitBook 帮助文档建议封面图片的尺寸为 1800*2360 像素并且遵循建议： 没有边框 清晰可见的书本标题 任何重要的文字在小版本中应该可见 图片的格式为 jpg 格式。把图片重命名为cover.jpg放到电子书项目文件夹即可。 预览 执行gitbook serve,用浏览器打开 http://localhost:4000，就可以看到电子书的最终效果了。 生成 执行下面命令，就可以将电子书的内容制作成静态网页，并保存在 _book 目录中。 gitbook build 导出为其他电子书文件 确定电子书没有问题后，可以通过输入以下命令生成 mobi 电子书： gitbook mobi ./ ./MyFirstBook.mobi 如果出现以下错误提示，说明您还未安装 Calibre。由于 GitBook 生成 mobi 格式电子书依赖 Calibre 的 ebook-convert，所以请先点击这里下载安装 Calibre。 Error: Need to install ebook-convert from Calibre Calibre 安装完毕后，对于 Mac OS X 系统，还需要先设置一下软链接： ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin 再次运行转换命令，即可生成 mobi 格式电子书。 结合 GitHub Pages GitHub Pages 是 GitHub 提供的静态网站托管服务。 GitHub 上的每个仓库都可以拥有一个 GitHub Pages，对应的 URL 如下：https://.github.io// GitHub Pages 的静态资源支持下面 3 个来源： master 分支 master 分支的 /docs 目录 gh-pages 分支 执行下面命令，在生成静态网页时，将保存的目录指定为 ./docs # 把mds目录下的所有文件编译成为电子书, 输出目录为docs gitbook build ./mds/. ./docs 然后直接推送到 GitHub 仓库。 git push origin master 最后选择仓库的setting,Pages,选择分支main-docs作为主目录,就可以在[username].github.io/[repository name]看到书啦. 将 _book 目录推送到 GitHub 仓库的 gh-pages 分支:git subtree push --prefix=_book origin gh-pages也可以。 更进一步: 使用Gitbook插件定制化页面 GitBook使用基于Node.Js的Gitbook插件对Markdown文件进行渲染. 写配置文件:在根目录新建book.json,在book.json中写入以下代码: { \"plugins\": [ \"back-to-top-button\", \"splitter\", \"code\", \"-lunr\", \"-search\", \"-sharing\", \"toggle-chapters\", \"sharing-plus\", \"search-pro\", \"insert-logo\", \"custom-favicon\", \"pageview-count\", \"tbfed-pagefooter\", \"mind-maps\", \"hide-element\", \"mathjax-single-dollar\", \"forkmegithub\", \"mermaid-gb3\", \"auto-scroll-table\" ], \"pluginsConfig\": { \"insert-logo\": { \"url\": \"./img/logo.png\", \"style\": \"background: none; max-height: 30px; min-height: 30px\" }, \"favicon\": \"./img/inlook.ico\", \"tbfed-pagefooter\": { \"copyright\": \"Copyright &copy charleechan 2021\", \"modify_label\": \"本文最终修订于：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"forkmegithub\": { \"url\": \"https://github.com/your/repo\" }, \"sharing\": { \"douban\": true, \"facebook\": false, \"google\": false, \"hatenaBookmark\": false, \"instapaper\": false, \"line\": false, \"linkedin\": false, \"messenger\": false, \"pocket\": false, \"qq\": true, \"qzone\": false, \"stumbleupon\": false, \"twitter\": true, \"viber\": false, \"vk\": false, \"weibo\": true, \"whatsapp\": false, \"all\": [ \"facebook\", \"google\", \"twitter\", \"weibo\", \"instapaper\", \"linkedin\", \"pocket\", \"stumbleupon\" ] }, \"hide-element\": { \"elements\": [\".gitbook-link\"] } } } CMD中导航到book.json所在目录,执行命令gitbook install,会自动安装book.json中用到的插件. 当然,也可以使用以下命令单独安装: CMD中导航到book.json所在目录,执行以下命令: npm install gitbook-plugin-mermaid-gb3 # wavedrom 插件, 渲染代码块wavedrom为时序图或电路图 npm install gitbook-plugin-wavedrom # 返回顶部按钮 npm install gitbook-plugin-back-to-top-button # 导航目录折叠 npm install gitbook-plugin-chapter-fold # 侧边栏宽度可调节 npm install gitbook-plugin-splitter # 给代码块增加复制代码按钮和行号 npm install gitbook-plugin-code # 分享功能增强 npm install gitbook-plugin-sharing-plus # 高级搜索,支持中英文,准确率更高 npm install gitbook-plugin-search-pro # 个性化网站导航栏的logo npm install gitbook-plugin-insert-logo # 个性化网站的icon npm install gitbook-plugin-custom-favicon # 个性化文章的页脚, 增加版权和修改时间 npm install gitbook-plugin-tbfed-pagefooter # 文档页面阅读数 npm install gitbook-plugin-pageview-count # 思维导图 npm install gitbook-plugin-mind-maps # 隐藏元素 npm install gitbook-plugin-hide-element # 支持mathjax公式 npm install gitbook-plugin-mathjax-single-dollar # 右上角添加fork me 丝带 npm install gitbook-plugin-forkmegithub-cn # 表格自动加滚动条 npm install gitbook-plugin-auto-scroll-table # 可以复制本代码块到cmd中,会自动安装 由于插件年久失修, 需要执行以下操作来使插件生效. gitbook build 之前, 将文件mermaid.min.js分别拷贝到\\node_modules\\gitbook-plugin-mermaid-gb3\\dist\\mermaid和\\node_modules\\mermaid\\dist目录,进行文件替换. 本命令已经写入文件GitbookBuild.bat,因此在不用每次执行. 如果公式中加了化学方程式，长等号，长箭头，colorbox等，则要在.md的最底部加入以下代码 MathJax.Hub.Config({ TeX: { extensions: [\"extpfeil.js\",\"color.js\",\"mhchem.js\"] }}); 可以修改node_modules\\gitbook-plugin-tbfed-pagefooter\\index.js,在页脚添加自定义内容,可以修改为文件index.js的内容。 问题警告 gitbook 3.2.3版本生成的本地HTML无法跳转,而gitbook 2.6.7版本可以跳转. gitbook 2.6.7版本不能使用search-pro插件,因此不能使用中文搜索功能. 综上, 强烈建议使用gitbook 3.2.3版本, 网站端HTML可以正常跳转的. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-03-30 17:26:20 "},"Tricks/Manage/Git/GithubUsage.html":{"url":"Tricks/Manage/Git/GithubUsage.html","title":"使用Github的基本流程","keywords":"","body":"使用Github的基本流程 下载Git 搜索“Git”，在官网中根据系统版本下载，并双击打开，按默认已勾选组件点下一步; 勾选在Windows命令行窗口中使用Git； 使用推荐的OpenSSL库用于HTTPS连接； 一路默认安装即可。 配置SSH Key 1.如果C:\\uers[user] 没有.ssh文件夹，需要创建SSH Key： ssh-keygen -t rsa -C \"charleechan@163.com\" 2.把生成的key填写到Github中,在右上角头像的Settings的SSH and GPG keys那里填,title随便写,主要是用来注明的 使用命令 `clip 使用Git 命令创建仓库 新建本地仓库 双击打开Git Bash，配置你的GitHub用户： git config --global user.name \"charleechan\" git config --global user.email \"charleechan@163.com\" 键入你要新建仓库的位置，如：cd /d/Code/charleechan.github.io 开始创建代码仓库：git init 关联远程仓库 新建远程仓库，注意不要勾选添加Readme!!!!!注意不要勾选添加Readme!!!!!注意不要勾选添加Readme!!!!! 首先与远程库创建关联：`git remote add origin https://github.com/[Github用户名]/[仓库名]`或`git remote add origin git@github.com:charleechan/charleechan.github.io.git` > 在创建好Github仓库后有两个地址,一个是https的地址,另一个是SSH地址,也就是上面这个地址. 切换到分支git checkout -b main,其中main是分支名 如果勾选了，你需要先将远程库的文件合并到本地库：`git pull --rebase origin main` ,其中main是分支名 在该文件夹下新建代码文件即可，这里方便测试，新建test.txt，输入命令 git add . 添加所有文件 git add test.txt 添加单个文件 git status 查看git状态 git commit -m \"It's my Test WebPage file.\" 上传到仓库(首次上传需要登陆账户密码)：git push -u origin main (执行这个之前必须先在本地做一次提交操作,其中main是分支名) 查看上传日志: git log 更进一步 当然, 有很多时候,我们需要忽略本地特定目录下的文件,例如:Python的依赖库PyhtonLibs,或者node.js的组件node_modules文件夹都不需要上传到github,这时,要设置忽略文件夹: 在git bash中输入touch .gitignore,新建一个文件.gitignore; 可以使用notepad++或VS code编辑该文件,在其中添加./node_modules/ 注意尽量在最后添加/ 分别执行以下命令git rm -r --cached . git add . git commit -m \"update .gitignore\" Github Host更新及常见问题 Hosts文件 # Github Hosts # Update 20210312 140.82.112.3 github.com 140.82.112.10 nodeload.github.com 140.82.114.6 api.github.com 13.229.189.0 codeload.github.com 185.199.110.133 raw.github.com 185.199.110.153 training.github.com 185.199.110.153 assets-cdn.github.com 185.199.110.153 documentcloud.github.com 185.199.110.154 help.github.com 185.199.110.153 githubstatus.com 199.232.69.194 github.global.ssl.fastly.net 185.199.110.133 raw.githubusercontent.com 185.199.110.133 cloud.githubusercontent.com 185.199.110.133 gist.githubusercontent.com 185.199.110.133 marketplace-screenshots.githubusercontent.com 185.199.110.133 repository-images.githubusercontent.com 185.199.110.133 user-images.githubusercontent.com 185.199.110.133 desktop.githubusercontent.com 185.199.110.133 avatars.githubusercontent.com 185.199.110.133 avatars0.githubusercontent.com 185.199.110.133 avatars1.githubusercontent.com 185.199.110.133 avatars2.githubusercontent.com 185.199.110.133 avatars3.githubusercontent.com 185.199.110.133 avatars4.githubusercontent.com 185.199.110.133 avatars5.githubusercontent.com 185.199.110.133 avatars6.githubusercontent.com 185.199.110.133 avatars7.githubusercontent.com 185.199.110.133 avatars8.githubusercontent.com # End of the section 问题: 使用git命令显示错误fatal: unable to access '××': OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054 解决办法: 首先执行命令git config http.sslVerify \"false\", 若出现错误fatal: not in a git directory,则继续执行git config --global http.sslVerify \"false\"即可. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-06 17:32:57 "},"Tricks/Manage/Git/UpdateThisSite.html":{"url":"Tricks/Manage/Git/UpdateThisSite.html","title":"本Wiki维护教程","keywords":"","body":"本Wiki维护教程 在已有分类的路径下添加markdown文件,需满足以下要求; 请把文件名设置为 英文开头，且只有英文和数字, 后缀名为.md; 文件内容的第一个非空行将作为内容索引, 因此: 第一个非空行中禁止链接和行内代码. 第一个非空行最好是中文名。 如果要新建分类,需要修改GenSideBarNav.py和GenMindImage.py脚本中的main()函数. 运行脚本GitbookBuild.bat,本脚本将自动: 运行根目录的GenMindImage.py脚本, 将为每个子分类建立目录页(README.md) 运行根目录的GenSideBarNav.py脚本, 将更新mds目录下的SUMMARY.md文件，以建立侧边栏目录。 自动编译生成Gitbook的网页文件(./docs). 自动打开浏览器预览本地电子书. 警告: 使用脚本GitbookResetReadMe.bat会将所有分类的目录页置为404页面. 本站通过脚本自动生成目录(导航)页,但前提是有本地已经安装了Python. 如果还没安装,需要把pythonlib.zip 放在与脚本同一目录,并解压到当前文件夹.并修改GitbookBuild.bat的10~13行. MyWiki |--docs : gitbook build生成的网页,xxx.github.io从本文件夹读取生成Pages. |--mds | |--README.md | |--SUMMARY.md | |--node_modules | |--Coding | |--SoftTuto | |--img : 包含网页logo. | |--pythonlib : | |--python.exe | |... | |--GitbookBuild.bat : 一键生成导航页的脚本,会使用脚本 GenMindImage.py 和 GenSideBarNav.py |--GenMindImage.py, GenSideBarNav.py : python脚本,不可删除. |--GitbookResetReadMe.bat : 一键置404,用处不大. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-01-26 16:12:47 "},"Tricks/Manage/Inlook/":{"url":"Tricks/Manage/Inlook/","title":"Inlook","keywords":"","body":"内容列表 回到主页 Inlook - 你的个人工作助手 Inlook用户指南 img 资源(右键打开或下载) res 资源(右键打开或下载) 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Manage/Inlook/InlookIsReleased.html":{"url":"Tricks/Manage/Inlook/InlookIsReleased.html","title":"Inlook - 你的个人工作助手","keywords":"","body":"Inlook - 你的个人工作助手 Inlook是为在桌面上直观地提醒用户收到未读邮件和日程安排而开发的软件。本发布版仅限Windows 10. 开发者可基于此项目自由开发其他平台的版本。 使用截图 声明: 如无特大bug,本软件将暂时不再发布新版本. 下载 点我下载 提取码 a1b2 用户使用说明 功能特点 新邮件到达时自动弹窗提醒. 列出从昨天到未来6天的日程. 支持解锁、锁定窗口大小和位置. 窗口放在桌面最底层,不影响游戏和工作. 网速和占用RAM监控. 支持鼠标穿透,提高工作效率. 智能缩放,根据邮箱数目和日程项数自动规划窗口大小. 支持中文界面!默认设置为中文. 每日一句古诗词,鼠标放上去可以查看自己的IP. 版本发布 2021.01.27 1.0.0.3 在中文界面增加每日诗词. 2021.01.19 1.0.0.2 增加用户登录账户验证功能, 修复Bug: 第二次网络中断后连接造成崩溃 2021.01.15 1.0.0.1 增加对中文界面的支持. 2020.12.29 1.0.0.0 初始版本发布 利益声明 GNU General Public License v3.0 用户提醒 添加你的邮箱账户可以实现新邮件提醒, 你需要提前获取你的邮箱的IMAP的服务器信息，部分邮箱如163，QQ邮箱登录时需要授权码而不是密码。 在本软件和手机自带的日历中添加同一个Exchange账户(我自己测试的是Outlook),可以实现日程多端自动同步, 日程提醒。 任何时候可以直接在托盘修改语言,无需重启软件. 自1.0.0.1发布版之后,去除了快捷方式的开机启动,如有需要,请自行生成指向start.bat的快捷方式,并拖放到C:\\Users\\[username]\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup目录. 其他 自己为了自己用写的软件，代码全部开源，你可以下载后直接修改作为自己喜欢的版本； 因使用本软件产生的问题，后果自负； 本软件中用到了PyQt,exchangelib,需自觉遵守开源协议，禁止商用； 自己的Win10上用的很好,可能不自动适配你的电脑屏幕，请自行修改，也希望能帮我改，可以一块合作。 后续可能会添加Launcher面板，可以放几个小工具。 支持请发热心和好评，欢迎一起Debug. 为了一些人的使用方便，添加了桌面快捷方式,如果需要去除，请到系统文件夹内删除快捷方式即可。 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-01-28 11:57:37 "},"Tricks/Manage/Inlook/InlookUsage.html":{"url":"Tricks/Manage/Inlook/InlookUsage.html","title":"Inlook用户指南","keywords":"","body":"Inlook用户指南 安装 点我下载 (提取码 a1b2) 双击Inlook V1.0.0.3.exe,选择目标文件夹到你想安装的目录(建议路径不要有中文) 点击安装. 安装过程会将所有源码解压到安装目录,写得不好请见谅,欢迎大佬指导. 完成安装,可以看到桌面已经生成快捷方式(链接到安装目录的start.bat). 添加邮箱账户 安装完成后, 会自动弹出登录窗口,在窗口中登录你的邮箱. 账户别称: 你给这个邮箱账户起的名字,后面会显示在软件中. 服务器: 去邮箱官网的帮助中心,查询邮箱的IMAP服务器. QQ邮箱的IMAP服务器imap.qq.com; 163邮箱的IMAP服务器imap.163.com; 其他服务器请在邮箱首页的帮助中心查看. 你的邮箱需要开启IMAP服务, QQ邮箱开启方法, 163邮箱开启方法. 账户名: 填写你的邮箱地址. 密码: 填写你的邮箱密码. 如果是163邮箱和QQ邮箱,需要填写授权码. 查看163邮箱的授权码获取方法,QQ邮箱的授权码获取方法. 网站: 填写邮箱的网页站点，如mail.163.com,mail.qq.com,mail.cstnet.cn等. 点击登录,弹出超大登录成功消息 可以看到已经在Windows桌面出现啦~~ 如果需要继续添加邮箱账户,请点击添加账户按钮. 添加Exchange账户 这里以添加outlook账户为例. 点击主页面添加账户按钮,选择账户类型为Exchange. 填写账户信息 账户别称: 你给这个账户起的名字,后面会显示在软件中. 服务器: 去邮箱官网的帮助中心,查询邮箱的Exchange服务器. Outlook账户的服务器eas.outlook.com 账户名: 你的 Exchange 账户 密码: 相应的账户密码 网站: 填写Exchange的网页站点，如outlook.live.com等. 点击登录,弹出超大登录成功消息 可以看到已经在Windows桌面出现啦~~ 主页面已经可以看到日程和邮箱未读数. 手机添加Exchange账户 这里以菊厂的自带日历为例.其他手机应该没别的问题,有问题也别找我,不归我负责. 打开华为日历，点击右上角三个点-点日历账户管理-点添加账户； 填写登陆账户信息，地址填写邮箱地址，密码为邮箱登录密码。 Exchange账户登陆成功就可以正常进行账户同步, 可以设置你的同步周期为15分钟。 添加日程 点击主页面添加日程按钮,弹出添加日程对话框. 填写添加日程的信息. 点击确认. 一分钟后,可以看到主页面已经自动同步到了 Inlook 的窗口,窗口大小根据日程数目自适应伸缩. 查看手机,也可以看到了 如果没有看到,是你的手机同步频率设置得低了,反正不是我的锅, 你需要在手机这边 手动同步 一下. 到时候后本软件自动强力提醒, 应该是 半分钟之内无法关闭的窗口 , 同时伴随 魔力铃声 . 你在手机端删除日程,Inlook也会同步删除哦~ 移动和缩放界面 切换语言及鼠标穿透 中文界面的每日一句功能有jinrishici API提供,感谢！ 英文界面的每日一句功能有爱词霸提供,感谢！ 鼠标穿透功能可以让Inlook停止捕获鼠标,安静地躺在桌面最下层,不影响你的正常办公~ 提醒 添加你的邮箱账户可以实现新邮件提醒, 你需要提前获取你的邮箱的IMAP的服务器信息，部分邮箱如163，QQ邮箱登录时需要授权码而不是密码。 在本软件和手机自带的日历中添加同一个Exchange账户(我自己测试的是Outlook),可以实现日程多端自动同步, 日程提醒。 任何时候可以直接在托盘修改语言,无需重启软件. 自1.0.0.1发布版之后,去除了快捷方式的开机启动,如有需要,请自行生成指向start.bat的快捷方式,并拖放到C:\\Users\\[username]\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup目录. 其他说明 自己为了自己用写的软件，代码全部开源，你可以下载后直接修改作为自己喜欢的版本； 因使用本软件产生的问题，后果自负； 本软件中用到了PyQt,exchangelib,需自觉遵守开源协议，禁止商用； 自己的Win10上用的很好,可能不自动适配你的电脑屏幕，请自行修改，也希望能帮我改，可以一块合作。 支持请发热心和好评，欢迎一起Debug. 为了使用方便，添加了桌面快捷方式,如果需要去除，请到系统文件夹内删除快捷方式即可。 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-01-28 11:56:59 "},"Tricks/Music/":{"url":"Tricks/Music/","title":"音频软件","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Office/":{"url":"Tricks/Office/","title":"办公软件","keywords":"","body":"内容列表 回到主页 Excel PPT Word 中文学位论文参考文献格式配置 Word中公式中自动编号的最终解决办法 跨行对齐公式与公式代码 Office 2019的ISO制作,安装,与激活 在Word中使用FontAwesome图标 res 资源(右键打开或下载) FontAwesomeFree511.zip FontAwesomePro572.zip 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Office/Excel/":{"url":"Tricks/Office/Excel/","title":"Excel","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Office/PPT/":{"url":"Tricks/Office/PPT/","title":"PPT","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Office/Word/":{"url":"Tricks/Office/Word/","title":"Word","keywords":"","body":"内容列表 回到主页 中文学位论文参考文献格式配置 Word中公式中自动编号的最终解决办法 跨行对齐公式与公式代码 Office 2019的ISO制作,安装,与激活 在Word中使用FontAwesome图标 res 资源(右键打开或下载) FontAwesomeFree511.zip FontAwesomePro572.zip 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Office/Word/CNPaperRefSetting.html":{"url":"Tricks/Office/Word/CNPaperRefSetting.html","title":"中文学位论文参考文献格式配置","keywords":"","body":"中文学位论文参考文献格式配置 mendeley引入并修改GB/T 7714-2005中文标准参考文献 ，解决人名全部大写问题 在mendeley的菜单栏,View->Citation Style->More styles->Get More Stytles 在出现的搜索框中搜索 7714，点击China National Starndard GB/T 7714-2015 (number,Chinese)安装; 在word中使用时发现英文人名都是大写的, 需要修改为首字母大写其余小写的人名样式: mendeley的菜单栏View->Citation Style->More styles->Installed 选中要修改的style->右键->Edit Stytle. 会进入网站页面。 网页左边的层次图中BIBLIOGARPHY> Layout > author (macro) > Names > Name > Name-part，在text-case中将原本的capitalize更换为capitalize-first,查看效果是否符合预期. 修改为首字母大写 修改完成, Style > Save Style As..., 即可自动完成在软件中的安装. 同时也在Mendeley网站存储, 别人可以通过链接https://csl.mendeley.com/styles/617813421/china-national-standard-gb-t-7714-2015-numeric-Chenchuanglu 安装该文件. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-01-20 10:13:16 "},"Tricks/Office/Word/EquationInWord.html":{"url":"Tricks/Office/Word/EquationInWord.html","title":"Word中公式中自动编号的最终解决办法","keywords":"","body":"Word中公式中自动编号的最终解决办法 网上讲述的有两种方式，一种是表格，一种是Tab控制缩进。不喜用表格做束缚，毕竟对于很长的公式，或者很长的编号，边框限制了它的想象，于是想用Tab控制缩进的方式。。。 路漫漫。。 制表位法公式 新建一个word2016文档，打开文档后，点击菜单栏中布局。点击布局选项卡中纸张大小，设置为A4大小。 点击页边距，选择为常规页边距。 在word页面中点击菜单栏插入，点击公式（或者按Alt 和 = 键），弹出列表中选择一个公式，例如二次公式。 插入公式后，在公式后面，点击菜单栏引用>插入题注，标签为公式，勾选从题注中排除标签，点确定自动插入编号。 由于除了公式之外，本行还有一个编号1，因此Word自动识别为行内公式，居左。 右键单击公式所在的行，弹出列表中点击“段落”。打开段落设置窗口，点击左下角的“制表位”。 打开制表位窗口。设置第一个制表位，即公式前面的制表位，在制表位位置处输入：7.32厘米，选择对齐方式为“居中对齐”。点击设置按钮。 继续设置第二个制表位位置，输入位置数值为：17.82厘米，对齐方式选择为“右对齐”，点击确定按钮。 将光标置于公式前面，按下键盘上的Tab键，则公式就会向右移动到第一个制表位的位置。 然后光标置于公式和编号中间，按下键盘上的Tab键，则编号就会移动到第二个制表位的位置。如图所示。 一次偶然地尝试写大型运算符，比如求和运算符的时候， 额，好丑有么有，通过一系列的查询，发现在公式外框的下拉菜单中，选择更改为显示，于是我的公式变成了下面这样 公式是好看了，可编号你妹的，，别跑。。呀。。 经过一系列的折腾，发现此法行不通了，嘤嘤嘤。。。 然鹅，一次偶然发现，原来Word里的公式是自己资瓷编号的，在公式里添加#(1)即可，于是试了试 然后公式框上的下拉菜单选择专用，把公式转变为专业格式，然后就出现了下面这一幕。 咦，挺像那么回事了。。 12. 然鹅！我又然鹅了！能不能在公式中插入题注呢~于是便有了下图。 插入之后，同样按公式框上的下拉菜单选择专用，把公式转变为专业格式，看到编号已经右对齐啦。 然后，怎么知道自动编号有没有用呢，你可以重复上述步骤，然鹅，我是不会这么干的，太慢啦~ 选中已有公式，菜单插入>文档部件>自动图文集> 将所选内容保存到自动图文集，并保存到文档模板normal.dot。 点击菜单中文件>选项>快速访问工具栏>从下列位置选择命令中选择\"插入\"选项卡，双击自动图文集，可以看到右侧已添加自动图文集，点确定将自动图文集添加到快速访问工具栏。 在Word窗口的最左上角，点击自动图文集按钮，选择公式，然后可以插入自动编号的美观大方的Word公式啦。 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-02-04 17:31:53 "},"Tricks/Office/Word/EquationInWord2.html":{"url":"Tricks/Office/Word/EquationInWord2.html","title":"跨行对齐公式与公式代码","keywords":"","body":"跨行对齐公式与公式代码 跨行对齐公式 打开或新建一个Word文档，按Alt+=键，插入一个新的公式，公式菜单默认使用Unicode模式； 输入\\eqarray, 出现一个黑色实心方块； 输入(a+b&=c@b+c+1&=d),然后按，可以看到公式已经完整出现. LaTeX公式代码为A=\\{\\matrix{a&b&c\\\\d&e&f\\\\g&h&j}\\}。 强烈建议使用Latex公式编码, Latex公式大全) Latex公式代码 查询Word官网可以得到，Word中的Latex公式主要有以下几点不同: 不支持\\begin{}和\\end{}，因此要将 \\begin{matrix}***\\end{matrix} 修改为 \\matrix{***} \\begin{cases}***\\end{cases} 修改为 \\cases{***} 花括号写起来更简单，不需要写成\\left\\{，直接使用{即可； 绝对值符号写起来更简单，不需要写成\\left\\vert或\\vert，直接使用|； 不支持关键字\\boxed{}，直接使用\\rect{}。 下面列出了Word中常用的公式： 公式效果 Word中Latex代码 Markdown中公式代码 \\overrightarrow{abc} \\vec{abc} \\overrightarrow{abc} \\widehat{abc} \\hat{abc} \\widehat{abc} \\overline{abc} \\overbar{abc} \\overline{abc} \\overbrace{abc} \\overbrace{abc} \\overbrace{abc} \\left\\{a+\\frac{b}{c}\\right\\} \\left{a+\\frac{b}{c}\\right} \\left\\{a+\\frac{b}{c}\\right\\} \\left(a+\\frac{b}{c}\\right) \\left(a+\\frac{b}{c}\\right) \\left(a+\\frac{b}{c}\\right) \\left\\{\\frac{b}{c}\\left\\vert x+y\\right\\vert\\right\\} \\left{\\frac{b}{c}|x+y|\\right} \\left\\{\\frac{b}{c}\\left\\vert x+y\\right\\vert\\right\\} \\frac{b}{a+c} \\frac{b}{a+c} \\frac{b}{a+c} {_a^b}x{_c^d} {_a^b}x{_c^d} {_a^b}x{_c^d} \\lim_{n\\rightarrow\\infty}{n} \\lim\\below{n\\rightarrow\\infty}{n} \\lim_{n\\rightarrow\\infty}{n} \\begin{matrix}a&b&\\cr&c&d\\cr\\end{matrix} \\matrix{a&b&\\cr&c&d\\cr} \\begin{matrix}a&b&\\cr&c&d\\cr\\end{matrix} \\iint_{a=0}^{\\infty}{a} \\iint_{a=0}^{\\infty}{a} \\iint_{a=0}^{\\infty}{a} \\sqrt[5]{a^2} \\sqrt[5]{a^2} \\sqrt[5]{a^2} 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-02-06 21:09:00 "},"Tricks/Office/Word/MakeOfficeISO.html":{"url":"Tricks/Office/Word/MakeOfficeISO.html","title":"Office 2019的ISO制作,安装,与激活","keywords":"","body":"Office 2019的ISO制作,安装,与激活 缘起 事情的起因是这样的~ 用VISIO画图，发现形状不能检索，搜索后啥也没有~ 上网查询一通后发现，怀疑是语言问题~ 果断卸载Office 2019 专业增强中文版，安装相应的英文版~ 然后就可以用Visio 形状搜索了~ 然鹅，有时候我还想用中文版office怎么办... 微软给了办法是下载 OFFICE显示语言包，中文版的网站 下载不了，用英文版网站 才可以下载该语言包。。 于是下载，双击，发现微软开始疯狂下载语言包~~ 那么问题来了，内网计算机也这么搞吗~我要离线安装包！！ 搜索一通，仍然没找到...于是萌生出一个想法: Office 中文+英文 的ISO。 步骤1-下载 Office tool plus 去 Office Tool Plus官网下载最新的Office Tool Plus，解压之后，您应该能看见 Runtime 文件夹和 setup 文件。 打开Office Tool Plus.exe，点击部署。 步骤2-下载Office 安装文件 下载 Office 安装文件与当前电脑上的 Office 无关，因此不需要考虑电脑上已安装的 Office。 下载 Office 安装文件前，需要确定5个内容： 体系结构：这里选择64位。 体系结构有 32 位和 64 位可以选择，通常情况下，我们只需要创建一个版本的即可。 如果需要分别创建 32 位和 64 位版本的，请先创建一个版本，然后删除现有的 Office 安装文件，再下载并创建另一个版本的。 如果需要创建 32 位和 64 位合集版本，请先下载一个版本，再下载另一个版本。重复的文件会自动跳过，不会重复下载。 通道：这里选择Office 2019 企业长期版 正常情况下，选择“当前通道”、“半年度企业版通道”中的一个即可，其它通道按需选择。 部署模式：这里选择仅下载 为了能下载 Office ISO 文件，请务必将部署模式更改为“仅下载”。 安装模块：这里选择Office部署工具 选择要使用的部署工具。 产品和语言： 在左侧添加你所需要的产品和语言，如果你不添加语言，则使用 Office ISO 进行安装时仍然需要下载语言包。 产品选择： Office 专业增强版2019-批量版+Visio专业版2019-批量版 下面的组件根据需要，这里只选择了word,excel,powerpoint。 语言选择：简体中文(中国)+English(United States) 配置完以上信息后，若 Office Tool Plus 没有提示任何错误信息，点击开始部署，即可下载 Office 安装文件。 步骤3-是否按配置文件自动安装 如果保存当前配置，那么在步骤5中，打开ISO中的Office Tool Plus时，会按配置文件自动安装已选的程序，如Word,Visio等。 如果你不需要自动安装，按下 F5 清空当前配置。 那么如何保存当前配置? 当前的配置信息可以通过点击查看 XML 代码了解，然后点击下拉菜单，点导出配置，可以看到保存了一个configure.xml文件。 为了让用户选择自己需要的组件，这里选择不自动安装，按下 F5 清空当前配置。 步骤4-创建 Office ISO 文件 将部署模式从仅下载更改为创建 ISO 文件，然后点击开始部署，Office Tool Plus 将会提示你选择文件保存位置，这里命名为Office_2019_ProPlus_EN_CN_*****.iso，之后 Office Tool Plus 将会制作 Office ISO 文件并储存。 创建完成之后，您应该验证此 Office ISO 是否可以正常工作。 步骤5-安装Office 专业增强 中文+英文版本 首先卸载目标机器已有的Office。 将刚刚生成的Office ISO 文件拷贝到目标机器上； 双击进行挂载； 双击打开虚拟光驱中的Office Tool Plus.exe： 点是：将会按配置文件自动安装已选的组件，包括word,excel,powerpoint,Visio。 点否：可以自己增加选择其他组件。 步骤6-激活Office 自动激活 清除激活信息，为了避免出现激活信息不正确的问题，请在激活 Office 之前清除旧的 Office 激活信息（如果有）。 一键激活: Office，Visio，Project等：按下键盘上的 Ctrl + P，Office Tool Plus 将会在顶栏显示一个命令输入框，按需复制下面的命令，粘贴后回车以执行操作。 /osppilbyid MondoVolume /osppsethst:kms.loli.beer /osppsetprt:1688 /osppact 手动激活 许可证管理：安装一个 Office 专业增强版2019-批量版-[ProPlus2019Volume]许可证，以及Visio 专业版 2019-批量版-[VisioPro2019Volume]，静静等待许可证安装完成。 设置一个 KMS 地址（可以设置端口为 1688）（KMS 地址在下面有列表）。 kms.loli.beer kms.loli.best kms.cangshui.net kms.iaini.net kms.ddz.red kms.ghpym.com kms.qkeke.com kms.wxlost.com kms.heng07.com kms8.MSGuides.com kms.kuretru.com kms.moeclub.org cy2617.jios.org kms.bige0.com kms.jm33.me kms.zhuxiaole.org windows.kms.app nb.shenqw.win kms.magicwall.org 下列地址因出现问题或不稳定而不推荐使用： kms.mogeko.me (不稳定) kms.03k.org (不稳定) kms2.loli.best kms.ddddg.cn kms.ijio.net home.aalook.com zh.us.to k.zpale.com 点击激活按钮，等待激活完成。 步骤7-增删应用程序（例如 Access，PowerPoint） 在部署页面的应用程序卡片中，将自己想要的应用程序打勾，不想要的取消打勾， 然后点击开始部署，即可增加/卸载指定的应用程序。 如果您想添加一个 Access，但是发现应用程序里面没有 Access 可以选？ 添加一个产品，选择 Access 即可，可以选择 Access 2019/2016 - 批量版，好激活。 步骤8-增删一个或多个产品（语言包同理） Office Tool Plus 中可以在已安装 Office 的情况下增加一个或者多个产品， 添加完成后，直接开始部署即可。 在系统自带的程序管理中，我们可以一次性卸载单个产品。 如果要一次性删除多个产品，在部署页面点击产品/语言的卸载，然后开始部署即可。 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-02-27 18:46:51 "},"Tricks/Office/Word/UseFontAwesomeInWord.html":{"url":"Tricks/Office/Word/UseFontAwesomeInWord.html","title":"在Word中使用FontAwesome图标","keywords":"","body":"在Word中使用FontAwesome图标 下载 Font Awesome Free 511或Font Awesome Pro 572 到本地，并安装改字体，字体名称为 FontAwesome. 在Word中插入符号,选择Font Awesome. 该字体在Visio中应该也是可用的。 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-02-04 11:45:17 "},"Tricks/Plugins/":{"url":"Tricks/Plugins/","title":"插件类","keywords":"","body":"内容列表 回到主页 ChromeExt Floccus配合坚果云同步书签教程 res 资源(右键打开或下载) bookmarks.xbel GIMPPlu GitbookPlu OfficePlu VSCodeExt 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Plugins/ChromeExt/":{"url":"Tricks/Plugins/ChromeExt/","title":"Chrome插件","keywords":"","body":"内容列表 回到主页 Floccus配合坚果云同步书签教程 res 资源(右键打开或下载) bookmarks.xbel 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Plugins/ChromeExt/FloccusSyncYourBookmarks.html":{"url":"Tricks/Plugins/ChromeExt/FloccusSyncYourBookmarks.html","title":"Floccus配合坚果云同步书签教程","keywords":"","body":"Floccus配合坚果云同步书签教程 Floccus支持WebDAV、Nextcloud Bookmarks和本地文件网盘同步。这里配合坚果云,采用的是WebDAV方案. 在坚果云上的准备 在同步文件夹根目录(也就是我的坚果云同一目录)下创建一个文件夹，选择默认不同步到本地，你要同步也可以，名字随意，这里是 floccus. 然后上传一个bookmarks.xbel文件到刚新建的文件夹里面. 接着坚果云账户信息-安全选项-第三方应用管理，创建一个WebDAV应用，获取密码。 Floccus插件安装和设置 安装好了Floccus插件后，点击图标，然后选择XBEL in WebDAV，然后Add Account。 WebDAV的服务器信息就跟着坚果云给你的信息填写上去就可以了,一般应该是: ## WebDAV URL: https://dav.jianguoyun.com/dav/ ## User name: *****@***.com ## Password: ***** ## Bookmarks file path,填写你刚才创建的 文件夹/bookmarks.xbel 书签的目录直接选择根目录就可以了，如果新建的话他是在你现在浏览器书签基础上新建一个同步的书签文件夹。 例如,在PC端Edge里选择根目录为/收藏夹栏/,在Android端的kiwi browser里选择/移动设备书签/就可以啦. 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-01-16 14:23:03 "},"Tricks/Plugins/GIMPPlu/":{"url":"Tricks/Plugins/GIMPPlu/","title":"GIMP插件","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Plugins/GitbookPlu/":{"url":"Tricks/Plugins/GitbookPlu/","title":"Gitbook插件","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Plugins/OfficePlu/":{"url":"Tricks/Plugins/OfficePlu/","title":"Office插件","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Plugins/VSCodeExt/":{"url":"Tricks/Plugins/VSCodeExt/","title":"VSCode插件","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Project/":{"url":"Tricks/Project/","title":"工程/项目软件","keywords":"","body":"内容列表 回到主页 AltiumDesigner CadenceSPB KeilMDK ModelSim MultiSim Others 根据文字生成字符画 Qt SolidWorks VisualStudio Vivado VSCode 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Project/AltiumDesigner/":{"url":"Tricks/Project/AltiumDesigner/","title":"Altium Designer","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Project/CadenceSPB/":{"url":"Tricks/Project/CadenceSPB/","title":"Cadence SPB","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Project/KeilMDK/":{"url":"Tricks/Project/KeilMDK/","title":"Keil MDK","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Project/ModelSim/":{"url":"Tricks/Project/ModelSim/","title":"ModelSim","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Project/MultiSim/":{"url":"Tricks/Project/MultiSim/","title":"MultiSim","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Project/Others/":{"url":"Tricks/Project/Others/","title":"其他","keywords":"","body":"内容列表 回到主页 根据文字生成字符画 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Project/Others/InsertASCIIChartInCode.html":{"url":"Tricks/Project/Others/InsertASCIIChartInCode.html","title":"根据文字生成字符画","keywords":"","body":"根据文字生成字符画 http://patorjk.com/software/taag http://www.network-science.de/ascii/ 根据图片生成字符画 http://www.degraeve.com/img2txt.php http://life.chacuo.net/convertphoto2char 根据流程图生成字符画 http://asciiflow.com/ 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-01-26 09:11:36 "},"Tricks/Project/Qt/":{"url":"Tricks/Project/Qt/","title":"Qt","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Project/SolidWorks/":{"url":"Tricks/Project/SolidWorks/","title":"SolidWorks","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Project/VisualStudio/":{"url":"Tricks/Project/VisualStudio/","title":"Visual Studio","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Project/Vivado/":{"url":"Tricks/Project/Vivado/","title":"Vivado","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Project/VSCode/":{"url":"Tricks/Project/VSCode/","title":"VS Code","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Video/":{"url":"Tricks/Video/","title":"视频软件","keywords":"","body":"内容列表 回到主页 VideoStudio 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "},"Tricks/Video/VideoStudio/":{"url":"Tricks/Video/VideoStudio/","title":"会声会影","keywords":"","body":"内容列表 回到主页 内容概要 正在加载今日诗词.... Copyright © charleechan 2021 all right reserved，powered by GitbookUpdated At: 2021-04-16 19:21:09 "}}